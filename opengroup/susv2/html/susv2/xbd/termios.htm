<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<!-- Copyright 1997 The Open Group, All Rights Reserved -->
<title>General Terminal Interface</title>
</head><body bgcolor=white>
<center>
<font size=2>
The Single UNIX &reg; Specification, Version 2<br>
Copyright &copy; 1997 The Open Group

</font></center><hr size=2 noshade><blockquote>
<center>
<h2><a name = "tag_008">&nbsp;</a>General Terminal Interface</h2>
</center>
<xref type="1" name="genterm"></xref>
This chapter describes a general
terminal interface that is provided to
control
asynchronous communications ports.
It is implementation-dependent whether it
supports network connections or synchronous ports or both.
<h3><a name = "tag_008_001">&nbsp;</a>Interface Characteristics</h3>
<h4><a name = "tag_008_001_001">&nbsp;</a>Opening a Terminal Device File</h4>
When a terminal device file is opened,
it normally
causes the thread to wait until
a connection
is established.
In practice, application programs
seldom open these files;
they are
opened
by special programs and become an
application's standard input, output and error files.
<p>
As described in
<i><a href="../xsh/open.htm">open()</a></i>,
opening
a terminal device file with the O_NONBLOCK
flag clear causes the thread
to block until the terminal device is ready and available.
If CLOCAL mode is not set,
this means blocking until a connection is established.
If
CLOCAL mode is set in the
terminal, or the O_NONBLOCK flag is specified in the
<i><a href="../xsh/open.htm">open()</a></i>,
the
<i><a href="../xsh/open.htm">open()</a></i>
function returns
a file descriptor without waiting for a connection
to be established.
<h4><a name = "tag_008_001_002">&nbsp;</a>Process Groups</h4>
A terminal may have a foreground
process group associated with it.
This foreground
process group plays a special role
in handling signal-generating input characters, as
discussed in
<xref href=specchar><a href="#tag_008_001_009">
Special Characters
</a></xref>.
<p>
A command interpreter process
supporting job control can
allocate the terminal to different jobs,
or process groups, by placing related processes in
a single process group and associating
this process group with the terminal.
A terminal's
foreground process group may be set
or examined by a process, assuming the permission
requirements are met;
see
<i><a href="../xsh/tcget284.htm">tcgetpgrp()</a></i>
and
<i><a href="../xsh/tcset287.htm">tcsetpgrp()</a></i>.
The
terminal interface aids in this allocation
by restricting access to the terminal by processes
that are not in the current
process group;
see
<xref href=termacc><a href="#tag_008_001_004">
Terminal Access Control
</a></xref>.
<p>
When there is no longer any process whose process ID or process
group ID matches the process group ID of the foreground process
group, the terminal will have no foreground process group.
It is unspecified whether the terminal has a foreground process
group when there is a process whose process ID matches the
foreground process ID, but whose process group ID does not.
No actions defined in this specification set, other than allocation of a
controlling terminal or a successful call to
<i><a href="../xsh/tcset287.htm">tcsetpgrp()</a></i>,
will cause a process group to become the foreground process group of
the terminal.
<h4><a name = "tag_008_001_003">&nbsp;</a>The Controlling Terminal</h4>
A terminal may belong to a
process as its controlling terminal.
Each process of a session
that has a controlling terminal has
the same controlling terminal.
A terminal may be the
controlling terminal for at most one
session.
The controlling terminal for a session is
allocated by the session leader in
an implementation-dependent manner.
If a session leader
has no controlling terminal, and opens
a terminal device file that is not already associated
with a session without using the
O_NOCTTY option (see
<i><a href="../xsh/open.htm">open()</a></i>),
it is
implementation-dependent whether the terminal becomes the
controlling terminal of the
session leader.
If a process which
is not a session leader opens a terminal file, or the
O_NOCTTY option is used on
<i><a href="../xsh/open.htm">open()</a></i>,
then that terminal does not become the controlling
terminal of the calling process.
When
a controlling terminal becomes associated with a
session, its foreground process group is
set to the process group of the session
leader.
<p>
The controlling terminal is inherited by a child process during a
<i><a href="../xsh/fork.htm">fork()</a></i>
function call.
A process relinquishes its controlling terminal
when it creates a new session with the
<i><a href="../xsh/setsid.htm">setsid()</a></i>
function;
other processes remaining in the old session that had
this terminal as their controlling terminal continue to have it.
Upon the close of the last file descriptor in the system (whether or
not it is in the current session) associated with the controlling terminal,
it is unspecified whether all processes
that had that terminal as their controlling terminal cease to have any
controlling terminal.
Whether and how a session leader can reacquire a controlling terminal
after the controlling terminal has been relinquished in this fashion
is unspecified.
A process
does not relinquish its controlling terminal simply by closing
all of its file descriptors associated with the controlling terminal
if other processes continue to have it open.
<p>
When a controlling process terminates, the
controlling terminal is dissociated from the
current session, allowing it to be
acquired by a new session leader.
Subsequent access to
the terminal by other processes in
the earlier session may be denied, with attempts to
access the terminal treated as if a
modem disconnect had been sensed.
<h4><a name = "tag_008_001_004">&nbsp;</a>Terminal Access Control</h4>
<xref type="3" name="termacc"></xref>
If a process is in the
foreground process group of its controlling terminal, read operations
are allowed, as described in
<xref href=inproc><a href="#tag_008_001_005">
Input Processing and Reading Data
</a></xref>.
Any attempts by a process in a
background process group to read from
its controlling terminal cause its process
group to be sent a SIGTTIN
signal unless one of the following special cases applies:
if the
reading process is ignoring or blocking
the SIGTTIN signal, or if the process group of the
reading process is orphaned, the
<i><a href="../xsh/read.htm">read()</a></i>
returns -1, with
<i>errno</i>
set to [EIO] and no signal is
sent.
The default action of the SIGTTIN signal
is to stop the process to which it is sent.
See
<i><a href="../xsh/signa248.htm">&lt;signal.h&gt;</a></i>.
<p>
If a process is in the
foreground process group of its controlling terminal, write
operations are allowed as described
in
<xref href=writedata><a href="#tag_008_001_008">
Writing Data and Output Processing
</a></xref>.
Attempts by a process in
a background process group to write to its controlling
terminal will cause the process group
to be sent a SIGTTOU signal unless one of the
following special cases applies:
if TOSTOP
is not set, or if TOSTOP is set and the process
is ignoring or blocking the SIGTTOU
signal, the process is allowed to write to the
terminal and the SIGTTOU signal is
not sent.
If TOSTOP is set, and the process group of
the writing process is orphaned, and
the writing process is not ignoring or blocking the SIGTTOU signal, the
<i><a href="../xsh/write.htm">write()</a></i>
returns -1, with
<i>errno</i>
set to [EIO] and no signal is sent.
<p>
Certain calls that set terminal parameters
are treated in the same fashion as
<i><a href="../xsh/write.htm">write()</a></i>,
except that TOSTOP is ignored; that is,
the effect is identical to that of terminal writes when
TOSTOP is set (see
<xref href=localmodes><a href="#tag_008_002_005">
Local Modes
</a></xref>,
<i><a href="../xsh/tcdrain.htm">tcdrain()</a></i>,
<i><a href="../xsh/tcflow.htm">tcflow()</a></i>,
<i><a href="../xsh/tcflush.htm">tcflush()</a></i>,
<i><a href="../xsh/tcsen285.htm">tcsendbreak()</a></i>
and
<i><a href="../xsh/tcset286.htm">tcsetattr()</a></i>).
<h4><a name = "tag_008_001_005">&nbsp;</a>Input Processing and Reading Data</h4>
<xref type="3" name="inproc"></xref>
A terminal device associated with a
terminal device file may operate in full-duplex mode,
so that data may arrive even
while output is occurring.
Each terminal device file has
an
associated with it,
into which incoming data is stored by the system
before being read by a process.
The system may impose a limit, {MAX_INPUT}, on the
number of bytes that may be
stored in the input queue.
The behaviour of the system when
this limit is exceeded is implementation-dependent.
<p>
Two general kinds of input processing
are available, determined by whether the terminal
device file is in canonical mode
or non-canonical mode.
These modes are described in
<xref href=canon><a href="#tag_008_001_006">
Canonical Mode Input Processing
</a></xref>
and
<xref href=noncanon><a href="#tag_008_001_007">
Non-canonical Mode Input Processing
</a></xref>.
Additionally, input characters
are processed according to the
<b>c_iflag</b>
(see
<xref href=inmodes><a href="#tag_008_002_002">
Input Modes
</a></xref>)
and
<b>c_lflag</b>
(see
<xref href=localmodes><a href="#tag_008_002_005">
Local Modes
</a></xref>)
fields.
Such
processing can include
which in
general means transmitting input characters
immediately back to the terminal when
they are received from the terminal.
This is
useful for terminals that can operate
in full-duplex mode.
<p>
The manner in which data is
provided to a process reading from a terminal device file is
dependent on whether the terminal file
is in canonical or non-canonical mode,
and on whether or not the O_NONBLOCK flag is set by
<i><a href="../xsh/open.htm">open()</a></i>
or
<i><a href="../xsh/fcntl.htm">fcntl()</a></i>.
<p>
If the
O_NONBLOCK flag is clear, then the
read request is blocked until data is available
or a signal has been received.
If the
O_NONBLOCK flag is set, then the read request
is completed, without blocking, in one
of three ways:
<p>
<ol>
<p>
<li>
If there is enough data available to satisfy the
entire request, the
<i><a href="../xsh/read.htm">read()</a></i>
completes successfully and returns the number of bytes read.
<p>
<li>
If there is not enough data available to satisfy
the entire request, the
<i><a href="../xsh/read.htm">read()</a></i>
completes successfully, having read as much data as possible, and
returns the number of bytes it was able to read.
<p>
<li>
If there is no data available, the
<i><a href="../xsh/read.htm">read()</a></i>
returns -1, with
<i>errno</i>
set to [EAGAIN].
<p>
</ol>
<p>
When data is available depends on
whether the input processing mode is canonical or
non-canonical.
The following sections,
<xref href=canon><a href="#tag_008_001_006">
Canonical Mode Input Processing
</a></xref>
and
<xref href=noncanon><a href="#tag_008_001_007">
Non-canonical Mode Input Processing
</a></xref>
describe
each of these input
processing modes.
<h4><a name = "tag_008_001_006">&nbsp;</a>Canonical Mode Input Processing</h4>
<xref type="3" name="canon"></xref>
In canonical mode input processing,
terminal input is processed in units of lines.
A line
is delimited by a newline character (NL),
an end-of-file character (EOF), or an end-of-line
(EOL) character.
See
<xref href=specchar><a href="#tag_008_001_009">
Special Characters
</a></xref>
for more information on EOF
and EOL.
This means that a
read request will not return until an entire line has
been typed or a signal has
been received.
Also, no matter how many bytes are requested
in the
<i><a href="../xsh/read.htm">read()</a></i>
call, at most
one line will be returned.
It is not, however, necessary to read a
whole line at once;
any number
of bytes, even one, may be requested in a
<i><a href="../xsh/read.htm">read()</a></i>
without losing information.
<p>
If {MAX_CANON} is defined for this terminal device, it is
a limit on the number of bytes in a line.
The behaviour
of the system when this limit
is exceeded is implementation-dependent.
If {MAX_CANON} is
not defined, there is no such
limit;
see
<i><a href="../xsh/pathconf.htm">pathconf()</a></i>.
<p>
Erase and kill processing occur when
either of two special characters, the ERASE and
KILL characters (see
<xref href=specchar><a href="#tag_008_001_009">
Special Characters
</a></xref>),
is received.
This processing affects
data in the input queue that
has not yet been delimited by a newline (NL), EOF or EOL
character.
This un-delimited data makes up
the current line.
The ERASE character
deletes the last character in the
current line, if there is one.
The KILL character deletes
all data in the current line,
if there are any.
The ERASE and KILL characters have no
effect if there is no data
in the current line.
The ERASE and KILL characters themselves
are not placed in the input
queue.
<h4><a name = "tag_008_001_007">&nbsp;</a>Non-canonical Mode Input Processing</h4>
<xref type="3" name="noncanon"></xref>
In non-canonical mode input processing, input
bytes are not assembled into lines, and
erase and kill processing does not
occur.
The values of the MIN and TIME members of
the
<b>c_cc</b>
array are used
to determine how to process the bytes received.
The ISO&nbsp;POSIX-1 standard does not specify whether the setting of O_NONBLOCK takes
precedence over MIN or TIME settings.
Therefore, if O_NONBLOCK is set,
<i><a href="../xsh/read.htm">read()</a></i>
may return immediately, regardless of the setting of MIN or TIME.
Also, if no data is available,
<i><a href="../xsh/read.htm">read()</a></i>
may either return 0, or return -1 with
<i>errno</i>
set to [EAGAIN].
<p>
MIN represents the minimum number of
bytes that should be received when the
<i><a href="../xsh/read.htm">read()</a></i>
function returns successfully.
TIME is a
timer of 0.1 second granularity that is used to
time out bursty and short-term data transmissions.
If MIN is greater than {MAX_INPUT},
the response to the request is
undefined.
The four possible values for MIN
and TIME and their interactions are
described below.
<h5><a name = "tag_008_001_007_001">&nbsp;</a>Case A: MIN &gt; 0, TIME &gt; 0</h5>
In this case TIME serves as
an inter-byte timer and is activated after the first byte is
received.
Since it is an inter-byte
timer, it is reset after a byte is received.
The
interaction between MIN and TIME is as
follows.
As soon as one byte is received, the
inter-byte timer is started.
If MIN bytes are
received before the inter-byte timer expires
(remember that the timer is reset
upon receipt of each byte), the read is satisfied.
If the
timer expires before MIN bytes are
received, the characters received to that point are
returned to the user.
Note that
if TIME expires at least one byte is returned because
the timer would not have been
enabled unless a byte was received.
In this case (MIN &gt; 0,
TIME &gt; 0) the read blocks until
the MIN and TIME mechanisms are activated by the
receipt of the first byte, or
a signal is received.
If the data is in the buffer at the time of the
<i><a href="../xsh/read.htm">read()</a></i>,
the result will be as if the data has been received immediately
after the
<i><a href="../xsh/read.htm">read()</a></i>.
<h5><a name = "tag_008_001_007_002">&nbsp;</a>Case B: MIN &gt; 0, TIME = 0</h5>
In this case, since the value
of TIME is zero, the timer plays no role and only MIN is
significant.
A pending read is not
satisfied until MIN bytes are received (that is, the pending
read blocks until MIN bytes
are received), or a signal is received.
A program that
uses this case to read record-based
terminal I/O may block indefinitely in the read
operation.
<h5><a name = "tag_008_001_007_003">&nbsp;</a>Case C: MIN = 0, TIME &gt; 0</h5>
In this case, since MIN = 0,
TIME no longer represents an inter-byte timer.
It now serves
as a read timer that is
activated as soon as the
<i><a href="../xsh/read.htm">read()</a></i>
function is processed.
A read is
satisfied as soon as a single
byte is received or the read timer expires.
Note that in this
case if the timer expires, no
bytes are returned.
If the timer does not expire, the only
way the read can be satisfied
is if a byte is received.
In this case the read will not block
indefinitely waiting for a byte;
if
no byte is received within TIME*0.1 seconds after the
read is initiated, the
<i><a href="../xsh/read.htm">read()</a></i>
returns a value of zero, having read no data.
If the data is in the buffer at the time of the
<i><a href="../xsh/read.htm">read()</a></i>,
the timer is started as if the data has been received immediately
after the
<i><a href="../xsh/read.htm">read()</a></i>.
<h5><a name = "tag_008_001_007_004">&nbsp;</a>Case D: MIN = 0, TIME = 0</h5>
The minimum of either the number
of bytes requested or the number of bytes currently
available is returned without waiting for more bytes to be input.
If no characters are available,
<i><a href="../xsh/read.htm">read()</a></i>
returns a value of zero, having read no data.
<h4><a name = "tag_008_001_008">&nbsp;</a>Writing Data and Output Processing</h4>
<xref type="3" name="writedata"></xref>
When a process writes one or
more bytes to a terminal device file, they are processed
according to the
<b>c_oflag</b>
field (see
<xref href=outmodes><a href="#tag_008_002_003">
Output Modes
</a></xref>).
The implementation may
provide a buffering mechanism;
as such,
when a call to
<i><a href="../xsh/write.htm">write()</a></i>
completes, all of the
bytes written have been scheduled for
transmission to the device, but the transmission
will not necessarily have completed.
See
<i><a href="../xsh/write.htm">write()</a></i>
for the effects of
O_NONBLOCK on
<i><a href="../xsh/write.htm">write()</a></i>.
<h4><a name = "tag_008_001_009">&nbsp;</a>Special Characters</h4>
<xref type="3" name="specchar"></xref>
Certain characters have special functions on
input or output or both.
These functions are
summarised as follows:
<p>
<dl compact>

<dt>INTR<dd>Special character on input, which is recognised if the ISIG flag is
set.
Generates a SIGINT signal which is sent to all processes
in the foreground process group for which the terminal is
the controlling terminal.
If
ISIG is set, the INTR character is discarded when processed.

<dt>QUIT<dd>Special character on input, which is recognised if the ISIG flag is
set.
Generates a SIGQUIT signal which is sent to all processes
in the foreground process group for which the terminal is the
controlling terminal.
If
ISIG is set, the QUIT character is discarded when processed.

<dt>ERASE<dd>Special character on input, which is recognised if the ICANON flag is
set.
Erases the last character in the current line;
see
<xref href=canon><a href="#tag_008_001_006">
Canonical Mode Input Processing
</a></xref>.
It will not erase beyond the
start of a line, as delimited by an NL, EOF or EOL character.
If
ICANON is set, the ERASE character is discarded when processed.

<dt>KILL<dd>Special character on input, which is recognised if the ICANON flag is
set.
Deletes the entire line, as delimited by an NL, EOF or EOL
character.
If ICANON is set, the KILL character is discarded when
processed.

<dt>EOF<dd>Special character on input, which is recognised if the ICANON flag is
set.
When received, all the bytes waiting to be read are
immediately passed to the process without waiting for a newline,
and the EOF is discarded.
Thus, if there are no bytes waiting (that
is, the EOF occurred at the beginning of a line), a byte count of
zero is returned from the
<i><a href="../xsh/read.htm">read()</a></i>,
representing an end-of-file
indication.
If ICANON is set, the EOF character is discarded when
processed.

<dt>NL<dd>Special character on input, which is recognised if the ICANON flag is
set.
It is the line delimiter
newline.
It cannot be changed.

<dt>EOL<dd>Special character on input, which
is recognised if the ICANON flag is
set.
It is an additional line delimiter, like NL.

<dt>SUSP<dd>If the
ISIG flag is set, receipt of the SUSP character causes a
SIGTSTP signal to be sent to all processes in the foreground
process group for which the terminal is the
controlling terminal, and the SUSP character
is discarded when processed.

<dt>STOP<dd>Special character on
both input and output, which is recognised if the
IXON (output control) or IXOFF (input control) flag is set.
Can be used to suspend output
temporarily.
It is useful with CRT terminals to
prevent output from disappearing before it can be read.
If IXON is
set, the STOP character is discarded when processed.

<dt>START<dd>Special character on both input and output, which is recognised if the
IXON (output control) or IXOFF (input control) flag is set.
Can be used to resume
output that has been suspended by a STOP character.
If IXON is
set, the START character is discarded when processed.

<dt>CR<dd>Special character on input, which is recognised if the ICANON flag is
set;
it is the
carriage-return character.
When ICANON and ICRNL are set and IGNCR is
not set, this character is translated into an NL, and has the same
effect as an NL character.

</dl>
<p>
The NL and CR characters cannot
be changed.
It is implementation-dependent whether the
START and STOP characters can be
changed.
The values for INTR, QUIT, ERASE, KILL,
EOF, EOL and SUSP
are changeable to suit individual tastes.
Special character functions
associated with changeable special control characters
can be disabled individually.
<p>
If two or more special characters
have the same value, the function performed when that
character is received is undefined.
<p>
A special character is recognised not
only by its value, but also by its context;
for example, an
implementation may support multi-byte sequences that
have a meaning different from the
meaning of the bytes when considered
individually.
Implementations may also support
additional single-byte functions.
These implementation-dependent multi-byte or single-byte
functions are recognised only if the
IEXTEN flag is set;
otherwise, data is received without
interpretation, except as required to recognise the
special characters defined in this section.
<p>
If IEXTEN is set, the
ERASE, KILL and EOF characters can be escaped by a preceding \
character, in which case no special function occurs.
<h4><a name = "tag_008_001_010">&nbsp;</a>Modem Disconnect</h4>
If a modem disconnect is detected
by the terminal interface for a controlling terminal,
and if CLOCAL is not set
in the
<b>c_cflag</b>
field for the terminal (see
<xref href=conmodes><a href="#tag_008_002_004">
Control Modes
</a></xref>),
the SIGHUP signal is sent
to the controlling process for which the terminal is the controlling
terminal.
Unless other arrangements have been
made, this causes the controlling process
to terminate (see
<i><a href="../xsh/exit.htm">exit()</a></i>).
Any
subsequent read from the terminal device returns
the value of zero, indicating end-of-file.
(See
<i><a href="../xsh/read.htm">read()</a></i>.)
Thus, processes that read a
terminal file and test for end-of-file
can terminate appropriately after a disconnect.
If the EIO condition as specified in
<i><a href="../xsh/read.htm">read()</a></i>
also exists, it is unspecified whether on EOF condition or the
[EIO] is returned.
Any subsequent
<i><a href="../xsh/write.htm">write()</a></i>
to the terminal device
returns -1, with
<i>errno</i>
set to [EIO], until the
device is closed.
<h4><a name = "tag_008_001_011">&nbsp;</a>Closing a Terminal Device File</h4>
The last process to close a
terminal device file causes any output to be sent to the
device and any input to be
discarded.
If HUPCL is set in the control modes and the
communications port supports a disconnect function,
the terminal device will perform a
disconnect.
<h3><a name = "tag_008_002">&nbsp;</a>Parameters that Can be Set</h3>
<h4><a name = "tag_008_002_001">&nbsp;</a>The termios Structure</h4>
Routines that need to control certain
terminal I/O characteristics do so by using the
<b>termios</b> structure as defined in the header
<i><a href="../xsh/termi288.htm">&lt;termios.h&gt;</a></i>.
The members of this structure include (but are not limited to):
<pre>
<table  bordercolor=#000000 border=1 align=center><tr valign=top><th align=center><b>Member Type</b>
<th align=center><b>Array Size</b>
<th align=center><b>Member Name</b>
<th align=center><b>Description</b>
<tr valign=top><td align=left>tcflag_t
<td align=left>&nbsp;
<td align=left>c_iflag
<td align=left>Input modes.
<tr valign=top><td align=left>tcflag_t
<td align=left>&nbsp;
<td align=left>c_oflag
<td align=left>Output modes.
<tr valign=top><td align=left>tcflag_t
<td align=left>&nbsp;
<td align=left>c_cflag
<td align=left>Control modes.
<tr valign=top><td align=left>tcflag_t
<td align=left>&nbsp;
<td align=left>c_lflag
<td align=left>Local modes.
<tr valign=top><td align=left>cc_t
<td align=left>NCCS
<td align=left>c_cc[]
<td align=left>Control characters.
</table>
</pre>
<p>
The types
<b>tcflag_t</b>
and
<b>cc_t</b>
are defined in the header
<i><a href="../xsh/termi288.htm">&lt;termios.h&gt;</a></i>.
They are
unsigned integral types.
<h4><a name = "tag_008_002_002">&nbsp;</a>Input Modes</h4>
<xref type="3" name="inmodes"></xref>
Values of the
<b>c_iflag</b>
field describe the basic
terminal input control, and are composed of the
bitwise inclusive OR of the masks shown, which will be
bitwise distinct.
The mask name symbols in this table are defined in
<i><a href="../xsh/termi288.htm">&lt;termios.h&gt;</a></i>:
<p><table  bordercolor=#000000 border=1 align=center><tr valign=top><th align=center><b>Mask Name</b>
<th align=center><b>Description</b>
<tr valign=top><td align=left>BRKINT
<td align=left>Signal interrupt on break.
<tr valign=top><td align=left>ICRNL
<td align=left>Map CR to NL on input.
<tr valign=top><td align=left>IGNBRK
<td align=left>Ignore break condition.
<tr valign=top><td align=left>IGNCR
<td align=left>Ignore CR.
<tr valign=top><td align=left>IGNPAR
<td align=left>Ignore characters with parity errors.
<tr valign=top><td align=left>INLCR
<td align=left>Map NL to CR on input.
<tr valign=top><td align=left>INPCK
<td align=left>Enable input parity check.
<tr valign=top><td align=left>ISTRIP
<td align=left>Strip character.
<tr valign=top><td align=left>IUCLC
<td align=left>Map upper case to lower case on input. (<b>LEGACY</b>)  
<tr valign=top><td align=left>IXANY
<td align=left>Enable any character to restart output.  
<tr valign=top><td align=left>IXOFF
<td align=left>Enable start/stop input control.
<tr valign=top><td align=left>IXON
<td align=left>Enable start/stop output control.
<tr valign=top><td align=left>PARMRK
<td align=left>Mark parity errors.
</table>
<p>
In the context of asynchronous serial
data transmission, a break condition is defined as a
sequence of zero-valued bits that continues
for more than the time to send one byte.
The
entire sequence of zero-valued bits is
interpreted as a single break condition, even if it
continues for a time equivalent to
more than one byte.
In contexts other than
asynchronous serial data transmission, the definition
of a break condition is
implementation-dependent.
<p>
If IGNBRK is set, a break condition detected on input is ignored that
is, not put on the input queue and therefore not read by any process.
If IGNBRK is not set and BRKINT is set, the break condition will
flush the input and output queues, and if the terminal is the
controlling terminal of a foreground process group, the break
condition will generate a single SIGINT signal to that foreground
process group.
If neither IGNBRK nor BRKINT is set, a break condition
is read as a single
0x00, or if PARMRK is set,
as 0xff 0x00 0x00.
<p>
If IGNPAR is set, a byte
with a framing or parity error (other than break) is ignored.
<p>
If PARMRK is set,
and IGNPAR is not set, a byte with a framing or parity error (other
than break) is given to the
application as the three-byte sequence
0xff 0x00 X,
where 0xff 0x00 is a two-byte
flag preceding each sequence and X is the data of
the byte received in error.
To avoid ambiguity in this case, if ISTRIP is not set, a
valid byte of 0xff is given
to the application as 0xff 0xff.
If neither
PARMRK nor IGNPAR is set, a
framing or parity error (other than break) is given to the
application as a single byte 0x00.
<p>
If INPCK is set, input parity
checking is enabled.
If INPCK is not set, input parity
checking is disabled, allowing output parity
generation without input parity errors.
Note
that whether input parity checking is
enabled or disabled is independent of whether parity
detection is enabled or disabled (see
<xref href=conmodes><a href="#tag_008_002_004">
Control Modes
</a></xref>).
If parity detection is
enabled but input parity checking is
disabled, the hardware to which the terminal is
connected will recognise the parity bit
but the terminal special file will not check
whether or not this bit is correctly set.
<p>
If ISTRIP is set, valid input
bytes are first stripped to seven bits, otherwise all eight bits
are processed.
<p>
If INLCR is set, a received
NL character is translated into a CR
character.
If IGNCR is set,
a received CR character is ignored
(not read).
If IGNCR is not set and ICRNL is set, a
received CR character is translated into
an NL character.
<p>
If IUCLC is set,
upper- to lower-case mappings are performed
on the received character.
In locales other than the POSIX locale,
the mapping is unspecified. (<b>LEGACY</b>)
<p>
If IXANY is set, any input character will restart output
that has been suspended.
<p>
If IXON is set, start/stop output control is enabled.
A received STOP character suspends output and a received START
character restarts output.
When IXON is set, START and STOP characters are not
read, but merely perform flow control functions.
When IXON is not set, the START and STOP characters are read.
<p>
If IXOFF is set, start/stop input
control is enabled.
The system transmits STOP
characters, which are intended to cause
the terminal device to stop transmitting data, as
needed to prevent the
input queue from
overflowing and causing undefined behaviour,
and transmits START characters,
which are intended to cause the
terminal device to resume transmitting data,
as soon as the device can continue
transmitting data without risk of overflowing
the input queue.
The precise conditions
under which STOP and START characters
are transmitted are implementation-dependent.
<p>
The initial input control value after
<i><a href="../xsh/open.htm">open()</a></i>
is implementation-dependent.
<h4><a name = "tag_008_002_003">&nbsp;</a>Output Modes</h4>
<xref type="3" name="outmodes"></xref>
The
<b>c_oflag</b>
field specifies the terminal
interface's treatment of output, and is composed of the
bitwise inclusive OR of the masks shown, which will be
bitwise distinct.
The mask name symbols in this table are defined
in
<i><a href="../xsh/termi288.htm">&lt;termios.h&gt;</a></i>:
<br>
<p><table  bordercolor=#000000 border=1 align=center><tr valign=top><th align=center><b>Mask Name</b>
<th align=center><b>Description</b>
<tr valign=top><td align=left>OPOST
<td align=left><i>Perform output processing.</i>
<tr valign=top><td align=left>OLCUC
<td align=left><i>Map lower case to upper on output. (<b>LEGACY</b>)</i>
<tr valign=top><td align=left>ONLCR
<td align=left><i>Map NL to CR-NL on output.</i>
<tr valign=top><td align=left>OCRNL
<td align=left><i>Map CR to NL on output.</i>
<tr valign=top><td align=left>ONOCR
<td align=left><i>No CR output at column 0.</i>
<tr valign=top><td align=left>ONLRET
<td align=left><i>NL performs CR function.</i>
<tr valign=top><td align=left>OFILL
<td align=left><i>Use fill characters for delay.</i>
<tr valign=top><td align=left>OFDEL
<td align=left><i>Fill is DEL, else NUL.</i>
<tr valign=top><td align=left>NLDLY
<td align=left><i>Select newline delays:</i>
<tr valign=top><td align=left>NL0
<td align=left><i>Newline character type 0</i>
<tr valign=top><td align=left>NL1
<td align=left><i>Newline character type 1.</i>
<tr valign=top><td align=left>CRDLY
<td align=left><i>Select carriage-return delays:</i>
<tr valign=top><td align=left>CR0
<td align=left><i>Carriage-return delay type 0</i>
<tr valign=top><td align=left>CR1
<td align=left><i>Carriage-return delay type 1</i>
<tr valign=top><td align=left>CR2
<td align=left><i>Carriage-return delay type 2</i>
<tr valign=top><td align=left>CR3
<td align=left><i>Carriage-return delay type 3.</i>
<tr valign=top><td align=left>TABDLY
<td align=left><i>Select horizontal-tab delays:</i>
<tr valign=top><td align=left>TAB0
<td align=left><i>Horizontal-tab delay type 0</i>
<tr valign=top><td align=left>TAB1
<td align=left><i>Horizontal-tab delay type 1</i>
<tr valign=top><td align=left>TAB2
<td align=left><i>Horizontal-tab delay type 2.</i>
<tr valign=top><td align=left>TAB3
<td align=left><i>Expand tabs to spaces.</i>
<tr valign=top><td align=left>BSDLY
<td align=left><i>Select backspace delays:</i>
<tr valign=top><td align=left>BS0
<td align=left><i>Backspace-delay type 0</i>
<tr valign=top><td align=left>BS1
<td align=left><i>Backspace-delay type 1.</i>
<tr valign=top><td align=left>VTDLY
<td align=left><i>Select vertical-tab delays:</i>
<tr valign=top><td align=left>VT0
<td align=left><i>Vertical-tab delay type 0</i>
<tr valign=top><td align=left>VT1
<td align=left><i>Vertical-tab delay type 1.</i>
<tr valign=top><td align=left>FFDLY
<td align=left><i>Select form-feed delays:</i>
<tr valign=top><td align=left>FF0
<td align=left><i>Form-feed delay type 0</i>
<tr valign=top><td align=left>FF1
<td align=left><i>Form-feed delay type 1.</i>
</table>
<p>
If OPOST is set, output data
is post-processed
as described below, so that
lines of text are modified to
appear appropriately on the terminal device; otherwise,
characters are transmitted without change.
<p>
If OLCUC is set,
lower- to upper-case mappings are performed
on the characters before they are transmitted.
In locales other than the POSIX locale,
the mapping is unspecified.
(<b>LEGACY</b>) 
<p>
If ONLCR is set, the NL
character is transmitted as the CR-NL
character pair.
If OCRNL
is set, the CR character is transmitted as the NL character.
If ONOCR is set, no CR
character is transmitted when at column 0 (first position).
If ONLRET is set, the NL
character is assumed to do the carriage-return function;
the column pointer will be set to 0 and the delays specified
for CR will be used.
Otherwise the NL
character is assumed
to do just the line-feed function;
the column pointer will remain unchanged.
The column pointer is also set to 0 if the CR
character is actually transmitted.
<p>
The delay bits specify how long
transmission stops to allow for mechanical or other movement
when certain characters are sent to the terminal.
In all cases a value of 0 indicates no delay.
If OFILL
is set,
fill characters will be transmitted
for delay instead of a timed delay.
This is useful for high baud rate terminals
which need only a minimal delay.
If OFDEL
is set,
the fill character is DEL,
otherwise NUL.
<p>
If a form-feed or vertical-tab delay is specified,
it lasts for about 2 seconds.
<p>
New-line delay lasts about 0.10 seconds.
If ONLRET
is set, the carriage-return delays are
used instead of the newline delays.
If OFILL
is set,
two fill characters will be transmitted.
<p>
Carriage-return delay type 1 is dependent on the current column
position,
type 2 is about 0.10 seconds,
and type 3 is about 0.15 seconds.
If OFILL is set,
delay type 1 transmits two fill characters,
and type 2, four fill characters.
<p>
Horizontal-tab delay type 1 is dependent on the current
column position.
Type 2 is about 0.10 seconds.
Type 3 specifies that tabs are to be expanded into spaces.
If OFILL
is set,
two fill characters will be transmitted for any delay.
<p>
Backspace delay lasts about 0.05 seconds.
If OFILL
is set,
one fill character will be transmitted.
<p>
The actual delays depend on line speed and system load.
<p>
The initial output control value after
<i><a href="../xsh/open.htm">open()</a></i>
is implementation-dependent.
<h4><a name = "tag_008_002_004">&nbsp;</a>Control Modes</h4>
<xref type="3" name="conmodes"></xref>
The
<b>c_cflag</b>
field describes the hardware control of the terminal,
and is composed of the bitwise inclusive OR of the masks shown, which will be
bitwise distinct.
The mask name symbols in this table are defined in
<i><a href="../xsh/termi288.htm">&lt;termios.h&gt;</a></i>;
not all values specified are required to be supported by 
the underlying hardware:
<pre>
<table  bordercolor=#000000 border=1 align=center><tr valign=top><th align=center><b>Mask Name</b>
<th align=center><b>Description</b>
<tr valign=top><td align=left>CLOCAL
<td align=left>Ignore modem status lines.
<tr valign=top><td align=left>CREAD
<td align=left>Enable receiver.
<tr valign=top><td align=left>CSIZE
<td align=left>Number of bits transmitted or received per byte:
<tr valign=top><td align=left>   CS5
<td align=left>   5 bits
<tr valign=top><td align=left>   CS6
<td align=left>   6 bits
<tr valign=top><td align=left>   CS7
<td align=left>   7 bits
<tr valign=top><td align=left>   CS8
<td align=left>   8 bits.
<tr valign=top><td align=left>CSTOPB
<td align=left>Send two stop bits, else one.
<tr valign=top><td align=left>HUPCL
<td align=left>Hang up on last close.
<tr valign=top><td align=left>PARENB
<td align=left>Parity enable.
<tr valign=top><td align=left>PARODD
<td align=left>Odd parity, else even.
</table>
</pre>
<p>
In addition, the input and output
baud rates are stored in the
<b>termios</b>
structure.
The following values are supported:
<pre>
<table  bordercolor=#000000 border=1 align=center><tr valign=top><th align=center><b>Name</b>
<th align=center><b>Description</b>
<th align=left>Name
<th align=center><b>Description</b>
<tr valign=top><td align=left>B0
<td align=left>Hang up
<td align=left>B600
<td align=left>600 baud
<tr valign=top><td align=left>B50
<td align=left>50 baud
<td align=left>B1200
<td align=left>1200 baud
<tr valign=top><td align=left>B75
<td align=left>75 baud
<td align=left>B1800
<td align=left>1800 baud
<tr valign=top><td align=left>B110
<td align=left>110 baud
<td align=left>B2400
<td align=left>2400 baud
<tr valign=top><td align=left>B134
<td align=left>134.5 baud
<td align=left>B4800
<td align=left>4800 baud
<tr valign=top><td align=left>B150
<td align=left>150 baud
<td align=left>B9600
<td align=left>9600 baud
<tr valign=top><td align=left>B200
<td align=left>200 baud
<td align=left>B19200
<td align=left>19200 baud
<tr valign=top><td align=left>B300
<td align=left>300 baud
<td align=left>B38400
<td align=left>38400 baud
</table>
</pre>
<p>
The following interfaces are provided for
getting and setting the values of the input and
output baud rates in the 
<b>termios</b>
structure:
<i><a href="../xsh/cfget18.htm">cfgetispeed()</a></i>,
<i><a href="../xsh/cfget19.htm">cfgetospeed()</a></i>,
<i><a href="../xsh/cfset20.htm">cfsetispeed()</a></i>
and
<i><a href="../xsh/cfset21.htm">cfsetospeed()</a></i>.
The effects on the terminal device do not become effective 
and not all errors are detected until the
<i><a href="../xsh/tcset286.htm">tcsetattr()</a></i>
function is successfully called.
<br>
<p>
The CSIZE bits specify the number of transmitted or received bits
per byte.
If ISTRIP is not set, the value of all the other bits is
unspecified.
If ISTRIP is set, the value of
all but the 7 low-order bits is zero,
but the value of any other bits beyond CSIZE is unspecified when read.
CSIZE does not include the
parity bit, if any.
If CSTOPB is set, two stop bits are used,
otherwise one stop bit.
For example,
at 110 baud, two stop bits are normally used.
<p>
If CREAD is set, the receiver
is enabled.
Otherwise, no characters will be received.
<p>
If PARENB is set, parity generation
and detection is enabled and a parity bit is added to
each byte.
If parity is enabled,
PARODD specifies odd parity if set, otherwise even
parity is used.
<p>
If HUPCL is set, the modem
control lines for the port are lowered when the last
process with the port open closes
the port or the process terminates.
The modem
connection is broken.
<p>
If CLOCAL is set, a connection
does not depend on the state of the modem status lines.
If
CLOCAL is clear, the modem status
lines are monitored.
<p>
Under normal circumstances, a call to
the
<i><a href="../xsh/open.htm">open()</a></i>
function waits for the modem connection to complete.
However, if the O_NONBLOCK flag is set (see
<i><a href="../xsh/open.htm">open()</a></i>)
or if CLOCAL has been set, the
<i><a href="../xsh/open.htm">open()</a></i>
function returns immediately without waiting for the connection.
<p>
If the object for which the
control modes are set is not an asynchronous serial connection,
some of the modes may be
ignored; for example, if an attempt is made to set the baud rate on a
network connection to a terminal on
another host, the baud rate may or may not be set on
the connection between that terminal and
the machine to which it is directly connected.
<p>
The initial hardware control value after
<i><a href="../xsh/open.htm">open()</a></i>
is implementation-dependent.
<br>
<h4><a name = "tag_008_002_005">&nbsp;</a>Local Modes</h4>
<xref type="3" name="localmodes"></xref>
The
<b>c_lflag</b>
field of the argument
structure is used to control various functions.
It is composed of the
bitwise inclusive OR of the masks shown, which will be
bitwise distinct.
The mask name symbols in this table are defined
in
<i><a href="../xsh/termi288.htm">&lt;termios.h&gt;</a></i>;
not all values specified
are required to be supported by
the underlying hardware:
<p><table  bordercolor=#000000 border=1 align=center><tr valign=top><th align=center><b>Mask Name</b>
<th align=center><b>Description</b>
<tr valign=top><td align=left>ECHO
<td align=left>Enable echo.
<tr valign=top><td align=left>ECHOE
<td align=left>Echo ERASE as an error correcting backspace.
<tr valign=top><td align=left>ECHOK
<td align=left>Echo KILL.
<tr valign=top><td align=left>ECHONL
<td align=left>Echo &lt;newline&gt;.
<tr valign=top><td align=left>ICANON
<td align=left>Canonical input (erase and kill processing).
<tr valign=top><td align=left>IEXTEN
<td align=left>Enable extended (implementation-dependent) functions.
<tr valign=top><td align=left>ISIG
<td align=left>Enable signals.
<tr valign=top><td align=left>NOFLSH
<td align=left>Disable flush after interrupt, quit or suspend.
<tr valign=top><td align=left>TOSTOP
<td align=left>Send SIGTTOU for background output.
<tr valign=top><td align=left>XCASE
<td align=left> Canonical upper/lower presentation. (<b>LEGACY</b>)  
</table>
<p>
If ECHO is set, input characters are echoed back to the terminal.
If ECHO is clear, input characters are not echoed.
<p>
If ECHOE and ICANON are set,
the ERASE character causes the terminal to erase, if possible, the
last character in the current line from the display.
If there were no character to erase, an implementation might
echo an indication that this was the case, or do nothing.
<p>
If ECHOK and ICANON are set,
the KILL character causes the terminal to erase
the line from the display or echoes the newline
character after the KILL character.
<p>
If ECHONL and ICANON are set, the newline
character is echoed even if ECHO is not set.
<p>
If ICANON is set, canonical processing is enabled.
This enables the erase and kill edit
functions, and the assembly of input
characters into lines delimited by NL, EOF and
EOL, as described in
<xref href=canon><a href="#tag_008_001_006">
Canonical Mode Input Processing
</a></xref>.
<p>
If ICANON is not set, read
requests are satisfied directly from the input queue.
A read is not satisfied until at
least MIN bytes have been received or the timeout value
TIME expired between bytes.
The time value represents tenths of a second.
See
<xref href=noncanon><a href="#tag_008_001_007">
Non-canonical Mode Input Processing
</a></xref>
for more details.
<p>
If IEXTEN is set, implementation-dependent functions
are recognised from the input data.
It is implementation-dependent how IEXTEN
being set interacts with ICANON, ISIG, IXON or IXOFF.
If IEXTEN is not set, implementation-dependent functions are not
recognised and the corresponding input
characters are processed as described for
ICANON, ISIG, IXON and IXOFF.
<p>
If ISIG is set, each input character
is checked against the special control characters INTR,
QUIT and SUSP.
If an input character matches one of these control
characters, the function associated with that
character is performed.
If ISIG is not set, no checking is done.
Thus these special input functions are possible only if ISIG is set.
<p>
If NOFLSH is set, the normal
flush of the input and output queues associated with the
INTR, QUIT and SUSP characters is not done.
<p>
If TOSTOP is set, the signal SIGTTOU is sent
to the process group of a
process that tries to write to its controlling terminal if it is not in
the foreground process group for that terminal.
This signal, by default, stops the members of the process group.
Otherwise, the output generated by that process is output
to the current output stream.
Processes that are blocking or ignoring SIGTTOU signals
are excepted and allowed to produce
output, and the SIGTTOU signal is not sent.
<p>
If XCASE is set, canonical lower and
canonical upper presentation are performed.
In locales other than the POSIX locale, the effect is unspecified.
(<b>LEGACY</b>)
<p>
The initial local control value after
<i><a href="../xsh/open.htm">open()</a></i>
is implementation-dependent.
<br>
<h4><a name = "tag_008_002_006">&nbsp;</a>Special Control Characters</h4>
The special control characters values are
defined by the array
<b>c_cc</b>.
The subscript name
and description for each element in
both canonical and non-canonical modes are as
follows:
<p><table  bordercolor=#000000 border=1 align=center><tr valign=top><th colspan=2 align=center><b>Subscript Usage</b>
<th align=left>&nbsp;
<tr valign=top><th align=center><b>Canonical</b>
<th align=center><b>Non-canonical</b>
<th align=left>&nbsp;
<tr valign=top><th align=center><b>Mode</b>
<th align=center><b>Mode</b>
<th align=center><b>Description</b>
<tr valign=top><td align=left>VEOF
<td align=left>&nbsp;
<td align=left>EOF character
<tr valign=top><td align=left>VEOL
<td align=left>&nbsp;
<td align=left>EOL character
<tr valign=top><td align=left>VERASE
<td align=left>&nbsp;
<td align=left>ERASE character
<tr valign=top><td align=left>VINTR
<td align=left>VINTR
<td align=left>INTR character
<tr valign=top><td align=left>VKILL
<td align=left>&nbsp;
<td align=left>KILL character
<tr valign=top><td align=left>&nbsp;
<td align=left>VMIN
<td align=left>MIN value
<tr valign=top><td align=left>VQUIT
<td align=left>VQUIT
<td align=left>QUIT character
<tr valign=top><td align=left>VSUSP
<td align=left>VSUSP
<td align=left>SUSP character
<tr valign=top><td align=left>&nbsp;
<td align=left>VTIME
<td align=left>TIME value
<tr valign=top><td align=left>VSTART
<td align=left>VSTART
<td align=left>START character
<tr valign=top><td align=left>VSTOP
<td align=left>VSTOP
<td align=left>STOP character
</table>
<p>
The subscript values are unique,
except that the VMIN and VTIME subscripts may
have the same values as the
VEOF and VEOL subscripts, respectively.
<p>
The number of elements in the
<b>c_cc</b>
array, NCCS, is unspecified.
<p>
Implementations that do not support changing the START and STOP
characters may ignore the character values in the
<b>c_cc</b>
array indexed by the VSTART and VSTOP subscripts when
<i><a href="../xsh/tcset286.htm">tcsetattr()</a></i>
is called, but will return the value in use when
<i><a href="../xsh/tcget283.htm">tcgetattr()</a></i>
is called.
<p>
The initial values of all control
characters are implementation-dependent.
<p>
If the value of one of
the changeable special control characters (see
<xref href=specchar><a href="#tag_008_001_009">
Special Characters
</a></xref>)
is {_POSIX_VDISABLE}, that function is disabled; 
that is, no input data will be recognised as the disabled special character.
If ICANON is not set, the value of {_POSIX_VDISABLE} has no special
meaning for the VMIN and VTIME entries of the
<b>c_cc</b>
array.

</blockquote>
<hr size=2 noshade>
<center><font size=2>
UNIX &reg; is a registered Trademark of The Open Group.<br>
Copyright &copy; 1997 The Open Group
<br> [ <a href="../index.htm">Main Index</a> | <a href="../xshix.htm">XSH</a> | <a href="../xcuix.htm">XCU</a> | <a href="../xbdix.htm">XBD</a> | <a href="../cursesix.htm">XCURSES</a> | <a href="../xnsix.htm">XNS</a> ]

</font></center><hr size=2 noshade>
</body></html>
