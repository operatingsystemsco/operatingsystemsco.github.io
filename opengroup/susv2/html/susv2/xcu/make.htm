<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<!-- Copyright 1997 The Open Group, All Rights Reserved -->
<title>make</title>
</head><body bgcolor=white>
<center>
<font size=2>
The Single UNIX &reg; Specification, Version 2<br>
Copyright &copy; 1997 The Open Group

</font></center><hr size=2 noshade>
<h4><a name = "tag_001_014_1365">&nbsp;</a>NAME</h4><blockquote>
make - maintain, update and regenerate groups of programs
(<b>DEVELOPMENT</b>)
</blockquote><h4><a name = "tag_001_014_1366">&nbsp;</a>SYNOPSIS</h4><blockquote>
<pre><code>

make <b>[</b>-einpqrst<b>][</b>-f <i>makefile</i><b>]</b>...<b>[</b> -k| -S<b>][</b><i>macros</i>=<i>name</i><b>]</b>...
<b>[</b><i>target_name</i>...<b>]</b>
</code>
</pre>
</blockquote><h4><a name = "tag_001_014_1367">&nbsp;</a>DESCRIPTION</h4><blockquote>
The
<i>make</i>
utility can be used as a part of software development to update
files that are derived from other files.
A typical case is one
where object files are derived from the corresponding source files.
The
<i>make</i>
utility examines time relationships and updates those derived files
(called targets) that have modified times earlier than
the modified times of the files
(called prerequisites) from which they are derived.
A description
file (makefile) contains a description of the relationships between
files, and the commands that must be executed to update the targets
to reflect changes in their prerequisites.
Each specification, or rule, consists of a target,
optional prerequisites and
optional commands to be executed when a prerequisite
is newer than the target.
There are two types of rule:
<ul>
<p>
<li>
inference rules,
which have one target name with at least one period
(.)
and no slash
(/)
<p>
<li>
target rules, which can have more than one target name.
<p>
</ul>
<p>
In addition,
<i>make</i>
has a collection of
built-in macros and inference rules that infer prerequisite
relationships to simplify maintenance of programs.
<p>
To receive exactly the behaviour described in this section,
a portable makefile must:
<ul>
<p>
<li>
include the special target
<b>.POSIX</b>
<p>
<li>
omit any special target reserved for implementations
(a leading period followed by upper-case letters)
that has not been specified by this section.
<p>
</ul>
<p>
The behaviour of
<i>make</i>
is unspecified if
either or both of these conditions are not met.
</blockquote><h4><a name = "tag_001_014_1368">&nbsp;</a>OPTIONS</h4><blockquote>
The
<i>make</i>
utility supports the <b>XBD</b> specification, <a href="../xbd/utilconv.htm#usg"><b>Utility Syntax Guidelines</b>&nbsp;</a> .
<p>
The following options are supported:
<dl compact>

<dt><b>-e</b>
<dd>Cause environment variables, including those with null values,
to override macro assignments within makefiles.

<dt><b>-f&nbsp;</b><i>makefile</i>
<dd>
Specify a different makefile.
The argument
<i>makefile</i>
is a pathname of a description file,
which is also referred to as the
<i>makefile</i>.
A pathname of "-" denotes the standard input.
There can be multiple instances of this option, and they will be
processed in the order specified.
The effect of specifying the same
option-argument more than once
is unspecified.

<dt><b>-i</b>
<dd>Ignore error codes returned by invoked commands.
This mode is the same as if the special target
<b>.IGNORE</b>
were specified
without prerequisites.

<dt><b>-k</b>
<dd>Continue to update other
targets that do not depend on the current target
if a non-ignored error occurs while executing the commands to
bring a target up-to-date.

<dt><b>-n</b>
<dd>Write commands that would be executed on standard output,
but do not execute them.
However, lines with a plus sign
(+)
prefix will be executed.
In this mode,
lines with an at sign
(@)
character prefix will be written to standard output.

<dt><b>-p</b>
<dd>Write to standard output the complete set of macro definitions
and target descriptions.
The output format is unspecified.

<dt><b>-q</b>
<dd>Return a zero exit value
if the target file is up-to-date;
otherwise,
return an exit value of 1.
Targets will not be updated if this option is specified.
However, a command line
(associated with the targets) with a plus sign
(+)
prefix will be executed.

<dt><b>-r</b>
<dd>Clear the suffix list and do not use the built-in rules.

<dt><b>-S</b>
<dd>Terminate
<i>make</i>
if an error occurs while executing the commands to bring a
target up-to-date.
This will be the default and the opposite of
<b>-k</b>.

<dt><b>-s</b>
<dd>Do not write command lines or touch messages (see
<b>-t</b>)
to standard output before executing.
This mode is the same as if the special target
<b>.SILENT</b>
were specified without prerequisites.

<dt><b>-t</b>
<dd>Update the modification time of each target as though a
<i><a href="touch.htm">touch</a></i>
<i>target</i>
had been executed.
Targets that have prerequisites but no commands (see
<xref href=mktarg><a href="#tag_001_014_1377_003">
Target Rules
</a></xref>),
or that are already up-to-date,
will not be touched in this manner.
Write messages to standard output for each target file
indicating the name of the file and that it was touched.
Normally, the command lines associated with each target
are not executed.
However, a command line
with a plus sign
(+)
prefix will be executed.

</dl>
<p>
If the
<b>-k</b>
and
<b>-S</b>
options are both specified on the command line, by the
<i>MAKEFLAGS</i>
environment variable, or by the
<b>MAKEFLAGS</b>
macro, the last one evaluated will take precedence.
The
<i>MAKEFLAGS</i>
environment variable will be
evaluated first and the command line will be evaluated second.
Assignments to the
<b>MAKEFLAGS</b>
macro will be evaluated as described in the ENVIRONMENT VARIABLES section.
</blockquote><h4><a name = "tag_001_014_1369">&nbsp;</a>OPERANDS</h4><blockquote>
The following operands are supported:
<dl compact>

<dt><i>target_name</i><dd>
Target names, as defined in the EXTENDED DESCRIPTION section.
If no target is specified, while
<i>make</i>
is processing the makefiles,
the first target that
<i>make</i>
encounters that is not a special target or an inference rule will be used.

<dt><i>macro=name</i><dd>
Macro definitions, as defined in
<xref href=mkmacro><a href="#tag_001_014_1377_004">
Macros
</a></xref>.

</dl>
<p>
If the
<i>target_name</i>
and
<i>macro=name</i>
operands are intermixed on the command line,
the results are unspecified.
</blockquote><h4><a name = "tag_001_014_1370">&nbsp;</a>STDIN</h4><blockquote>
The standard input will be used only if the
<i>makefile</i>
option-argument is "-".
See the INPUT FILES section.
</blockquote><h4><a name = "tag_001_014_1371">&nbsp;</a>INPUT FILES</h4><blockquote>
The input file, otherwise known as the makefile,
is a text file containing
rules, macro definitions and comments.
</blockquote><h4><a name = "tag_001_014_1372">&nbsp;</a>ENVIRONMENT VARIABLES</h4><blockquote>
The following environment variables affect the execution of
<i>make</i>:
<dl compact>

<dt><i>LANG</i><dd>Provide a default value for the internationalisation variables
that are unset or null.
If
<i>LANG</i>
is unset or null, the corresponding value from the
implementation-dependent default locale will be used.
If any of the internationalisation variables contains an invalid setting, the
utility will behave as if none of the variables had been defined.

<dt><i>LC_ALL</i><dd>
If set to a non-empty string value,
override the values of all the other internationalisation variables.

<dt><i>LC_CTYPE</i><dd>
Determine the
locale for the interpretation of sequences of bytes of text data as
characters (for example, single- as opposed to multi-byte characters
in arguments and input files).

<dt><i>LC_MESSAGES</i><dd>
Determine the locale that should be used to affect
the format and contents of diagnostic
messages written to standard error.

<dt><i>MAKEFLAGS</i><dd>
This variable is interpreted as a character string representing
a series of option characters to be used as the default options.
The implementation will accept both of the following formats
(but need not accept them when intermixed):
<ol>

<li>
The characters are option letters without the leading hyphens or
blank character
separation used on a command line.

<li>
The characters are formatted in a manner similar to a portion of the
<i>make</i>
command line:
options are preceded by hyphens and
blank-character-separated
as described in
the <b>XBD</b> specification, <a href="../xbd/utilconv.htm#usg"><b>Utility Syntax Guidelines</b>&nbsp;</a> .
The
<i>macro=name</i>
macro definition operands can also be included.
The difference between the contents of
<i>MAKEFLAGS</i>
and the command line is that
the contents of the variable will not be subjected to the word expansions
(see
<xref href=wordexp><a href="chap2.htm#tag_001_006">
Word Expansions
</a></xref>)
associated with parsing the command line values.

</ol>

When the command-line options
<b>-f</b>
or
<b>-p</b>
are used, they will take effect
regardless of whether they also appear in
<i>MAKEFLAGS .
</i>If they otherwise appear in
<i>MAKEFLAGS ,
</i>the result is undefined.

The
<i>MAKEFLAGS</i>
variable will be accessed from the environment
before the makefile is read.
At that time,
all of the options (except
<b>-f</b>
and
<b>-p</b>)
and command-line macros
not already included in
<b>MAKEFLAGS</b>
are added to the
<b>MAKEFLAGS</b>
macro.
The
<b>MAKEFLAGS</b>
macro will be passed into the environment as
an environment variable for all child processes.
If the
<b>MAKEFLAGS</b>
macro is subsequently set by the makefile, it
replaces the
<i>MAKEFLAGS</i>
variable currently found in the environment.

<dt><i>NLSPATH</i><dd>
Determine the location of message catalogues
for the processing of
<i>LC_MESSAGES .
</i>
<dt><i>PROJECTDIR</i><dd>
Provide a directory to be used to search for SCCS files not found
in the current directory.
In all of the following cases, the
search for SCCS files will be made in the directory
<b>SCCS</b>
in the
identified directory.
If the value of
<i>PROJECTDIR</i>
begins with a
slash, it is considered an absolute pathname;
otherwise, the home
directory of a user of that name is examined for a subdirectory
<b>src</b>
or
<b>source</b>.
If such a directory is found, it is used.
Otherwise, the value is used as a relative pathname.

If
<i>PROJECTDIR</i>
is not set or has a null value, the search for SCCS
files will be made in the directory
<b>SCCS</b>
in the current directory.

The setting of
<i>PROJECTDIR</i>
affects all files listed in the
remainder of this utility description for files with a component
named
<b>SCCS</b>.

</dl>
<p>
The value of the
<i>SHELL</i>
environment variable
will not be used as a macro and
will not be modified by defining the
<b>SHELL</b>
macro in a makefile or on the command line.
All other environment variables,
including those with null values,
are used as macros, as defined in
<xref href=mkmacro><a href="#tag_001_014_1377_004">
Macros
</a></xref>.
</blockquote><h4><a name = "tag_001_014_1373">&nbsp;</a>ASYNCHRONOUS EVENTS</h4><blockquote>
If not already ignored,
<i>make</i>
will trap SIGHUP, SIGTERM, SIGINT and SIGQUIT
and remove the current
target unless the target is a directory or the target is a
prerequisite of the special target
<b>.PRECIOUS</b>
or unless one of the
<b>-n</b>,
<b>-p</b>
or
<b>-q</b>
options was specified.
Any targets removed in this manner will be reported
in diagnostic messages of unspecified format,
written to standard error.
After this cleanup process, if any,
<i>make</i>
will take the standard action for all other signals.
</blockquote><h4><a name = "tag_001_014_1374">&nbsp;</a>STDOUT</h4><blockquote>
The
<i>make</i>
utility will write all commands to be executed to standard output
unless the
<b>-s</b>
option was specified, the command
is prefixed with an at sign,
or the special target
<b>.SILENT</b>
has either the current target as a prerequisite or has no prerequisites.
If
<i>make</i>
is invoked without any work
needing to be done, it will write a message to standard output
indicating that no action was taken.
</blockquote><h4><a name = "tag_001_014_1375">&nbsp;</a>STDERR</h4><blockquote>
Used only for diagnostic messages.
</blockquote><h4><a name = "tag_001_014_1376">&nbsp;</a>OUTPUT FILES</h4><blockquote>
None.
However, utilities invoked by
<i>make</i>
may create additional files.
</blockquote><h4><a name = "tag_001_014_1377">&nbsp;</a>EXTENDED DESCRIPTION</h4><blockquote>
The
<i>make</i>
utility attempts to perform the actions required
to ensure that the specified targets are up-to-date.
A target is considered out-of-date if it is older than any
of its prerequisites
or if it does not exist.
The
<i>make</i>
utility treats all prerequisites as
targets themselves and recursively ensures that they are
up-to-date, processing them in the order in which they
appear in the rule.
The
<i>make</i>
utility uses the modification times of
files to determine if the
corresponding targets are out-of-date.
<p>
After
<i>make</i>
has ensured that all of the prerequisites of a target are
up-to-date and if the target is out-of-date, the commands
associated with the target entry are executed.
If there are
no commands listed for the target, the target is treated
as up-to-date.
<h5><a name = "tag_001_014_1377_001">&nbsp;</a>Makefile Syntax</h5>
A makefile can contain rules, macro definitions (see
<xref href=mkmacro><a href="#tag_001_014_1377_004">
Macros
</a></xref>),
and comments.
There are two kinds of rules:
inference rules
and target rules.
The
<i>make</i>
utility contains a set of built-in inference rules.
If the
<b>-r</b>
option is present, the built-in rules are not used and the suffix
list is cleared.
Additional rules of both types can be specified in a makefile.
If a rule or macro is defined more than once, the value
of the rule or macro will be that of the last one specified.
Comments start with a number sign
(#)
and continue until an unescaped
newline character
is reached.
<p>
By default, the following files are tried in sequence:
<b>./makefile</b>,
<b>./Makefile</b>,
<b>./s.makefile</b>,
<b>SCCS/s.makefile</b>,
<b>./s.Makefile</b>,
and
<b>SCCS/s.Makefile</b>.
<p>
The
<b>-f</b>
option directs
<i>make</i>
to ignore any of these default files
and use the specified argument as a makefile instead.
If the "-" argument is specified, standard input will be used.
<p>
The term
<i>makefile</i>
is used to refer to any rules provided by the
user, whether in
<b>./makefile</b>
or its variants,
or specified by the
<b>-f</b>
option.
<p>
The rules in makefiles consist of the following types of lines:
target rules, including special targets (see
<xref href=mktarg><a href="#tag_001_014_1377_003">
Target Rules
</a></xref>);
inference rules (see
<xref href=infrules><a href="#tag_001_014_1377_005">
Inference Rules
</a></xref>);
macro definitions (see
<xref href=mkmacro><a href="#tag_001_014_1377_004">
Macros
</a></xref>);
empty lines;
and comments.
Comments start with a number sign
(#)
and continue until an unescaped
newline character
is reached.
<p>
When an escaped
newline character
(one preceded by a
<b>backslash</b>)
is found anywhere in the makefile, it is replaced,
along with any leading white space on the following line, with a single
space character.
<h5><a name = "tag_001_014_1377_002">&nbsp;</a>Makefile Execution</h5>
Command lines are processed one at a time
by writing the command line to the standard output (unless
one of the conditions listed below under "@"
suppresses the writing)
and executing the commands in the line.
A tab character may precede the command to standard output.
Commands will be executed
by passing the command line to the command interpreter in
the same manner as if the string were the argument to
the <b>XSH</b> specification
<i><a href="../xsh/system.htm">system()</a></i>
function.
<p>
The environment for the command being executed will
contain all of the variables in the environment of
<i>make</i>.
The macros from the command line to
<i>make</i>
will be added to
<i>make</i>'s
environment.
Other implementation-dependent
variables may also be added to
<i>make</i>'s
environment.
If any command-line macro has been defined elsewhere, the
command-line value will overwrite the existing value.
If the
<i>MAKEFLAGS</i>
variable is not set in the environment in which
<i>make</i>
was invoked, in the makefile or on the
command line, it will be created by
<i>make</i>,
and will contain all options specified on the command line except for the
<b>-f</b>
and
<b>-p</b>
options.
It may also contain implementation-dependent options.
<p>
By default, when
<i>make</i>
receives a non-zero status from the
execution of a command, it terminates with an error message
to standard error.
<p>
Command lines can have one or more of the following prefixes:
a hyphen
(-),
an at sign
(@),
or a plus sign
(+).
These modify the way in which
<i>make</i>
processes the command.
When a command is written to standard output,
the prefix is not included in the output.
<dl compact>

<dt><b>-</b><dd>If the command prefix contains a hyphen,
or the
<b>-i</b>
option is present, or the special target
<b>.IGNORE</b>
has either the current target as a prerequisite or has no prerequisites,
any error found while executing the command will be ignored.

<dt>@<dd>If the command prefix contains an at sign
and the command-line
<b>-n</b>
option is not specified, or the
<b>-s</b>
option
is present, or the special target
<b>.SILENT</b>
has either the current target as a prerequisite or has no prerequisites,
the command will not be written to standard output before it is executed.

<dt><b>+</b><dd>If the command prefix contains a plus sign,
this indicates a command line that will be executed even if
<b>-n</b>,
<b>-q</b>
or
<b>-t</b>
is specified.

</dl>
<h5><a name = "tag_001_014_1377_003">&nbsp;</a>Target Rules</h5>
<xref type="5" name="mktarg"></xref>
Target rules are formatted as follows:
<pre>
<code>
<i>target </i><b>[</b><i>target</i>...<b>]</b>:&nbsp;<b>[</b><i>prerequisite</i>...<b>][;</b><i>command</i><b>]
[</b>&lt;tab&gt;<i>command</i><b>]</b>
&lt;tab&gt;command
...<b>]</b>

<i>line that does not begin with </i>&lt;tab&gt;
</code>
</pre>
<p>
Target entries are specified by a
blank-character-separated,
non-null list of targets, then a colon, then a
blank-character-separated,
possibly empty list of prerequisites.
Text following a semicolon,
if any, and all following lines that begin with a
tab character,
are command lines to be executed to update the target.
The first non-empty line that does not begin with a
tab character
or
"#"
begins a new entry.
An empty or blank line, or a line beginning with
"#",
may begin a new entry.
<p>
Applications must select target names from the
set of characters consisting solely of periods,
underscores, digits and alphabetics
from the portable character set (see
the <b>XBD</b> specification, <a href="../xbd/charset.htm#tag_001_001"><b>Portable Character Set</b>&nbsp;</a> ).
Implementations may allow other characters
in target names as extensions.
The interpretation of targets containing the characters "%" and """
is implementation-dependent.
<p>
A target that has prerequisites, but does not have any commands,
can be used to add to the prerequisite list for that target.
Only one target rule for any given target can contain commands.
<p>
Lines that begin with one of the following are called
<i>special targets</i>
and control the operation of
<i>make</i>:
<dl compact>

<dt>.DEFAULT<dd>If the makefile uses this special target,
it must be specified with commands, but
without prerequisites.
The commands will be used by
<i>make</i>
if there are no other rules
available to build a target.

<dt>.IGNORE<dd>Prerequisites of this special target are targets themselves;
this will cause errors from commands associated with them
to be ignored in the same manner as specified by the
<b>-i</b>
option.
Subsequent occurrences of
<b>.IGNORE</b>
add to the list of targets ignoring command errors.
If no prerequisites are specified,
<i>make</i>
will behave as if the
<b>-i</b>
option had been specified and errors
from all commands associated with all targets will be ignored.

<dt>.POSIX<dd>This special target must be specified without prerequisites or commands.
If it appears before the first non-comment line in the makefile,
<i>make</i>
will process the makefile as specified by this section;
otherwise, the behaviour of
<i>make</i>
is unspecified.

<dt>.PRECIOUS<dd>Prerequisites of this special target will not be removed if
<i>make</i>
receives one of the asynchronous events explicitly described in
the ASYNCHRONOUS EVENTS section.
Subsequent occurrences of
<b>.PRECIOUS</b>
add to the list of precious files.
If no prerequisites are specified,
all targets in the makefile will be treated as if specified with
<b>.PRECIOUS</b>.

<dt>.SCCS_GET<dd>This special target must be specified without prerequisites.
If this special target is included in a
makefile, the commands specified with this target
replace the default commands associated with this
special target.
(See
<xref href=mkdefr><a href="#tag_001_014_1377_008">
Default Rules
</a></xref>.)
The commands specified with this target are used to get all
SCCS files that are not found in the current directory.

When source files are named in a dependency list,
<i>make</i>
treats them just like any other target.
Because the
source file is presumed to be present in the directory,
there is no need to add an entry for it to the makefile.
When a target has no dependencies, but is present in the
directory,
<i>make</i>
assumes that that file is up-to-date.
If, however, an SCCS file named
<b>SCCS/s.</b><i>source_file</i>
is found for a target
<i>source_file</i>,
<i>make</i>
does some additional checking to assure that the target is up-to-date.
If the target is missing, or if the SCCS file is newer,
<i>make</i>
automatically issues the commands specified
for the
<b>.SCCS_GET</b>
special target to retrieve the most
recent version.
However, if the target is writable by
anyone,
<i>make</i>
does not retrieve a new version.

<dt>.SILENT<dd>Prerequisites of this special target are targets themselves;
this causes commands associated with them to not be written
to the standard output before they are executed.
Subsequent occurrences of
<b>.SILENT</b>
add to the list of targets with silent commands.
If no prerequisites are specified,
<i>make</i>
will behave as if the
<b>-s</b>
option had been specified and no commands or touch messages associated with
any target will be written to standard output.

<dt>.SUFFIXES<dd>Prerequisites of
<b>.SUFFIXES</b>
are appended to the list
of known suffixes and are used
in conjunction with the inference rules (see
<xref href=infrules><a href="#tag_001_014_1377_005">
Inference Rules
</a></xref>).
If
<b>.SUFFIXES</b>
does not have
any prerequisites, the list of known suffixes will be cleared.
Makefiles must not associate commands with
<b>.SUFFIXES</b>.

</dl>
<p>
Targets with names consisting of a leading period followed by
the upper-case letters
<b>POSIX</b>
and then any other characters are reserved for future standardisation.
Targets with names consisting of a leading period followed by
one or more upper-case letters are reserved for implementation extensions.
<h5><a name = "tag_001_014_1377_004">&nbsp;</a>Macros</h5>
<xref type="5" name="mkmacro"></xref>
Macro definitions are in the form:
<p>
<dl compact><dt> <dd>
<i>string1</i>
"="
<b>[</b><i>string2</i><b>]</b>
</dl>
</p>
<p>
The macro named
<i>string1</i>
is defined as having the value of
<i>string2</i>,
where
<i>string2</i>
is defined as all characters,
if any, after the equal sign,
up to a comment character
(#)
or an unescaped
newline
character.
Any
blank characters
immediately before or after the equal sign
will be ignored.
<p>
Subsequent appearances of
<b>$(</b><i>string1</i><b>)</b>
or
<b>${</b><i>string1</i><b>}</b>
are replaced by
<i>string2</i>.
The parentheses or braces are optional if
<i>string1</i>
is a single character.
The macro
$$
is replaced by the single character "$".
<p>
Applications must select macro names from the
set of characters consisting solely of periods,
underscores, digits and alphabetics
from the portable character set (see
the <b>XBD</b> specification, <a href="../xbd/charset.htm#tag_001_001"><b>Portable Character Set</b>&nbsp;</a> ).
A macro name cannot contain an equal sign.
Implementations may allow other characters
in macro names as extensions.
<p>
Macros can appear anywhere in the makefile.
Macros in target lines will be evaluated when the target line is read.
Macros in command lines will be evaluated when the command is executed.
Macros in macro definition lines will not be evaluated
until the new macro being defined is used in a rule or command.
A macro that has not been defined will evaluate to a null string
without causing any error condition.
<p>
The forms
<b>$(</b><i>string1</i><b>[:</b><i>subst1</i><b>=[</b><i>subst2</i><b>]])</b>
or
<b>${</b><i>string1</i><b>[:</b><i>subst1</i><b>=[</b><i>subst2</i><b>]]}</b>
can be used to replace
all occurrences of
<i>subst1</i>
with
<i>subst2</i>
when the macro substitution is performed.
The
<i>subst1</i>
to be replaced is recognised when it is a suffix
at the end of a word in
<i>string1</i>
(where a
<i>word</i>,
in this context, is defined to be a string
delimited by the beginning of the line, a
blank or newline character).
<p>
Macro assignments will be accepted from the sources listed below,
in the order shown.
If a macro name
already exists at the time it is being processed, the newer definition
will replace the existing definition.
<ol>
<p>
<li>
Macros defined in
<i>make</i>'s
built-in inference rules.
<p>
<li>
The contents of the environment,
including the variables with null values,
in the order defined in the environment.
<p>
<li>
Macros defined in the makefiles,
processed in the order specified.
<p>
<li>
Macros specified on the command line.
It is unspecified whether the internal macros defined in
<xref href=mkimacs><a href="#tag_001_014_1377_007">
Internal Macros
</a></xref>
are accepted from the command line.
<p>
</ol>
<p>
If the
<b>-e</b>
option is specified, the order of processing sources items 2 and 3
will be reversed.
<p>
The
<b>SHELL</b>
macro is treated specially.
It is provided by
<i>make</i>
and set to the pathname of the shell command language
interpreter (see
<i><a href="sh.htm">sh</a></i>).
The
<i>SHELL</i>
environment variable
will not affect the value of the
<b>SHELL</b>
macro.
If
<b>SHELL</b>
is defined in the makefile or is
specified on the command line, it will replace the original value
of the
<b>SHELL</b>
macro, but will not affect the
<i>SHELL</i>
environment variable.
Other effects of defining
<b>SHELL</b>
in the makefile or on the command line are implementation-dependent.
<h5><a name = "tag_001_014_1377_005">&nbsp;</a>Inference Rules</h5>
<xref type="5" name="infrules"></xref>
Inference rules are formatted as follows:
<pre>
<code>
<i>target</i>:
&lt;tab&gt;<i>command
</i><b>[</b>&lt;tab&gt;<i>command</i><b>]
...

</b><i>line that does not begin with </i>&lt;tab&gt;<i> or </i>#
</code>
</pre>
<p>
The
<i>target</i>
portion must be a valid target name (see
<xref href=mktarg><a href="#tag_001_014_1377_003">
Target Rules
</a></xref>)
of the form
<i>.s2</i>
or
<i>.s1.s2</i>
(where
<i>.s1</i>
and
<i>.s2</i>
are suffixes that have been given as prerequisites of the
<b>.SUFFIXES</b>
special target and
<i>s1</i>
and
<i>s2</i>
do not contain any slashes or periods.)
If there is only one period in the target,
it is a single-suffix inference rule.
Targets with two periods are double-suffix inference rules.
Inference rules can have only one target before the colon.
<p>
The makefile must not specify prerequisites for inference rules;
no characters other than white space can follow the colon
in the first line,
except when creating the
<i>empty rule,</i>
described below.
Prerequisites are inferred, as described below.
<p>
Inference rules can be redefined.
A target that matches an existing
inference rule will overwrite the old inference rule.
An empty rule can be created with a command
consisting of simply a semicolon
(that is, the rule still exists and is found during inference rule
search, but since it is empty, execution has no effect).
The empty rule also can be formatted as follows:
<pre>
<code>
<i>rule</i>: ;
</code>
</pre>
where zero or more
blank characters
separate the colon and semicolon.
<p>
The
<i>make</i>
utility uses the suffixes of targets and their prerequisites to infer
how a target can be made up-to-date.
A list of inference rules
defines the commands to be executed.
By default,
<i>make</i>
contains a built-in set of inference rules.
Additional rules can be specified in the
makefile.
<p>
The special target
<b>.SUFFIXES</b>
contains as its prerequisites a
list of suffixes that are to be used by the inference rules.
The order in which the suffixes are specified defines the order
in which the inference rules for the suffixes are used.
New suffixes will be appended to the current list by specifying a
<b>.SUFFIXES</b>
special target in the
makefile.
A
<b>.SUFFIXES</b>
target with no
prerequisites will clear the list of suffixes.
An empty
<b>.SUFFIXES</b>
target followed by a new
<b>.SUFFIXES</b>
list is required to change the order of the suffixes.
<p>
Normally, the user would provide an inference rule for each suffix.
The inference rule to update a target with a suffix
<i>.s1</i>
from a prerequisite with a suffix
<i>.s2</i>
is specified as a target
<i>.s2.s1</i>.
The internal macros provide the means to specify general inference rules.
(See
<xref href=mkimacs><a href="#tag_001_014_1377_007">
Internal Macros
</a></xref>.)
<p>
When no target rule is found to update a target, the inference
rules are checked.
The suffix of the target
(<i>.s1</i>)
to be built is compared to the list of suffixes specified by the
<b>.SUFFIXES</b>
special targets.
If the
<i>.s1</i>
suffix is found in
<b>.SUFFIXES</b>,
the inference rules are searched in the order defined for the first
<i>.s2.s1</i>
rule whose prerequisite file
(<b>$*</b><i>.s2</i>)
exists.
If the target is out-of-date with
respect to this prerequisite, the commands for that inference rule
are executed.
<p>
If the target to be built does not contain a suffix and
there is no rule for the target, the single
suffix inference rules will be checked.
The single-suffix inference rules define how to build
a target if a file is found with a name that
matches the target name with one of the single
suffixes appended.
A rule with one suffix
<i>.s2</i>
is the definition of how to build
<i>target</i>
from
<i>target.s2</i>.
The other suffix
(<i>.s1</i>)
is treated as null.
<p>
A tilde
(~)
in the above rules refers to an SCCS file in the current directory.
Thus, the rule
<b>.c~.o</b>
would transform an SCCS C-language source file into an
object file
(<b>.o</b>).
Because the
<b>s.</b>
of the SCCS files is a prefix,
it is incompatible with
<i>make</i>'s
suffix point of view.
Hence, the  ~ is a way of changing any file
reference into an SCCS file reference.
<h5><a name = "tag_001_014_1377_006">&nbsp;</a>Libraries</h5>
If a target or prerequisite contains parentheses, it will be treated
as a member of an archive library.
For the <i>lib</i><b>(</b><i>member</i><b>.o)</b> expression
<i>lib</i>
refers to the name of the archive library and
<i>member</i>.o
to the member name.
The member must be an object file with the
<b>.o</b>
suffix.
The modification time of the expression is the modification time
for the member as kept in the archive library.
See
<i><a href="ar.htm">ar</a></i>.
The
<b>.a</b>
suffix refers to an archive library.
The
<i>.s2</i><b>.a</b>
rule is used
to update a member in the library from a file with a suffix
<i>.s2</i>.
<h5><a name = "tag_001_014_1377_007">&nbsp;</a>Internal Macros</h5>
<xref type="5" name="mkimacs"></xref>
The
<i>make</i>
utility maintains five internal macros that can
be used in target and inference rules.
In order to clearly
define the meaning of these macros, some clarification of the
terms
<i>target rule</i>,
<i>inference rule</i>,
<i>target</i>
and
<i>prerequisite</i>
is necessary.
<p>
Target rules are specified by the user in a makefile for a
particular target.
Inference rules are user- or
<i>make</i>-specified
rules for a particular class of target names.
Explicit prerequisites are those prerequisites
specified in a makefile on target lines.
Implicit prerequisites are those prerequisites
that are generated when inference rules are used.
Inference rules are applied to implicit prerequisites or to explicit
prerequisites that do not have target rules defined for them in
the makefile.
Target rules are applied to targets specified in the makefile.
<p>
Before any target in the makefile is updated, each of its
prerequisites (both explicit and implicit) will be updated.
This is accomplished by recursively processing each prerequisite.
Upon recursion, each prerequisite becomes a target itself.
Its prerequisites in turn
are processed recursively until a target is found that has no
prerequisites, at which point the recursion stops.
The recursion then backs up, updating each target as it goes.
<p>
In the definitions that follow, the word
<i>target</i>
refers to one of:
<ul>
<p>
<li>
a target specified in the makefile
<p>
<li>
an explicit prerequisite specified in the
makefile that becomes the target when
<i>make</i>
processes it during recursion
<p>
<li>
an implicit prerequisite that becomes a target when
<i>make</i>
processes it during recursion.
<p>
</ul>
<p>
In the definitions that follow, the word
<i>prerequisite</i>
refers to one o the following:
<ul>
<p>
<li>
an explicit prerequisite specified in the makefile
for a particular target
<p>
<li>
an implicit prerequisite
generated as a result of locating an appropriate inference rule
and corresponding file that matches the suffix of the target.
<p>
</ul>
<br>
<p>
The five internal macros are:
<dl compact>

<dt>$@<dd>The $@ evaluates to the full target name
of the current target, or the archive filename
part of a library archive target.
It is evaluated for both target and inference rules.

For example, in the
<b>.c.a</b>
inference rule, $@ represents the out-of-date
<b>.a</b>
file to be built.
Similarly, in a makefile target rule to build
<b>lib.a</b>
from
<b>file.c</b>,
$@ represents the out-of-date
<b>lib.a</b>.

<dt>$%<dd>The $% macro is evaluated only when the current
target is an archive library member of the form
<i>libname</i>(<i>member</i><b>.o</b>).
In these cases, $@ evaluates to
<i>libname</i>
and $%
evaluates to
<i>member</i><b>.o</b>.
The $% macro is evaluated for both target and inference rules.

For example, in a makefile target rule to build
<b>lib.a(file.o)</b>,
$% represents
<b>file.o</b>
 as opposed to $@, which represents
<b>lib.a</b>.

<dt>$?<dd>The $? macro evaluates to the list of
prerequisites that are newer than the current target.
It is evaluated for both target and inference rules.

For example, in a makefile target rule to build
<b>prog</b>
from
<b>file1.o</b>,
<b>file2.o</b>
and
<b>file3.o</b>,
and where
<b>prog</b>
is not out of date with respect to
<b>file1.o</b>,
but is out of date with respect to
<b>file2.o</b>
and
<b>file3.o</b>,
$? represents
<b>file2.o</b>
and
<b>file3.o</b>.

<dt>$&lt;<dd>In an inference rule, $&lt; evaluates to the filename
whose existence allowed the inference rule to be chosen for the target.
In the
<b>.DEFAULT</b>
rule, the $&lt; macro evaluates to the current target name.
The $&lt; macro is evaluated only for inference rules.

For example, in the
<b>.c.a</b>
inference rule, $&lt; represents the prerequisite
<b>.c</b>
file.

<dt>$*<dd>The $* macro evaluates to the current target
name with its suffix deleted.
It is evaluated at least for inference rules.

For example, in the
<b>.c.a</b>
inference rule, $*.o represents the out-of-date
<b>.o</b>
file that corresponds to the prerequisite
<b>.c</b>
file.

</dl>
<p>
Each of the internal macros has an alternative form.
When an upper-case
D
or
F
is appended to any of the macros, the meaning
is changed to the
<i>directory part</i>
for
D
and
<i>filename part</i>
for
F.
The directory part is the path prefix of the file without a trailing slash;
for the current directory, the directory part is &quot;.&quot;.
When the $? macro contains more than one prerequisite filename, the
$(?D)
and
$(?F)
(or
${?D}
and
${?F})
macros expand to a list of directory name
parts and filename parts respectively.
<p>
For the target <i>lib</i><b>(</b><i>member</i><b>.o)</b> and the
<b>s2.a</b>
rule, the internal macros are defined as:
<dl compact>

<dt>$&lt;<dd><i>member</i><b>.s2</b>

<dt>$*<dd><i>member</i>

<dt>$@<dd><i>lib</i>

<dt>$?<dd><i>member</i><b>.s2</b>

<dt>$%<dd><i>member</i><b>.o</b>

</dl>
<h5><a name = "tag_001_014_1377_008">&nbsp;</a>Default Rules</h5>
<xref type="5" name="mkdefr"></xref>
The default rules for
<i>make</i>
achieve results that are the same
as if the following were used.
Implementations that do not support
FORTRAN may omit
<b>FC</b>,
<b>FFLAGS</b>
and the
.f
inference rules.
Implementations may provide additional macros and rules.
<pre>
<code>
<i>SPECIAL TARGETS</i>

.SCCS_GET: sccs $(SCCSFLAGS) get $(SCCSGETFLAGS) $@     

.SUFFIXES: .o .c .y .l .a .sh .f .c~ .y~ .l~ .sh~ .f~      

<i>MACROS</i>

MAKE=make
AR=ar
ARFLAGS=-rv
YACC=yacc
YFLAGS=
LEX=lex
LFLAGS=
LDFLAGS=
CC=c89
CFLAGS=-O
FC=fort77
FFLAGS=-O 1
GET=get
GFLAGS=
SCCSFLAGS=
SCCSGETFLAGS=-s

<i>SINGLE SUFFIX RULES</i>

.c:
    $(CC) $(CFLAGS) $(LDFLAGS) -o $@ $&lt;

.f:
    $(FC) $(FFLAGS) $(LDFLAGS) -o $@ $&lt;

.sh:
    cp $&lt; $@
    chmod a+x $@

.c~:
    $(GET) $(GFLAGS) -p $&lt; &gt; $*.c
    $(CC) $(CFLAGS) $(LDFLAGS) -o $@ $*.c

.f~:
    $(GET) $(GFLAGS) -p $&lt; &gt; $*.f
    $(FC) $(FFLAGS) $(LDFLAGS) -o $@ $*.f

.sh~:
    $(GET) $(GFLAGS) -p $&lt; &gt; $*.sh
    cp $*.sh $@
    chmod a+x $@

<i>DOUBLE SUFFIX RULES</i>

.c.o:
    $(CC) $(CFLAGS) -c $&lt;

.f.o:
    $(FC) $(FFLAGS) -c $&lt;

.y.o:
    $(YACC) $(YFLAGS) $&lt;
    $(CC) $(CFLAGS) -c y.tab.c
    rm -f y.tab.c
    mv y.tab.o $@

.l.o:
    $(LEX) $(LFLAGS) $&lt;
    $(CC) $(CFLAGS) -c lex.yy.c
    rm -f lex.yy.c
    mv lex.yy.o $@

.y.c:
    $(YACC) $(YFLAGS) $&lt;
    mv y.tab.c $@

.l.c:
    $(LEX) $(LFLAGS) $&lt;
    mv lex.yy.c $@

.c~.o:
    $(GET) $(GFLAGS) -p $&lt; &gt; $*.c
    $(CC) $(CFLAGS) -c $*.c

.f~.o:
    $(GET) $(GFLAGS) -p $&lt; &gt; $*.f
    $(FC) $(FFLAGS) -c $*.f

.y~.o:
    $(GET) $(GFLAGS) -p $&lt; &gt; $*.y
    $(YACC) $(YFLAGS) $*.y
    $(CC) $(CFLAGS) -c y.tab.c
    rm -f y.tab.c
    mv y.tab.o $@

.l~.o:
    $(GET) $(GFLAGS) -p $&lt; &gt; $*.l
    $(LEX) $(LFLAGS) $*.l
    $(CC) $(CFLAGS) -c lex.yy.c
    rm -f lex.yy.c
    mv lex.yy.o $@

.y~.c:
    $(GET) $(GFLAGS) -p $&lt; &gt; $*.y
    $(YACC) $(YFLAGS) $*.y
    mv y.tab.c $@

.l~.c:
    $(GET) $(GFLAGS) -p $&lt; &gt; $*.l
    $(LEX) $(LFLAGS) $*.l
    mv lex.yy.c $@

.c.a:
    $(CC) -c $(CFLAGS) $&lt;
    $(AR) $(ARFLAGS) $@ $*.o
    rm -f $*.o

.f.a:
    $(FC) -c $(FFLAGS) $&lt;
    $(AR) $(ARFLAGS) $@ $*.o
    rm -f $*.o
</code>
</pre>
</blockquote><h4><a name = "tag_001_014_1378">&nbsp;</a>EXIT STATUS</h4><blockquote>
When the
<b>-q</b>
option is specified, the
<i>make</i>
utility will exit with one of the following values:
<dl compact>

<dt>0<dd>Successful completion.

<dt>1<dd>The target was not up-to-date.

<dt>&gt;1<dd>An error occurred.

</dl>
<p>
When the
<b>-q</b>
option is not specified, the
<i>make</i>
utility will exit with one of the following values:
<dl compact>

<dt>0<dd>successful completion

<dt>&gt;0<dd>an error occurred

</dl>
</blockquote><h4><a name = "tag_001_014_1379">&nbsp;</a>CONSEQUENCES OF ERRORS</h4><blockquote>
Default.
</blockquote><h4><a name = "tag_001_014_1380">&nbsp;</a>APPLICATION USAGE</h4><blockquote>
If there is a source file (such as
<b>./source.c</b>)
and there are two SCCS files corresponding to it
(<b>./s.source.c</b> 
and
<b>./SCCS/s.source.c</b>),
<i>make</i>
will use the SCCS file in the current directory.
However, users are advised to use the underlying SCCS utilities
(<i>admin</i>,
<i><a href="delta.htm">delta</a></i>,
<i><a href="get.htm">get</a></i>,
and so on) or the
<i><a href="sccs.htm">sccs</a></i>
utility for all source files in a given directory.
If both forms are used for a given source file,
future developers are very likely to be confused.
<p>
It is incumbent upon portable makefiles to specify the
<b>.POSIX</b>
special target in order to guarantee that they are not affected by local
extensions.
<p>
The
<b>-k</b>
and
<b>-S</b>
options are both present so that the
relationship between the command line, the
<i>MAKEFLAGS</i>
variable, and the makefile can be controlled precisely.
If the
k
flag is passed in
<i>MAKEFLAGS</i>
and a command is of the form:
<pre>
<code>
$(MAKE) -S foo
</code>
</pre>
then the default behaviour is restored for the child
<i>make</i>.
<p>
When the
<b>-n</b>
option is specified, it is always added to
<i>MAKEFLAGS .
</i>This allows a recursive
<i>make</i>
<b>-n</b>
<i>target</i>
to be used to see all of the action that would be taken to update
<i>target</i>.
<p>
Because of widespread historical practice,
interpreting a # number sign inside a variable as the start of a comment
has the unfortunate side effect of making it impossible to
place a number sign in a variable, thus forbidding something like:
<pre>
<code>
CFLAGS = "-D COMMENT_CHAR='#'"
</code>
</pre>
<p>
Many historical
<i>make</i>
utilities
stop chaining together
inference rules when an intermediate target is non-existent.
For example, it might be possible for a
<i>make</i>
to determine that both
.y.c
and
.c.o
could be used to convert a
.y
to a
.o.
Instead, in this case,
<i>make</i>
requires the use of a
.y.o
rule.
<p>
The best way to provide portable makefiles
is to include all of the rules needed in the makefile itself.
The rules provided use only features provided by other parts of the standard.
The default rules include rules for optional commands in the standard.
Only rules pertaining to commands
that are provided are needed in an implementation's default set.
<p>
Macros used within other macros are evaluated when the new macro
is used rather than when the new macro is defined.
Therefore:
<pre>
<code>
MACRO = <i>value1</i>
NEW   = $(MACRO)
MACRO = <i>value2</i>

target:
    echo $(NEW)
</code>
</pre>
would produce
<i>value2</i>
and not
<i>value1</i>
since
<b>NEW</b>
was not expanded until
it was needed in the
<i><a href="echo.htm">echo</a></i>
command line.
<p>
Some historical applications
have been known to intermix
<i>target_name</i>
and
<i>macro=name</i>
operands on the command line,
expecting that all of the macros will be processed
before any of the targets are dealt with.
Portable applications do not do this,
although some backward compatibility support may be included
in some implementations.
<p>
The following characters in filenames may give trouble:
<pre>
<code>
=   :   `   '   @
</code>
</pre>
For inference rules, the description of
$&lt;
and
$?
seem similar.
However, an example shows the minor difference.
In a makefile containing:
<pre>
<code>
foo.o: foo.h
</code>
</pre>
if
<b>foo.h</b>
is newer than
<b>foo.o</b>,
yet
<b>foo.c</b>
is older than
<b>foo.o</b>,
the built-in rule to make
<b>foo.o</b>
from
<b>foo.c</b>
will be used, with
$&lt;
equal to
<b>foo.c</b>
and
$?
equal to
<b>foo.h</b>.
If
<b>foo.c</b>
is also newer than
<b>foo.o</b>,
$&lt;
is equal to
<b>foo.c</b>
and
$?
is equal to
<b>foo.h foo.c</b>.
</blockquote><h4><a name = "tag_001_014_1381">&nbsp;</a>EXAMPLES</h4><blockquote>
<ol>
<p>
<li>
The following command:
<pre>
<code>
make
</code>
</pre>
makes the first target found in the makefile.
<p>
<li>
The following command:
<pre>
<code>
make junk
</code>
</pre>
makes the target
<b>junk</b>.
<p>
<li>
The following makefile says that <b>pgm</b> depends on two files,
<b>a.o</b> and <b>b.o,</b> and that they in turn depend on
their corresponding source files (<b>a.c</b> and <b>b.c</b>),
and a common file <b>incl.h</b>:
<pre>
<code>
pgm: a.o b.o
      c89 a.o b.o -o pgm
a.o: incl.h a.c
      c89 -c a.c
b.o: incl.h b.c
      c89 -c b.c
</code>
</pre>
<p>
<li>
An example for making optimised
<b>.o</b>
files from
<b>.c</b>
files is:
<pre>
<code>
.c.o:
      c89 -c -O $*.c
</code>
</pre>
<p>
or:
<pre>
<code>
.c.o:
      c89 -c -O $&lt;
</code>
</pre>
<p>
<li>
The most common use of the archive interface follows.
Here, it is assumed that the source files are all C-language source:
<pre>
<code>
lib:  lib(file1.o) lib(file2.o) lib(file3.o)
      @echo lib is now up-to-date
</code>
</pre>
<p>
The
<b>.c.a</b>
rule is used to make
<b>file1.o</b>,
<b>file2.o</b>
and
<b>file3.o</b>
and insert them into
<b>lib</b>.
<p>
The treatment of escaped newline characters
throughout the makefile is historical practice.
For example, the inference rule:
<pre>
<code>
.c.o\
:
</code>
</pre>
<p>
works, and the macro:
<pre>
<code>
f=  bar baz\
   biz
a:
    echo ==$f==
</code>
</pre>
<p>
will echo
==bar&nbsp;baz&nbsp;biz==.
<p>
If
$?
were:
<pre>
<code>
/usr/include/stdio.h /usr/include/unistd.h foo.h
</code>
</pre>
then
$(?D)
would be:
<pre>
<code>
/usr/include /usr/include .
</code>
</pre>
and
$(?F)
would be:
<pre>
<code>
stdio.h unistd.h foo.h
</code>
</pre>
<p>
<li>
The contents of the built-in rules can be viewed by running:
<pre>
<code>
make -p -f /dev/null 2&gt;/dev/null
</code>
</pre>
<p>
</ol>
</blockquote><h4><a name = "tag_001_014_1382">&nbsp;</a>FUTURE DIRECTIONS</h4><blockquote>
The IEEE PASC 1003.2 Interpretations Committee has forwarded concerns about
parts of this interface definition to the IEEE PASC Shell and Utilities Working Group
which is identifying the corrections.
A future revision of this specification will align with
IEEE Std. 1003.2b when finalised.
</blockquote><h4><a name = "tag_001_014_1383">&nbsp;</a>SEE ALSO</h4><blockquote>
<i><a href="ar.htm">ar</a></i>,
<i><a href="c89.htm">c89</a></i>,
<i><a href="cc.htm">cc</a></i>,
<i><a href="get.htm">get</a></i>,
<i><a href="lex.htm">lex</a></i>,
<i><a href="sh.htm">sh</a></i>,
<i><a href="yacc.htm">yacc</a></i>.
</blockquote><hr size=2 noshade>
<center><font size=2>
UNIX &reg; is a registered Trademark of The Open Group.<br>
Copyright &copy; 1997 The Open Group
<br> [ <a href="../index.htm">Main Index</a> | <a href="../xshix.htm">XSH</a> | <a href="../xcuix.htm">XCU</a> | <a href="../xbdix.htm">XBD</a> | <a href="../cursesix.htm">XCURSES</a> | <a href="../xnsix.htm">XNS</a> ]

</font></center><hr size=2 noshade>
</body></html>
