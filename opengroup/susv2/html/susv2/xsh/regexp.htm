<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<!-- Copyright 1997 The Open Group, All Rights Reserved -->
<title>regexp</title>
</head><body bgcolor=white>
<center>
<font size=2>
The Single UNIX &reg; Specification, Version 2<br>
Copyright &copy; 1997 The Open Group

</font></center><hr size=2 noshade>
<h4><a name = "tag_000_008_057">&nbsp;</a>NAME</h4><blockquote>
advance, compile, step, loc1, loc2, locs - compile
and match regular expressions (<b>LEGACY</b>)
</blockquote><h4><a name = "tag_000_008_058">&nbsp;</a>SYNOPSIS</h4><blockquote>
<pre><code>

#define INIT <i>declarations</i>
#define GETC() getc <i>code</i>
#define PEEKC() peek <i>code</i>
#define UNGETC() ungetc <i>code</i>
#define RETURN(ptr) return <i>code</i>
#define ERROR(val) error <i>code</i>

#include &lt;<a href="regex205.htm">regexp.h</a>&gt;

char *compile(char *<i>instring</i>, char *<i>expbuf</i>,
    const char *<i>endbuf</i>, int <i>eof</i>);

int step(const char *<i>string</i>, const char *<i>expbuf</i>);

int advance(const char *<i>string</i>, const char *<i>expbuf</i>);

extern char *loc1, *loc2, *locs;
</code>
</pre>
</blockquote><h4><a name = "tag_000_008_059">&nbsp;</a>DESCRIPTION</h4><blockquote>
These are general-purpose, regular expression-matching
functions to be used in programs that perform regular expression
matching, using the Regular Expressions described in
<xref href=simpreg><a href="#tag_000_008_059_001">
Simple Regular Expressions (Historical Version)
</a></xref>.
These functions are defined by the
<i><a href="regex205.htm">&lt;regexp.h&gt;</a></i>
header.
<p>
Implementations may also accept internationalised simple regular
expressions as input.
<p>
Programs must have the following five macros declared before the
<b>#include</b>
<i><a href="regex205.htm">&lt;regexp.h&gt;</a></i>
statement.
These macros are used by
<i><a href="compile.htm">compile()</a></i>.
The macros GETC(), PEEKC() and UNGETC()
operate on the regular expression given as input to
<i><a href="compile.htm">compile()</a></i>.
<dl compact>

<dt>GETC()<dd>This macro returns the value of the next character (byte) in the
regular expression pattern.
Successive calls to GETC() should return successive characters of
the regular expression.

<dt>PEEKC()<dd>This macro returns the next character (byte) in the regular expression.
Immediately successive calls to PEEKC() should return the same byte,
which should also be the next character returned by GETC().

<dt>UNGETC(<i>c</i>)<dd>This macro causes the argument
<i>c</i>
to be returned by the next call to GETC() and PEEKC().
No more than one character of pushback is ever needed and this
character is guaranteed to be the last character read by GETC().
The value of the macro UNGETC(<i>c</i>) is always ignored.


<dt>RETURN(<i>ptr</i>)<dd>This macro is used on normal exit of the
<i><a href="compile.htm">compile()</a></i>
function.  The value of the argument
<i>ptr</i>
is a pointer to the character after the last character of the compiled
regular expression.
This is useful to programs that have memory allocation to manage.


<dt>ERROR(<i>val</i>)<dd>This macro is the abnormal return from
<i><a href="compile.htm">compile()</a></i>.
The argument
<i>val</i>
is an error number (see the <b>ERRORS</b> section below for meanings).
This call should never return.

</dl>
<p>
The
<i><a href="step.htm">step()</a></i>
and
<i><a href="advance.htm">advance()</a></i>
functions do pattern matching given a character string and a compiled
regular expression as input.
<p>
The
<i><a href="compile.htm">compile()</a></i>
function takes as input a simple regular expression (see
<xref href=simpreg><a href="#tag_000_008_059_001">
Simple Regular Expressions (Historical Version)
</a></xref>)
and produces a compiled expression that can be used with
<i><a href="step.htm">step()</a></i>
and
<i><a href="advance.htm">advance()</a></i>.
<p>
The first parameter
<i>instring</i>
is never used explicitly by
<i><a href="compile.htm">compile()</a></i>
but is useful for programs that pass down different pointers
to input characters.  It is sometimes used in the INIT declaration (see below).
Programs which invoke functions to input characters or have characters in an
external array can pass down (<b>char*</b>)0 for this parameter.
<p>
The next parameter
<i>expbuf</i>
is a character pointer.
It points to the place where the compiled regular expression will be
placed.
<p>
The parameter
<i>endbuf</i>
is one more than the highest address where the compiled
regular expression may be placed.
If the compiled expression cannot fit in
(<i>endbuf-expbuf</i>)
bytes, a call to ERROR(50) is made.
<p>
The parameter
<i>eof</i>
is the character which marks the end of the regular expression.
<p>
Each program that includes the
<i><a href="regex205.htm">&lt;regexp.h&gt;</a></i>
header must have a
<b>#define</b>
statement for INIT.
It is used for dependent declarations and initialisations.
Most often it is used to set a register variable to point to the
beginning of the regular expression so that this register variable can
be used in the declarations for GETC(), PEEKC() and UNGETC().
Otherwise it can be used to declare external variables that might be
used by GETC(), PEEKC() and UNGETC().
See the EXAMPLES section below.
<p>
The first parameter to
<i><a href="step.htm">step()</a></i>
is a pointer to a string of characters to be checked for a match.
This string should be null-terminated.
<p>
The second parameter,
<i>expbuf</i>,
is the compiled regular expression which was obtained by a call to
<i>compile</i>.
<p>
The
<i><a href="step.htm">step()</a></i>
function returns non-zero if some substring of
<i>string</i>
matches the regular expression in
<i>expbuf</i>,
and 0, if there is no match.
If there is a match, two external character pointers are set as a side
effect to the call to
<i><a href="step.htm">step()</a></i>.
The variable
<i>loc1</i>
points to the first character that matched the regular expression;
the variable
<i>loc2</i>
points to the character after the last character that matches the
regular expression.
Thus if the regular expression matches the entire input string,
<i>loc1</i>
will point to the first character of
<i>string</i>
and
<i>loc2</i>
will point to the null at the end of
<i>string</i>.
<p>
The
<i><a href="advance.htm">advance()</a></i>
function returns non-zero if the initial substring of
<i>string</i>
matches the regular expression in
<i>expbuf</i>.
If there is a match an external character pointer,
<i>loc2</i>,
is set as a side effect.
The variable
<i>loc2</i>
points to the next character in
<i>string</i>
after the last character that matched.
<p>
When
<i><a href="advance.htm">advance()</a></i>
encounters a "*" or \{&nbsp;\} sequence in the regular expression, it
will advance its pointer to the string to be matched as far as
possible and will recursively call itself trying to match the rest of
the string to the rest of the regular expression.
As long as there is no match,
<i><a href="advance.htm">advance()</a></i>
will back up along the string until it finds a match or reaches the
point in the string that initially matched the * or \{&nbsp;\}.
It is sometimes desirable to stop this backing up before the initial
point in the string is reached.
If the external character pointer
<i>locs</i>
is equal to the point in the string at some time during the backing up
process,
<i><a href="advance.htm">advance()</a></i>
will break out of the loop that backs up and will return 0.
<p>
The external variables
<i>circf</i>,
<i>sed</i>
and
<i>nbra</i>
are reserved.
<h5><a name = "tag_000_008_059_001">&nbsp;</a>Simple Regular Expressions (Historical Version)</h5>
<xref type="5" name="simpreg"></xref>
A Simple Regular Expression (SRE) specifies a set of character strings.
A member of this set of strings is said to be <i>matched</i> by the SRE.
<p>
A <i>pattern</i> is constructed from one or more SREs.
An SRE consists of <i>ordinary characters</i> or <i>metacharacters</i>.
<p>
Within a pattern, all alphanumeric characters
that are not part of a bracket expression, back-reference or duplication
match themselves; that is, the SRE pattern <i>abc</i> ,
when applied to a set of strings, will match only those strings containing
the character sequence <i>abc</i>
anywhere in them.
<p>
Most other characters also match themselves. However, a small
set of characters, known as the <i>metacharacters</i>, have
special meanings when encountered in patterns.
They are described below.
<h5><a name = "tag_000_008_059_002">&nbsp;</a>Simple Regular Expression Construction</h5>
SREs are constructed as follows:
<dl compact>

<dt><b>Expression</b><dd><b>Meaning</b>

<dt><i>c</i><dd>The character
<i>c</i>,
where
<i>c</i>
is not a special character.

<dt>\<i>c</i><dd>The character
<i>c</i>,
where
<i>c</i>
is any character with special meaning, see below.

<dt>^<dd>The beginning of the string being compared.

<dt>$<dd>The end of the string being compared.

<dt>.<dd>Any character.

<dt>[<i>s</i>]<dd>Any character in the non-empty set
<i>s</i>,
where
<i>s</i>
is a sequence of characters.  Ranges may be specified as
<i>c-c</i>.
The character ] may be included in the set by placing it first in the set.
The character "-"
may be included in the set by placing it first or last in the set.
The character "^"
may be included in the set by placing it anywhere other than first
in the set, see below.
Ranges in Simple Regular Expressions are only valid if the
<i>LC_COLLATE</i>
category is set to the C locale.
Otherwise, the effect of using the range notation is unspecified.

<dt>[^<i>s</i>]<dd>Any character not in the set
<i>s</i>,
where
<i>s</i>
is defined as above.

<dt><i>r</i>*<dd>Zero or more successive occurrences of the regular expression
<i>r</i>.
The longest leftmost match is chosen.

<dt><i>rx</i><dd>The occurrence of regular expression
<i>r</i>
followed by the occurrence of regular expression
<i>x</i>.
(Concatenation.)

<dt><i>r</i>\{<i>m</i>,<i>n</i>\}<dd>Any number of
<i>m</i>
through
<i>n</i>
successive occurrences of the regular expression
<i>r</i>.
The regular expression
<i>r</i>\{<i>m</i>\}
matches exactly
<i>m</i>
occurrences,
<i>r</i>\{<i>m</i>,\}
matches at least
<i>m</i>
occurrences.  The maximum number of occurrences is matched.

<dt>\(<i>r</i>\)<dd>The regular expression
<i>r</i>.
The
<i>\(</i>
and
<i>\)</i>
sequences are ignored.

<dt>\<i>n</i><dd>When
<i>\n</i>
(where
<i>n</i>
is a number in the range 1 to 9) appears in a concatenated
regular expression, it stands for the regular expression
<i>x</i>,
where
<i>x</i>
is the
<i>n</i>th
regular expression enclosed in \( and \)
sequences that appeared
earlier in the concatenated regular expression.
For example, in the pattern
<i>\(r\)x\(y</i>
the
<i>\2</i>
matches the regular expression
<i>y</i>,
giving
<i>rxyzy</i>.

</dl>
<p>
Characters that have special meaning except where they appear within
square brackets, [] , or are preceded by "\" are:
<pre>
<code>
</code>
</pre>
Other special characters, such as $ have special meaning in more
restricted contexts.
<p>
The character "^"
at the beginning of an expression permits a successful
match only immediately after a newline or at the beginning of
each of the strings to which the match is applied, and the character
"$" at the end of an expression requires a trailing newline.
<p>
Two characters have special meaning only when used within square
brackets.
The character "-" denotes a range, [<i>c</i> - <i>c</i> ],
unless it is just after the left square bracket or before the
right square bracket, [-<i>c</i> ]
or [<i>c</i> -],
in which case it has no special meaning.
The character "^" has the meaning
<i>complement of</i>
if it immediately follows the left square bracket, [^<i>c</i> ].
Elsewhere between brackets, [
<i>c</i>^],
it stands for the ordinary character "^".
The right square bracket (]) loses its special meaning and
represents itself in a bracket expression if it occurs first in
the list after any initial circumflex (^) character.
<p>
The special meaning of the "\" operator can be escaped
<i>only</i>
by preceding it with another "\"; that is, "\\".
<br>
<h5><a name = "tag_000_008_059_003">&nbsp;</a>SRE Operator Precedence</h5>
The precedence of the operators is as shown below:
<dl compact>

<dt>[...]<dd>High precedence.

<dt>*<dd>
<dt>concatenation<dd>Low precedence.

</dl>
<h5><a name = "tag_000_008_059_004">&nbsp;</a>Internationalised SREs</h5>
Character expressions within square brackets are constructed as
follows:
<dl compact>

<dt><b>Expression</b><dd><b>Meaning</b>

<dt><i>c</i><dd>The single character
<i>c</i>
where
<i>c</i>
is not a special character.


<dt>[[:<i>class</i>:]]<dd>A character class expression.  Any character of type
<i>class</i>,
as defined by category LC_CTYPE
in the program's locale (see the <b>XBD</b> specification, <a href="../xbd/locale.htm"><b>Locale</b>&nbsp;</a>).
For
<i>class</i>,
one of the following should be substituted:
<dl compact>

<dt>alpha<dd>A letter.

<dt>upper<dd>An upper-case letter.

<dt>lower<dd>A lower-case letter.

<dt>digit<dd>A decimal digit.

<dt>xdigit<dd>A hexadecimal digit.

<dt>alnum<dd>An alphanumeric (letter or digit).

<dt>space<dd>A character producing white space in displayed text.

<dt>punct<dd>A punctuation character.

<dt>print<dd>A printing character.

<dt>graph<dd>A character with a visible representation.

<dt>cntrl<dd>A control character.

</dl>
<p>
<dt>[[<i>=c=</i>]]<dd>An equivalence class.  Any collation element defined as having the same
relative order in the current collation sequence as
<i>c</i>.
As an example, if
<b>A</b>
and
<b>a</b>
belong to the same equivalence class, then both [[<i>=A=</i>]<i>b</i>]
and [[
<i>=a=</i>]<i>b</i>]
are equivalent to [
<i>Aab</i>].
<br>
<p>
<dt>[[<i>.cc.</i>]]<dd>A collating symbol.  Multi-character collating elements must be
represented as collating symbols to distinguish them from
single-character collating elements.  As an example, if the string
<i>ch</i>
is a valid collating element, then [[
<i>.ch.</i>]]
will be treated as an element matching the same string
of characters, while
<i>ch</i>
will be treated as a simple list of
<i>c</i>
and
<i>h</i>.
If the string is not a valid collating element in the current
collating sequence definition, the symbol will be treated as an
invalid expression.
<p>
<dt>[<i>c-c</i>]<dd>Any collation element in the character expression range
<i>c-c</i>,
where
<i>c</i>
can identify a collating symbol or an equivalence class.
If the character "-" appears immediately after an opening
square bracket (for example, [-<i>c</i>]) or immediately prior to
a closing square bracket (for example, [<i>c</i>-]), it has no
special meaning.
<p>
<dt>^<dd>Immediately following an opening square
bracket, means the complement of, for example, [^<i>c</i>].
Otherwise, it has no special meaning.
<p>
</dl>
<p>
Within square brackets, a "." that is not part of a [[
<i>.cc.</i>]]
sequence, or a ":" that is not part of a [[:<i>class</i>:]]
sequence, or an "=" that is not part of a [[<i>=c=</i>]]
sequence, matches itself.
<br>
<h5><a name = "tag_000_008_059_005">&nbsp;</a>SRE Examples</h5>
Below are examples of regular expressions:
<p><table  bordercolor=#000000 border=1 align=center><tr valign=top><th align=center><b>Pattern</b>
<th align=center><b>Meaning</b>
<tr valign=top><td align=left>ab.d
<td align=left>ab <i>any character</i> d
<tr valign=top><td align=left>ab.*d
<td align=left>ab <i>any sequence of characters (including none)</i> d
<tr valign=top><td align=left>ab[xyz]d
<td align=left>ab <i>one of </i>x y <i>or</i> z d
<tr valign=top><td align=left>ab[c]d
<td align=left>ab <i>anything except </i>c d
<tr valign=top><td align=left>abcd$
<td align=left><i>a line containing only</i> abcd
<tr valign=top><td align=left>[a-d]
<td align=left><i>any one of</i> a b c <i>or</i> d
</table>
<p>
These interfaces need not be reentrant.
</blockquote><h4><a name = "tag_000_008_060">&nbsp;</a>RETURN VALUE</h4><blockquote>
The
<i><a href="compile.htm">compile()</a></i>
function uses the macro RETURN() on success and the macro ERROR()
on failure, see above.
The
<i><a href="step.htm">step()</a></i>
and
<i><a href="advance.htm">advance()</a></i>
functions return non-zero on a successful match and 0 if there is no match.
</blockquote><h4><a name = "tag_000_008_061">&nbsp;</a>ERRORS</h4><blockquote>
<dl compact>

<dt>11<dd>Range endpoint too large.

<dt>16<dd>Bad number.

<dt>25<dd>\digit out of range.

<dt>36<dd>Illegal or missing delimiter.

<dt>41<dd>No remembered search string.

<dt>42<dd>\( \) imbalance.

<dt>43<dd>Too many \( .

<dt>44<dd>More than two numbers given in \{ \} .

<dt>45<dd>} expected after \ .

<dt>46<dd>First number exceeds second in \{ \} .

<dt>49<dd>[  ] imbalance.

<dt>50<dd>Regular expression overflow.

</dl>
</blockquote><h4><a name = "tag_000_008_062">&nbsp;</a>EXAMPLES</h4><blockquote>
The following is an example of how the regular expression macros and
calls might be defined by an application program:
<pre>
<code>
#define INIT         char *sp = instring;
#define GETC()     (*sp++)
#define PEEKC()    (*sp)
#define UNGETC(c)    (--sp)
#define RETURN(c)    return;
#define ERROR(c)     regerr()

#include &lt;regexp.h&gt;
    (void) compile(*argv, expbuf, &amp;expbuf[ESIZE], \0);
    if (step(linebuf, expbuf) )
        succeed();
</code>
</pre>
</blockquote><h4><a name = "tag_000_008_063">&nbsp;</a>APPLICATION USAGE</h4><blockquote>
Applications should migrate to the
<i><a href="fnmatch.htm">fnmatch()</a></i>,
<i><a href="glob.htm">glob()</a></i>,
<i><a href="regcomp.htm">regcomp()</a></i>
and
<i><a href="regexec.htm">regexec()</a></i>
functions which provide full internationalised regular expression
functionality compatible with the ISO POSIX-2 standard, as described in the <b>XBD</b> specification, <a href="../xbd/re.htm"><b>Regular Expressions</b>&nbsp;</a>.
</blockquote><h4><a name = "tag_000_008_064">&nbsp;</a>FUTURE DIRECTIONS</h4><blockquote>
None.
</blockquote><h4><a name = "tag_000_008_065">&nbsp;</a>SEE ALSO</h4><blockquote>
<i><a href="fnmatch.htm">fnmatch()</a></i>,
<i><a href="glob.htm">glob()</a></i>,
<i><a href="regcomp.htm">regcomp()</a></i>,
<i><a href="regexec.htm">regexec()</a></i>,
<i><a href="setlo231.htm">setlocale()</a></i>,
<i><a href="regex204.htm">&lt;regex.h&gt;</a></i>,
<i><a href="regex205.htm">&lt;regexp.h&gt;</a></i>,
the <b>XBD</b> specification, <a href="../xbd/re.htm"><b>Regular Expressions</b>&nbsp;</a>.
</blockquote><h4>DERIVATION</h4><blockquote>
Derived from Issue 2 of the SVID.
</blockquote><hr size=2 noshade>
<center><font size=2>
UNIX &reg; is a registered Trademark of The Open Group.<br>
Copyright &copy; 1997 The Open Group
<br> [ <a href="../index.htm">Main Index</a> | <a href="../xshix.htm">XSH</a> | <a href="../xcuix.htm">XCU</a> | <a href="../xbdix.htm">XBD</a> | <a href="../cursesix.htm">XCURSES</a> | <a href="../xnsix.htm">XNS</a> ]

</font></center><hr size=2 noshade>
</body></html>

