<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<!-- Copyright 1997 The Open Group, All Rights Reserved -->
<title>read</title>
</head><body bgcolor=white>
<center>
<font size=2>
The Single UNIX &reg; Specification, Version 2<br>
Copyright &copy; 1997 The Open Group

</font></center><hr size=2 noshade>
<h4><a name = "tag_000_007_1897">&nbsp;</a>NAME</h4><blockquote>
read, readv, pread - read from a file
</blockquote><h4><a name = "tag_000_007_1898">&nbsp;</a>SYNOPSIS</h4><blockquote>
<pre><code>

#include &lt;<a href="unist299.htm">unistd.h</a>&gt;

ssize_t read(int <i>fildes</i>, void *<i>buf</i>, size_t <i>nbyte</i>);
ssize_t pread(int <i>fildes</i>, void *<i>buf</i>, size_t <i>nbyte</i>, off_t offset);

#include &lt;<a href="sysui279.htm">sys/uio.h</a>&gt;

ssize_t readv(int <i>fildes</i>, const struct iovec *<i>iov</i>, int <i>iovcnt</i>);
</code>
</pre>
</blockquote><h4><a name = "tag_000_007_1899">&nbsp;</a>DESCRIPTION</h4><blockquote>
The
<i>read()</i>
function attempts to read
<i>nbyte</i>
bytes from the file associated with the open file descriptor,
<i>fildes</i>,
into the buffer pointed to by
<i>buf</i>.
<p>
If
<i>nbyte</i>
is 0,
<i>read()</i>
will return 0 and have no other results.
<p>
On files that support seeking (for example, a regular file), the
<i>read()</i>
starts at a position in the file given by the file offset associated with
<i>fildes</i>.
The file offset is incremented by the number of bytes actually read.
<p>
Files that do not support seeking,
for example, terminals,
always read from the current
position. The value of a file offset
associated with such a file is undefined.
<p>
No data transfer will occur past the current end-of-file.  If the starting
position is at or after the end-of-file, 0 will be returned. If the file
refers to a device special file, the result of subsequent
<i>read()</i>
requests is implementation-dependent.
<p>
If the value of
<i>nbyte</i>
is greater than {SSIZE_MAX}, the result is implementation-dependent.
<p>
When attempting to read from an empty pipe or FIFO:
<ul>
<p>
<li>
If no process has the pipe open for writing,
<i>read()</i>
will return 0 to indicate end-of-file.
<p>
<li>
If some process has the pipe open for writing and O_NONBLOCK is set,
<i>read()</i>
will return -1 and set
<i>errno</i>
to [EAGAIN].
<p>
<li>
If some process has the pipe open for writing and O_NONBLOCK is clear,
<i>read()</i>
will block
the calling thread
until some data is written or the
pipe is closed by all processes that had the
pipe open for writing.
<p>
</ul>
<p>
When attempting to read a file (other than a pipe or FIFO)
that supports non-blocking reads and has no data currently available:
<ul>
<p>
<li>
If O_NONBLOCK is set,
<i>read()</i>
will return a -1 and set
<i>errno</i>
to [EAGAIN].
<p>
<li>
If O_NONBLOCK is clear,
<i>read()</i>
will block 
the calling thread
until some data becomes available.
<p>
<li>
The use of the O_NONBLOCK
flag has no effect if there is some data available.
<p>
</ul>
<p>
The
<i>read()</i>
function reads data previously written to a file.  If any portion of a regular
file prior to the end-of-file has not been written,
<i>read()</i>
returns bytes with value 0.  For example,
<i><a href="lseek.htm">lseek()</a></i>
allows the file offset to be set beyond the end of existing data in the file.
If data is later written at this point, subsequent reads
in the gap between the previous end of data and the newly written data
will return bytes with value 0 until data is written into the gap.
<p>
Upon successful completion, where
<i>nbyte</i>
is greater than 0,
<i>read()</i>
will mark for update the <i>st_atime</i>
field of the file,
and return the number of bytes read.
This number will never be greater than
<i>nbyte</i>.
The value returned may be less than
<i>nbyte</i>
if the number of bytes left in the file is less than
<i>nbyte</i>,
if the
<i>read()</i>
request was interrupted by a signal, or if the file
is a pipe or FIFO or special file and has fewer than
<i>nbyte</i>
bytes immediately available for reading.  For example, a
<i>read()</i>
from a file associated with a terminal may return
one typed line of data.
<p>
If a
<i>read()</i>
is interrupted by a signal before it reads any data,
it will return -1 with
<i>errno</i>
set to [EINTR].
<p>
If a
<i>read()</i>
is interrupted by a signal after it has successfully read
some data,
it will return the number of bytes read.
<p>
A
<i>read()</i>
from a STREAMS file can read data in three different modes:  byte-stream mode,
message-nondiscard mode, and message-discard mode.  The default is byte-stream
mode.  This can be changed using the I_SRDOPT
<i><a href="ioctl.htm">ioctl()</a></i>
request, and can be tested with the I_GRDOPT
<i><a href="ioctl.htm">ioctl()</a></i>.
In byte-stream mode,
<i>read()</i>
retrieves data from the STREAM until as many bytes as were requested are
transferred, or until there is no more data to be retrieved.  Byte-stream mode
ignores message boundaries.
<p>
In STREAMS message-nondiscard mode,
<i>read()</i>
retrieves data until as many bytes as were requested are transferred, or until
a message boundary is reached.  If
<i>read()</i>
does not retrieve all the data in a message, the remaining data is left on
the STREAM, and can be retrieved by the next
<i>read()</i>
call.  Message-discard mode also retrieves data until as many bytes as were
requested are transferred, or a message boundary is reached.  However, unread
data remaining in a message after the
<i>read()</i>
returns is discarded,
and is not available for a subsequent
<i>read()</i>,
<i><a href="readv.htm">readv()</a></i>
or
<i><a href="getmsg.htm">getmsg()</a></i>
call.
<p>
How
<i>read()</i>
handles zero-byte STREAMS messages is determined by the current read mode
setting.  In byte-stream mode,
<i>read()</i>
accepts data until it has read
<i>nbyte</i> bytes, or until there is no more data
to read, or until a zero-byte message block is encountered.
The
<i>read()</i>
function
then returns the number of bytes read, and places the zero-byte
message back on the STREAM to be retrieved by the
next
<i>read()</i>,
<i><a href="readv.htm">readv()</a></i>
or
<i><a href="getmsg.htm">getmsg()</a></i>.
In message-nondiscard mode or message-discard mode, a zero-byte message
returns 0 and the message is removed from the STREAM.  When a
zero-byte message is read as the first message on a STREAM, the message is
removed from the STREAM and 0 is returned, regardless of the read mode.
<p>
A
<i>read()</i>
from a STREAMS file returns the data in the message at the front of the STREAM
head read queue, regardless of the priority band of the message.
<p>
By default, STREAMs are in control-normal mode, in which a
<i>read()</i>
from a STREAMS file can only process messages that contain a data part but do
not contain a control part.  The
<i>read()</i>
fails if a message containing a control part is encountered at the STREAM
head.  This default action can be changed by placing the STREAM in either
control-data mode or control-discard mode with the I_SRDOPT
<i><a href="ioctl.htm">ioctl()</a></i>
command.  In control-data mode,
<i>read()</i>
converts any control part to data and passes it to the application before
passing any data part originally present in the same message.  In
control-discard mode,
<i>read()</i>
discards message control parts but returns to the process any data part in the
message.
<p>
In addition,
<i>read()</i>
and
<i><a href="readv.htm">readv()</a></i>
will fail if the STREAM head had processed an asynchronous error before the
call.  In this case, the value of
<i>errno</i>
does not reflect the result of
<i>read()</i>
or
<i><a href="readv.htm">readv()</a></i>
but reflects the prior error.
If a hangup occurs on the STREAM being read,
<i>read()</i>
continues to operate normally until the STREAM head read queue is empty.
Thereafter, it returns 0.
<p>
The
<i><a href="readv.htm">readv()</a></i>
function is equivalent to
<i>read()</i>,
but places the input data into the
<i>iovcnt</i>
buffers specified by the members of the
<i>iov</i>
array: <i>iov</i>[0], <i>iov</i>[1], ...,
<i>iov</i>[<i>iovcnt</i>-1].
The <i>iovcnt</i> argument is valid if greater than 0 and less than or equal to
{IOV_MAX}.
<p>
Each <i>iovec</i> entry specifies the base address and length of an area in
memory where data should be placed.  The
<i><a href="readv.htm">readv()</a></i>
function always fills an area completely before proceeding to the next.
<p>
Upon successful completion,
<i><a href="readv.htm">readv()</a></i>
marks for update the <i>st_atime</i> field of the file.
<p>
If the Synchronized Input and Output option is supported:
<dl compact><dt> <dd>
If the O_DSYNC and O_RSYNC bits have been set,
read I/O operations on the file descriptor complete as defined by
synchronised I/O data integrity completion.
If the O_SYNC and O_RSYNC bits have been set,
read I/O operations on the file descriptor complete as defined by
synchronised I/O file integrity completion.
</dl>
<p>
If the Shared Memory Objects option is supported:
<dl compact><dt> <dd>
If
<i>fildes</i>
refers to a shared memory object, the result of the
<i>read()</i>
function is unspecified.
</dl>
<p>
For regular files, no data transfer will occur past the offset maximum
established in the open file description associated with
<i>fildes</i>.
<p>
The
<i><a href="pread.htm">pread()</a></i>
function performs the same action as
<i>read()</i>,
except that it reads from a given position in the file without
changing the file pointer.
The first three arguments to
<i><a href="pread.htm">pread()</a></i>
are the same as
<i>read()</i>
with the addition of a fourth argument offset for the desired position
inside the file.
An attempt to perform a
<i><a href="pread.htm">pread()</a></i>
on a file that is incapable of seeking results in an error.
</blockquote><h4><a name = "tag_000_007_1900">&nbsp;</a>RETURN VALUE</h4><blockquote>
Upon successful completion,
<i>read()</i>,
<i><a href="pread.htm">pread()</a></i>
and
<i><a href="readv.htm">readv()</a></i>
return a non-negative integer indicating the number of bytes actually read.
Otherwise, the functions return -1 and set <i>errno</i> to indicate the
error.
</blockquote><h4><a name = "tag_000_007_1901">&nbsp;</a>ERRORS</h4><blockquote>
The
<i>read()</i>,
<i><a href="pread.htm">pread()</a></i>
and
<i><a href="readv.htm">readv()</a></i>
functions will fail if:
<dl compact>

<dt>[EAGAIN]<dd>
The O_NONBLOCK flag is set for the file descriptor and the process
would be delayed.

<dt>[EBADF]<dd>
The
<i>fildes</i>
argument is not a valid file descriptor open for reading.

<dt>[EBADMSG]<dd>
The file is a STREAM file that is set to control-normal mode
and the message waiting to be read includes a control part.

<dt>[EINTR]<dd>
The read operation was terminated due to the receipt
of a signal, and no data was transferred.

<dt>[EINVAL]<dd>
The STREAM or multiplexer referenced by <i>fildes</i> is linked (directly or
indirectly) downstream from a multiplexer.

<dt>[EIO]<dd>
A physical I/O error has occurred.

<dt>[EIO]<dd>
The process is a member
of a background process attempting to read from its controlling
terminal, the process is ignoring or blocking the SIGTTIN signal
or the process group is orphaned. This error may also be generated for
implementation-dependent reasons.

<dt>[EISDIR]<dd>
The <i>fildes</i> argument refers to a directory and the implementation
does not allow the directory to be read using
<i>read()</i>,
<i><a href="pread.htm">pread()</a></i>
or
<i><a href="readv.htm">readv()</a></i>.
The
<i><a href="readdir.htm">readdir()</a></i>
function should be used instead.

<dt>[EOVERFLOW]<dd>
The file is a regular file,
<i>nbyte</i>
is greater than 0, the starting
position is before the end-of-file and the starting position is
greater than or equal to the offset maximum established in the open
file description associated with
<i>fildes</i>.

</dl>
<p>
The
<i><a href="readv.htm">readv()</a></i>
function will fail if:
<dl compact>

<dt>[EINVAL]<dd>
The sum of the <i>iov_len</i> values in the <i>iov</i> array overflowed an
<b>ssize_t</b>.

</dl>
<p>
The
<i>read()</i>,
<i><a href="pread.htm">pread()</a></i>
and
<i><a href="readv.htm">readv()</a></i>
functions may fail if:
<dl compact>

<dt>[ENXIO]<dd>
A request was made of a non-existent device, or the request was
outside the capabilities of the device.

</dl>
<p>
The
<i><a href="readv.htm">readv()</a></i>
function may fail if:
<dl compact>

<dt>[EINVAL]<dd>
The <i>iovcnt</i> argument was less than or equal to 0, or greater than
{IOV_MAX}.

</dl>
<p>
The
<i><a href="pread.htm">pread()</a></i>
function will fail, and the file pointer remains unchanged, if:
<dl compact>

<dt>[EINVAL]<dd>
The
<i>offset</i>
argument is invalid.
The value is negative.

<dt>[EOVERFLOW]<dd>
The file is a regular file and an attempt was made to read or write at
or beyond the offset maximum associated with the file.

<dt>[ENXIO]<dd>
A request was outside the capabilities of the device.

<dt>[ESPIPE]<dd>
<i>fildes</i> is associated with a pipe or FIFO.

</dl>
</blockquote><h4><a name = "tag_000_007_1902">&nbsp;</a>EXAMPLES</h4><blockquote>
None.
</blockquote><h4><a name = "tag_000_007_1903">&nbsp;</a>APPLICATION USAGE</h4><blockquote>
None.
</blockquote><h4><a name = "tag_000_007_1904">&nbsp;</a>FUTURE DIRECTIONS</h4><blockquote>
None.
</blockquote><h4><a name = "tag_000_007_1905">&nbsp;</a>SEE ALSO</h4><blockquote>
<i><a href="fcntl.htm">fcntl()</a></i>,
<i><a href="ioctl.htm">ioctl()</a></i>,
<i><a href="lseek.htm">lseek()</a></i>,
<i><a href="open.htm">open()</a></i>,
<i><a href="pipe.htm">pipe()</a></i>,
<i><a href="strop263.htm">&lt;stropts.h&gt;</a></i>,
<i><a href="sysui279.htm">&lt;sys/uio.h&gt;</a></i>,
<i><a href="unist299.htm">&lt;unistd.h&gt;</a></i>,
<b>XBD</b> specification, <a href="../xbd/termios.htm"><b>General Terminal Interface</b>&nbsp;</a>.
</blockquote><h4>DERIVATION</h4><blockquote>
Derived from Issue 1 of the SVID.
</blockquote><hr size=2 noshade>
<center><font size=2>
UNIX &reg; is a registered Trademark of The Open Group.<br>
Copyright &copy; 1997 The Open Group
<br> [ <a href="../index.htm">Main Index</a> | <a href="../xshix.htm">XSH</a> | <a href="../xcuix.htm">XCU</a> | <a href="../xbdix.htm">XBD</a> | <a href="../cursesix.htm">XCURSES</a> | <a href="../xnsix.htm">XNS</a> ]

</font></center><hr size=2 noshade>
</body></html>

