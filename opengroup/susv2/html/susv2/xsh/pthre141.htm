<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<!-- Copyright 1997 The Open Group, All Rights Reserved -->
<title>pthread_cond_wait</title>
</head><body bgcolor=white>
<center>
<font size=2>
The Single UNIX &reg; Specification, Version 2<br>
Copyright &copy; 1997 The Open Group

</font></center><hr size=2 noshade>
<h4><a name = "tag_000_007_1270">&nbsp;</a>NAME</h4><blockquote>
pthread_cond_wait, pthread_cond_timedwait - wait on a condition
</blockquote><h4><a name = "tag_000_007_1271">&nbsp;</a>SYNOPSIS</h4><blockquote>
<pre><code>

#include &lt;<a href="pthre114.htm">pthread.h</a>&gt;

int pthread_cond_wait(pthread_cond_t *<i>cond</i>, pthread_mutex_t *<i>mutex</i>);
int pthread_cond_timedwait(pthread_cond_t *<i>cond</i>, 
    pthread_mutex_t *<i>mutex</i>, const struct timespec *<i>abstime</i>);
</code>
</pre>
</blockquote><h4><a name = "tag_000_007_1272">&nbsp;</a>DESCRIPTION</h4><blockquote>
The
<i>pthread_cond_wait()</i>
and
<i>pthread_cond_timedwait()</i>
functions are used to block on a condition variable.
They are called with
<i>mutex</i>
locked by the calling thread or undefined behaviour will result.
<p>
These functions atomically release
<i>mutex</i>
and cause the calling thread to block on the condition variable
<i>cond</i>;
atomically here means &quot;atomically with respect to access by another 
thread to the mutex and then the condition variable&quot;.
That is, if another thread is able to acquire the mutex
after the about-to-block thread has released it,
then a subsequent call to
<i><a href="pthre140.htm">pthread_cond_signal()</a></i>
or
<i><a href="pthre137.htm">pthread_cond_broadcast()</a></i>
in that thread behaves as if it were issued
after the about-to-block thread has blocked.
<p>
Upon successful return, the mutex has been
locked and is owned by the calling thread.
<p>
When using condition variables there is always a boolean predicate involving
shared variables associated with each condition wait that is true if the thread
should proceed.
Spurious wakeups from the
<i>pthread_cond_wait()</i>
or
<i>pthread_cond_timedwait()</i>
functions may occur.
Since the return from
<i>pthread_cond_wait()</i>
or
<i>pthread_cond_timedwait()</i>
does not imply anything about the value of this predicate,
the predicate should be re-evaluated upon such return.
<p>
The effect of using more than one mutex for concurrent
<i>pthread_cond_wait()</i>
or
<i>pthread_cond_timedwait()</i>
operations on the same condition variable is
undefined; that is, a condition variable becomes bound to a unique mutex
when a thread
waits on the condition variable,
and this (dynamic) binding ends when the wait returns.
<p>
A condition wait (whether timed or not) is a cancellation point.
When the cancelability enable state of a thread is set to
PTHREAD_CANCEL_DEFERRED,
a side effect of acting upon a cancellation request
while in a condition wait is that the mutex is (in effect) re-acquired
before calling the first cancellation cleanup handler.
The effect is as if the thread were unblocked,
allowed to execute up to the point of returning from the
call to 
<i>pthread_cond_wait()</i>
or 
<i>pthread_cond_timedwait()</i>,
but at that point
notices the cancellation request and instead of returning to the caller
of 
<i>pthread_cond_wait()</i>
or
<i>pthread_cond_timedwait()</i>,
starts the thread cancellation activities, which includes calling
cancellation cleanup handlers.
<p>
A thread that has been unblocked because it has been
canceled while blocked in a call to
<i>pthread_cond_wait()</i>
or
<i>pthread_cond_timedwait()</i>
does not consume any condition signal that may be
directed concurrently at the
condition variable if there are other threads blocked on
the condition variable.
<p>
The
<i>pthread_cond_timedwait()</i>
function is the same as
<i>pthread_cond_wait()</i>
except that
an error is returned
if the absolute time specified by
<i>abstime</i>
passes (that is, system time equals or exceeds
<i>abstime</i>)
before the condition
<i>cond</i>
is signaled or broadcasted,
or if the absolute time specified by
<i>abstime</i>
has already been passed at the time of the call.
When such time-outs occur,
<i>pthread_cond_timedwait()</i>
will nonetheless release
and reacquire the mutex referenced by
<i>mutex</i>.
The function
<i>pthread_cond_timedwait()</i>
is also a cancellation point.
<p>
If a signal is delivered to a thread waiting for a condition variable,
upon return from the signal handler
the thread resumes waiting for the condition variable
as if it was not interrupted,
or it returns zero due to spurious wakeup.
</blockquote><h4><a name = "tag_000_007_1273">&nbsp;</a>RETURN VALUE</h4><blockquote>
Except in the case of [ETIMEDOUT],
all these error checks act as if they were performed immediately
at the beginning of processing for the function
and cause an error return,
in effect, prior to modifying the state of the mutex specified by
<i>mutex</i>
or the condition variable specified by
<i>cond</i>.
<p>
Upon successful completion, a value of zero is returned.
Otherwise, an error number is returned to indicate the error.
</blockquote><h4><a name = "tag_000_007_1274">&nbsp;</a>ERRORS</h4><blockquote>
The 
<i>pthread_cond_timedwait()</i>
function will fail if:
<dl compact>

<dt>[ETIMEDOUT]<dd>
The time specified by
<i>abstime</i>
to
<i>pthread_cond_timedwait()</i>
has passed.

</dl>
<p>
The
<i>pthread_cond_wait()</i>
and
<i>pthread_cond_timedwait()</i>
functions may fail if:
<dl compact>

<dt>[EINVAL]<dd>
The value specified by
<i>cond</i>,
<i>mutex</i>,
or
<i>abstime</i>
is invalid.

<dt>[EINVAL]<dd>Different mutexes were supplied for concurrent
<i>pthread_cond_wait()</i>
or
<i>pthread_cond_timedwait()</i>
operations on the same condition variable.

<dt>[EINVAL]<dd>The mutex was not owned by the current thread at the time of the call.

</dl>
<p>
These functions will not return an error code of [EINTR].
</blockquote><h4><a name = "tag_000_007_1275">&nbsp;</a>EXAMPLES</h4><blockquote>
None.
</blockquote><h4><a name = "tag_000_007_1276">&nbsp;</a>APPLICATION USAGE</h4><blockquote>
None.
</blockquote><h4><a name = "tag_000_007_1277">&nbsp;</a>FUTURE DIRECTIONS</h4><blockquote>
None.
</blockquote><h4><a name = "tag_000_007_1278">&nbsp;</a>SEE ALSO</h4><blockquote>
<i><a href="pthre140.htm">pthread_cond_signal()</a></i>,
<i><a href="pthre137.htm">pthread_cond_broadcast()</a></i>,
<i><a href="pthre114.htm">&lt;pthread.h&gt;</a></i>.
</blockquote><h4>DERIVATION</h4><blockquote>
Derived from the POSIX Threads Extension (1003.1c-1995)
</blockquote><hr size=2 noshade>
<center><font size=2>
UNIX &reg; is a registered Trademark of The Open Group.<br>
Copyright &copy; 1997 The Open Group
<br> [ <a href="../index.htm">Main Index</a> | <a href="../xshix.htm">XSH</a> | <a href="../xcuix.htm">XCU</a> | <a href="../xbdix.htm">XBD</a> | <a href="../cursesix.htm">XCURSES</a> | <a href="../xnsix.htm">XNS</a> ]

</font></center><hr size=2 noshade>
</body></html>

