<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<!-- Copyright 1997 The Open Group, All Rights Reserved -->
<title>timer_settime</title>
</head><body bgcolor=white>
<center>
<font size=2>
The Single UNIX &reg; Specification, Version 2<br>
Copyright &copy; 1997 The Open Group

</font></center><hr size=2 noshade>
<h4><a name = "tag_000_010_061">&nbsp;</a>NAME</h4><blockquote>
timer_settime, timer_gettime, timer_getoverrun - per-process timers
(<b>REALTIME</b>)
</blockquote><h4><a name = "tag_000_010_062">&nbsp;</a>SYNOPSIS</h4><blockquote>
<pre><code>

#include &lt;<a href="timeh289.htm">time.h</a>&gt;

int timer_settime(timer_t <i>timerid</i>, int <i>flags</i>,
    const struct itimerspec *<i>value</i>, struct itimerspec *<i>ovalue</i>);
int timer_gettime(timer_t <i>timerid</i>, struct itimerspec *<i>value</i>);
int timer_getoverrun(timer_t <i>timerid</i>);
</code>
</pre>
</blockquote><h4><a name = "tag_000_010_063">&nbsp;</a>DESCRIPTION</h4><blockquote>
The
<i>timer_settime()</i>
function sets the time until the next expiration
of the timer specified by
<i>timerid</i>
from the
<i>it_value</i>
member of the
<i>value</i>
argument and arm the timer if the
<i>it_value</i>
member of
<i>value</i>
is non-zero.
If the specified timer was already armed when
<i>timer_settime()</i>
is called,
this call resets the time until next expiration to the
<i>value</i>
specified.
If the
<i>it_value</i>
member of
<i>value</i>
is zero, the timer is disarmed.
The effect of disarming or resetting a timer
on pending expiration notifications is unspecified.
<p>
If the flag TIMER_ABSTIME
is not set in the argument
<i>flags</i>,
<i>timer_settime()</i>
behaves as if
the time until next expiration is set to be equal to the
interval specified by the
<i>it_value</i>
member of
<i>value</i>.
That is, the timer expires in
<i>it_value</i>
nanoseconds from when the call is made.
If the flag TIMER_ABSTIME
is set in the argument
<i>flags</i>,
<i>timer_settime()</i>
behaves as if
the time until next expiration is set to be equal to
the difference between the absolute time specified by the
<i>it_value</i>
member of
<i>value</i>
and the current value of the clock associated with
<i>timerid</i>.
That is, the timer expires when the clock reaches the
value specified by the
<i>it_value</i>
member of
<i>value</i>.
If the specified time has already passed,
the function succeeds and the expiration notification is made.
<p>
The reload value of the timer is set to the value specified by the
<i>it_interval</i>
member of
<i>value</i>.
When a timer is armed with a non-zero
<i>it_interval</i>,
a periodic (or repetitive) timer is specified.
<p>
Time values that are between two consecutive non-negative integer
multiples of the resolution of the specified timer will be rounded up
to the larger multiple of the resolution.
Quantization error will not cause the timer to expire earlier
than the rounded time value.
<p>
If the argument
<i>ovalue</i>
is not NULL, the function
<i>timer_settime()</i>
stores, in the location referenced by
<i>ovalue</i>,
a value representing the previous amount of time
before the timer would have expired or zero if the timer was disarmed,
together with the previous timer reload value.
The members of
<i>ovalue</i>
are subject to the resolution of the timer,
and they are the same values that would be returned by a
<i>timer_gettime()</i>
call at that point in time.
<p>
The
<i>timer_gettime()</i>
function stores the amount of time until the specified timer,
<i>timerid</i>,
expires and the reload value of the timer
into the space pointed to by the
<i>value</i>
argument.
The
<i>it_value</i>
member of this structure contains the amount of time
before the timer expires, or zero if the timer is disarmed.
This value is returned as the interval until timer expiration,
even if the timer was armed with
absolute time.
The
<i>it_interval</i>
member of
<i>value</i>
contains the reload value last set by
<i>timer_settime()</i>.
<p>
Only a single signal will be queued to the process for a
given timer at any point in time.
When a timer for which a signal is still pending expires,
no signal will be queued, and a
timer overrun occurs.
When a timer expiration signal is delivered to
or accepted by
a process,
if the implementation supports the Realtime Signals Extension,
the
<i>timer_getoverrun()</i>
function returns the timer expiration overrun count
for the specified timer.
The overrun count returned contains the number of extra timer expirations
that occurred between the time the signal was generated (queued)
and when it was delivered
or accepted,
up to but not including an implementation-dependent maximum of
{DELAYTIMER_MAX}.
If the number of such extra expirations is greater than or equal to
{DELAYTIMER_MAX}, then the overrun count will be set to
{DELAYTIMER_MAX}.
The value returned by
<i>timer_getoverrun()</i>
applies to the most recent expiration signal delivery
or acceptance
for the timer.
If no expiration signal has been delivered for the timer, or if the
Realtime Signals Extension
is not supported, the meaning of the overrun count returned is undefined.
</blockquote><h4><a name = "tag_000_010_064">&nbsp;</a>RETURN VALUE</h4><blockquote>
If the
<i>timer_settime()</i>
or
<i>timer_gettime()</i>
functions succeed, a value of 0 is returned.
If an error occurs for either of these functions,
the value -1 is returned, and
<i>errno</i>
is set to indicate the error.
If the
<i>timer_getoverrun()</i>
function succeeds,
it returns the timer expiration overrun count as explained above.
</blockquote><h4><a name = "tag_000_010_065">&nbsp;</a>ERRORS</h4><blockquote>
The 
<i>timer_settime()</i>,
<i>timer_gettime()</i>
and
<i>timer_getoverrun()</i>
functions will fail if:
<dl compact>

<dt>[EINVAL]<dd>
The
<i>timerid</i>
argument does not correspond to an id returned by
<i><a href="timer290.htm">timer_create()</a></i>
but not yet deleted by
<i><a href="timer291.htm">timer_delete()</a></i>.

<dt>[ENOSYS]<dd>
The functions
<i>timer_settime()</i>,
<i>timer_gettime()</i>,
and
<i>timer_getoverrun()</i>
are not supported by this implementation.

</dl>
<p>
The
<i>timer_settime()</i>
function will fail if:
<dl compact>

<dt>[EINVAL]<dd>
A
<i>value</i>
structure specified a nanosecond
value less than zero or greater than or equal to 1000 million.

</dl>
</blockquote><h4><a name = "tag_000_010_066">&nbsp;</a>EXAMPLES</h4><blockquote>
None.
</blockquote><h4><a name = "tag_000_010_067">&nbsp;</a>APPLICATION USAGE</h4><blockquote>
None.
</blockquote><h4><a name = "tag_000_010_068">&nbsp;</a>FUTURE DIRECTIONS</h4><blockquote>
None.
</blockquote><h4><a name = "tag_000_010_069">&nbsp;</a>SEE ALSO</h4><blockquote>
<i><a href="clock23.htm">clock_gettime()</a></i>,
<i><a href="timer290.htm">timer_create()</a></i>,
<i><a href="timeh289.htm">&lt;time.h&gt;</a></i>.
</blockquote><h4>DERIVATION</h4><blockquote>
Derived from the POSIX Realtime Extension (1003.1b-1993/1003.1i-1995)
</blockquote><hr size=2 noshade>
<center><font size=2>
UNIX &reg; is a registered Trademark of The Open Group.<br>
Copyright &copy; 1997 The Open Group
<br> [ <a href="../index.htm">Main Index</a> | <a href="../xshix.htm">XSH</a> | <a href="../xcuix.htm">XCU</a> | <a href="../xbdix.htm">XBD</a> | <a href="../cursesix.htm">XCURSES</a> | <a href="../xnsix.htm">XNS</a> ]

</font></center><hr size=2 noshade>
</body></html>

