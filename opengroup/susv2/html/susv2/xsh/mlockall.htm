<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<!-- Copyright 1997 The Open Group, All Rights Reserved -->
<title>mlockall</title>
</head><body bgcolor=white>
<center>
<font size=2>
The Single UNIX &reg; Specification, Version 2<br>
Copyright &copy; 1997 The Open Group

</font></center><hr size=2 noshade>
<h4><a name = "tag_000_007_686">&nbsp;</a>NAME</h4><blockquote>
mlockall, munlockall - lock/unlock the address space of a process
(<b>REALTIME</b>)
</blockquote><h4><a name = "tag_000_007_687">&nbsp;</a>SYNOPSIS</h4><blockquote>
<pre><code>

#include &lt;<a href="sysmm268.htm">sys/mman.h</a>&gt;

int mlockall(int <i>flags</i>);
int munlockall(void);
</code>
</pre>
</blockquote><h4><a name = "tag_000_007_688">&nbsp;</a>DESCRIPTION</h4><blockquote>
The function
<i>mlockall()</i>
causes all of the pages mapped by the address space of a process to be
memory resident until unlocked or until the process exits or
<i>exec</i>s
another process image.
The
<i>flags</i>
argument determines whether the pages to be locked are
those currently mapped by the address space of the process,
those that will be mapped in the future, or both.
The
<i>flags</i>
argument is constructed from the inclusive OR of one or more
of the following symbolic constants, defined in
<i><a href="sysmm268.htm">&lt;sys/mman.h&gt;</a></i>:
<dl compact>

<dt>MCL_CURRENT<dd>
Lock all of the pages currently mapped into the address space of the process.

<dt>MCL_FUTURE<dd>
Lock all of the pages that become mapped into the address space of the process
in the future, when those mappings are established.

</dl>
<p>
If MCL_FUTURE is specified, and the automatic locking of future mappings
eventually causes the amount of locked memory to exceed
the amount of available physical memory
or any other implementation-dependent limit,
the behaviour is implementation-dependent.
The manner in which the implementation informs the application
of these situations is also implementation-dependent.
<p>
The
<i>munlockall()</i>
function unlocks all currently mapped pages of the address space of the process.
Any pages that become mapped into the address space of the process
after a call to
<i>munlockall()</i>
will not be locked, unless there is an intervening call to
<i>mlockall()</i>
specifying MCL_FUTURE or a subsequent call to
<i>mlockall()</i>
MCL_CURRENT.
If pages mapped into the address space of the process are also mapped
into the address spaces of other processes
and are locked by those processes,
the locks established by the other processes are unaffected
by a call by this process to
<i>munlockall()</i>.
<p>
Upon successful return from the
<i>mlockall()</i>
function that specifies MCL_CURRENT,
all currently mapped pages of
the process's address space will be memory resident and locked.
Upon return from the
<i>munlockall()</i>
function, all currently mapped pages of the process's address space
will be unlocked with respect to the process's address space.
The memory residency of unlocked pages is unspecified.
<p>
The appropriate privilege is required to lock process memory with
<i>mlockall()</i>.
</blockquote><h4><a name = "tag_000_007_689">&nbsp;</a>RETURN VALUE</h4><blockquote>
Upon successful completion, the
<i>mlockall()</i>
function returns a value of zero.
Otherwise, no additional memory is locked, and
the function returns a value of -1 and sets
<i>errno</i>
to indicate the error.
The effect of failure of 
<i>mlockall()</i>
on previously existing locks in the address space is unspecified.
<p>
If it is supported by the implementation,
the
<i>munlockall()</i>
function always returns a value of zero.
Otherwise, the function returns a value of -1 and sets
<i>errno</i>
to indicate the error.
</blockquote><h4><a name = "tag_000_007_690">&nbsp;</a>ERRORS</h4><blockquote>
The 
<i>mlockall()</i>
and
<i>munlockall()</i>
functions will fail if:
<dl compact>

<dt>[ENOSYS]<dd>
The implementation does not support this memory locking interface.

</dl>
<p>
The 
<i>mlockall()</i>
function will fail if:
<dl compact>

<dt>[EAGAIN]<dd>
Some or all of the memory identified by the operation could not be locked
when the call was made.

<dt>[EINVAL]<dd>
The
<i>flags</i>
argument is zero, or includes unimplemented
flags.

</dl>
<p>
The 
<i>mlockall()</i>
function may fail if:
<dl compact>

<dt>[ENOMEM]<dd>
Locking all of the pages currently mapped into the address space of the process
would exceed an implementation-dependent limit on the amount of memory
that the process may lock.

<dt>[EPERM]<dd>
The calling process does not have the appropriate privilege to perform the
requested operation.

</dl>
</blockquote><h4><a name = "tag_000_007_691">&nbsp;</a>EXAMPLES</h4><blockquote>
None.
</blockquote><h4><a name = "tag_000_007_692">&nbsp;</a>APPLICATION USAGE</h4><blockquote>
None.
</blockquote><h4><a name = "tag_000_007_693">&nbsp;</a>SEE ALSO</h4><blockquote>
<i><a href="exec.htm">exec</a></i>,
<i><a href="exit2.htm">_exit()</a></i>,
<i><a href="fork.htm">fork()</a></i>,
<i><a href="mlock.htm">mlock()</a></i>,
<i><a href="munmap.htm">munmap()</a></i>,
<i><a href="sysmm268.htm">&lt;sys/mman.h&gt;</a></i>.
</blockquote><h4>DERIVATION</h4><blockquote>
Derived from the POSIX Realtime Extension (1003.1b-1993/1003.1i-1995)
</blockquote><hr size=2 noshade>
<center><font size=2>
UNIX &reg; is a registered Trademark of The Open Group.<br>
Copyright &copy; 1997 The Open Group
<br> [ <a href="../index.htm">Main Index</a> | <a href="../xshix.htm">XSH</a> | <a href="../xcuix.htm">XCU</a> | <a href="../xbdix.htm">XBD</a> | <a href="../cursesix.htm">XCURSES</a> | <a href="../xnsix.htm">XNS</a> ]

</font></center><hr size=2 noshade>
</body></html>

