<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<!-- Copyright 1997 The Open Group, All Rights Reserved -->
<title>accept</title>
</head><body bgcolor=white>
<center>
<font size=2>
The Single UNIX &reg; Specification, Version 2<br>
Copyright &copy; 1997 The Open Group

</font></center><hr size=2 noshade>
<h4>NAME</h4><blockquote>
accept - accept a new connection on a socket
</blockquote><h4>SYNOPSIS</h4><blockquote>
<pre><code>

#include &lt;<a href="sysso38.htm">sys/socket.h</a>&gt;

int accept (int <I>socket</I>, struct sockaddr *<I>address</I>,
                                 socklen_t *<I>address_len</I>);
</code>
</pre>
</blockquote><h4>DESCRIPTION</h4><blockquote>
The
<i>accept()</i>
function extracts the first connection on the queue of pending connections,
creates a new socket with the same socket type protocol and address family as
the specified socket, and allocates a new file descriptor for that socket.
<p>
The function takes the following arguments:
<dl compact>

<dt><I>socket</I><dd>Specifies a socket that was created with
<i><a href="socket.htm">socket()</a></i>,
has been bound to an address with
<i><a href="bind.htm">bind()</a></i>,
and has issued a successful call to
<i><a href="listen.htm">listen()</a></i>.

<dt><I>address</I><dd>Either a null pointer, or a pointer to a <B>sockaddr</B> structure
where the address of the connecting socket will be returned.

<dt><I>address_len</I><dd>Points to a <B>socklen_t</B> which on input specifies the length of the supplied
<B>sockaddr</B> structure, and on output specifies the length of the stored
address.

</dl>
<p>
If <I>address</I> is not a null pointer, the address of the peer
for the accepted connection is stored in the <B>sockaddr</B> structure
pointed to by <I>address</I>, and the length of this address is
stored in the object pointed to by <I>address_len</I>.
<p>
If the actual length of the address is greater than the length of the supplied
<B>sockaddr</B> structure, the stored address will be truncated.
<p>
If the protocol permits connections by unbound clients, and the peer is not
bound, then the value stored in the object pointed to by <I>address</I> is
unspecified.
<p>
If the listen queue is empty of connection requests and O_NONBLOCK is not set
on the file descriptor for the socket,
<i>accept()</i>
will block until a connection is present.
If the
<i><a href="listen.htm">listen()</a></i>
queue is empty of connection requests and
O_NONBLOCK is set on the file descriptor for the socket,
<i>accept()</i>
will fail and set <I>errno</I> to [EAGAIN] or [EWOULDBLOCK]. 
<p>
The accepted socket cannot itself accept more connections.  The
original socket remains open and can accept more connections.
</blockquote><h4>RETURN VALUE</h4><blockquote>
Upon successful completion,
<i>accept()</i>
returns the nonnegative file descriptor of the accepted socket.  Otherwise,
-1 is returned and <I>errno</I> is set to indicate the error.
</blockquote><h4>ERRORS</h4><blockquote>
The
<i>accept()</i>
function will fail if:
<dl compact>

<dt>[EAGAIN] or [EWOULDBLOCK]<dd><br>
O_NONBLOCK is set for the socket file descriptor and no connections
are present to be accepted.

<dt>[EBADF]<dd>The <I>socket</I> argument is not a valid file descriptor.

<dt>[ECONNABORTED]<dd>A connection has been aborted.

<dt>[EFAULT]<dd>The 
<I>address</I>
or 
<I>address_len</I>
parameter can not be accessed or written.

<dt>[EINTR]<dd>The
<i>accept()</i>
function was interrupted by a signal that was caught before a valid connection
arrived.

<dt>[EINVAL]<dd>The <I>socket</I> is not accepting connections.

<dt>[EMFILE]<dd>{OPEN_MAX} file descriptors are currently open in the calling process.

<dt>[ENFILE]<dd>The maximum number of file descriptors in the system are already open.

<dt>[ENOTSOCK]<dd>The <I>socket</I> argument does not refer to a socket.

<dt>[EOPNOTSUPP]<dd>The socket type of the specified socket does not support accepting
connections.

</dl>
<p>
The
<i>accept()</i>
function may fail if:
<dl compact>

<dt>[ENOBUFS]<dd>No buffer space is available.

<dt>[ENOMEM]<dd>There was insufficient memory available to complete the operation.

<dt>[ENOSR]<dd>There was insufficient STREAMS resources available to complete the operation.

<dt>[EPROTO]<dd>A protocol error has occurred; for example, the STREAMS protocol stack has not
been initialised.

</dl>
</blockquote><h4>APPLICATION USAGE</h4><blockquote>
When a connection is available,
<i><a href="select.htm">select()</a></i>
will indicate that the file descriptor for the socket is ready for reading.
</blockquote><h4>SEE ALSO</h4><blockquote>
<i><a href="bind.htm">bind()</a></i>,
<i><a href="connect.htm">connect()</a></i>,
<i><a href="listen.htm">listen()</a></i>,
<i><a href="socket.htm">socket()</a></i>,
<i><a href="sysso38.htm">&lt;sys/socket.h&gt;</a></i>.
</blockquote><hr size=2 noshade>
<center><font size=2>
UNIX &reg; is a registered Trademark of The Open Group.<br>
Copyright &copy; 1997 The Open Group
<br> [ <a href="../index.htm">Main Index</a> | <a href="../xshix.htm">XSH</a> | <a href="../xcuix.htm">XCU</a> | <a href="../xbdix.htm">XBD</a> | <a href="../cursesix.htm">XCURSES</a> | <a href="../xnsix.htm">XNS</a> ]

</font></center><hr size=2 noshade>
</body></html>
