<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<!-- Copyright 1997 The Open Group, All Rights Reserved -->
<title>t_snd</title>
</head><body bgcolor=white>
<center>
<font size=2>
The Single UNIX &reg; Specification, Version 2<br>
Copyright &copy; 1997 The Open Group

</font></center><hr size=2 noshade>
<xref type="10" name="sndmm"></xref>
<h4>NAME</h4><blockquote>
t_snd - send data or expedited data over a connection
</blockquote><h4>SYNOPSIS</h4><blockquote>
<pre><code>

#include &lt;<a href="xtih78.htm">xti.h</a>&gt;

int t_snd(
    int fd,
    void *buf,
    unsigned int nbytes,
    int flags)
</code>
</pre>
</blockquote><h4>DESCRIPTION</h4><blockquote>
<pre>
<P><table  bordercolor=#000000 border=1 align=center><tr valign=top><th align=center><b>Parameters</b>
<th align=center><b>Before call</b>
<th align=center><b>After call</b>
<tr valign=top><td align=left>fd
<td align=center>x
<td align=center>/
<tr valign=top><td align=left>buf
<td align=center>x (x)
<td align=center>=
<tr valign=top><td align=left>nbytes
<td align=center>x
<td align=center>/
<tr valign=top><td align=left>flags
<td align=center>x
<td align=center>/
</table>
</pre>
<p>
This function is used to send either normal or expedited data.
The argument
<I>fd</I>
identifies the local transport endpoint over which data should be sent,
<I>buf</I>
points to the user data,
<I>nbytes</I>
specifies the number of bytes of user data to be sent, and
<I>flags</I>
specifies any optional flags described below:
<dl compact>

<dt>T_EXPEDITED<dd>If set in
<I>flags</I>,
the data will be sent as expedited data and will be subject to the
interpretations of the transport provider.

<dt>T_MORE<dd>If set in
<I>flags</I>,
this indicates to the transport provider that the transport service
data unit (TSDU)
(or expedited transport service data unit - ETSDU)
is being sent through multiple
<i>t_snd()</i>
calls.  Each
<i>t_snd()</i>
with the T_MORE flag set indicates that another
<i>t_snd()</i>
will follow with more data for the current TSDU (or ETSDU).

The end of the TSDU (or ETSDU) is identified by a
<i>t_snd()</i>
call with the T_MORE flag not set.
Use of T_MORE
enables a user to break up large logical data units without losing
the boundaries of those units at the other end of the connection.
The flag implies nothing about how the data is
packaged for transfer below the transport interface.
If the transport provider does not support the concept of a TSDU
as indicated in the
<I>info</I>
argument on return from
<i><a href="topen55.htm">t_open()</a></i>
or
<i><a href="tgeti50.htm">t_getinfo()</a></i>,
the T_MORE flag is not meaningful and will be ignored if set.

The sending of a zero-length fragment of a TSDU or ETSDU is only permitted where
this is used to indicate the end of a TSDU or ETSDU; that is, when the
T_MORE flag is not set. Some transport providers also forbid
zero-length TSDUs and ETSDUs.
See
<xref href=istpi></xref>
for a fuller explanation.


<dt>T_PUSH<dd><index term="T_PUSH, "></index>
If set in <I>flags</I>, requests that the provider transmit all data
that it has accumulated but not sent.  The request is a local action
on the provider and does not affect any similarly named protocol
flag (for example, the TCP PUSH flag). This effect of setting
this flag is protocol-dependent, and it may be ignored entirely
by transport providers which do not support the use of this feature. 

<dl><dt><b>Note:</b>
<dd>The communications provider is free to collect
data in a send buffer until it accumulates a sufficient
amount for transmission.
</dl>
<p>
</dl>
<p>
By default,
<i>t_snd()</i>
operates in synchronous mode and
may wait if flow control restrictions prevent the data from
being accepted by the local transport provider at the time
the call is made.  However, if O_NONBLOCK is set (via
<i><a href="topen55.htm">t_open()</a></i>
or
<i><a href="fcntl.htm">fcntl()</a></i>),
<i>t_snd()</i>
will execute in asynchronous mode,
and will fail immediately if there are flow control restrictions.
The process can arrange to be informed
when the flow control restrictions
are cleared via either
<i><a href="tlook54.htm">t_look()</a></i>
or the EM interface.
<p>
On successful completion, 
<i>t_snd()</i>
returns the number of bytes (octets)
accepted by the communications provider.  Normally this will
equal the number of octets specified in nbytes.  However, if
O_NONBLOCK is set or the function is interrupted by a signal, it
is possible that only part of the data has actually been
accepted by the communications provider.  In this case, 
<i>t_snd()</i>
returns a value that is less than the value of nbytes.  If
<i>t_snd()</i>
is interrupted by a signal before it could transfer data
to the communications provider, it returns -1 with 
<I>t_errno</I>
set to [TSYSERR] and 
<I>errno</I>
set to [EINTR].
<p>
If nbytes is zero and sending of zero bytes is not supported by
the underlying communications service, 
<i>t_snd()</i>
returns -1
with 
<I>t_errno</I>
set to [TBADDATA].
<p>
The size of each TSDU or ETSDU must not exceed the limits of the
transport provider as specified by the current values
in the TSDU or ETSDU fields in
the
<I>info</I>
argument returned by
<i><a href="tgeti50.htm">t_getinfo()</a></i>.
<p>
The error [TLOOK] is returned for asynchronous events. It is required
only for an incoming disconnect event but may be returned for
other events.
</blockquote><h4>VALID STATES</h4><blockquote>
T_DATAXFER, T_INREL
</blockquote><h4>ERRORS</h4><blockquote>
On failure,
<I>t_errno</I>
is set to one of the following:
<dl compact>

<dt>[TBADDATA]<dd>Illegal amount of data:
<ul>

<li>
A single send was attempted specifying a TSDU (ETSDU) or fragment
TSDU (ETSDU) greater than that specified
by the current values of the TSDU or ETSDU fields in
the <I>info</I> argument.

<li>
A send of a zero byte TSDU (ETSDU) or zero byte fragment of a
TSDU (ETSDU) is not supported by the provider (see
<xref href=istpi></xref>.

<li>
Multiple sends were attempted resulting in a TSDU (ETSDU) larger
than that specified by the current value of the TSDU or ETSDU
fields in the
<I>info</I>
argument - the ability of an XTI implementation to detect such an
error case is implementation-dependent (see <B>CAVEATS</B>, below).

</ul>

<dt>[TBADF]<dd>The specified file descriptor does not refer to a transport endpoint.

<dt>[TBADFLAG]<dd>An invalid flag was specified.

<dt>[TFLOW]<dd>O_NONBLOCK
was set, but
the flow control mechanism prevented the transport provider from
accepting any data at this time.

<dt>[TLOOK]<dd>An asynchronous event has occurred on this transport endpoint.

<dt>[TNOTSUPPORT]<dd>This function is not supported by the underlying transport
provider.

<dt>[TOUTSTATE]<dd>The communications endpoint referenced by 
<I>fd</I>
is not in one of the states in which a call to this function is valid.

<dt>[TPROTO]<dd>This error indicates that a communication problem has been detected between
XTI and the transport provider for which there is no other suitable XTI
error
<I>(t_errno)</I>.

<dt>[TSYSERR]<dd>A system error has occurred during execution of this function.

</dl>
</blockquote><h4>RETURN VALUE</h4><blockquote>
On successful completion,
<i>t_snd()</i>
returns the number of bytes accepted by the transport provider.
Otherwise, -1 is returned on failure and
<I>t_errno</I>
is set to indicate the error.
<p>
<dl><dt><b>Note:</b>
<dd>If the number of bytes accepted by the communications
provider is less than the number of bytes requested, this may
either indicate that O_NONBLOCK is set and the communications
provider is blocked due to flow control, or that O_NONBLOCK is
clear and the function was interrupted by a signal.
</dl>
</blockquote><h4>SEE ALSO</h4><blockquote>
<i><a href="tgeti50.htm">t_getinfo()</a></i>,
<i><a href="topen55.htm">t_open()</a></i>,
<i><a href="trcv57.htm">t_rcv()</a></i>.
</blockquote><h4>CAVEATS</h4><blockquote>
It is important to remember that the transport provider treats all users
of a transport endpoint as a single user.
Therefore if several processes issue concurrent
<i>t_snd()</i>
calls then the different data may be intermixed.
<p>
Multiple sends which exceed the maximum TSDU or ETSDU size may
not be discovered by XTI.  In this case an
implementation-dependent error
will result (generated by the transport provider)
perhaps on a subsequent XTI call.  This error may take the form
of a connection abort, a [TSYSERR], a [TBADDATA] or a [TPROTO] error.
<p>
If multiple sends which exceed the maximum TSDU or ETSDU size are detected by
XTI,
<i>t_snd()</i>
fails with [TBADDATA].
</blockquote><hr size=2 noshade>
<center><font size=2>
UNIX &reg; is a registered Trademark of The Open Group.<br>
Copyright &copy; 1997 The Open Group
<br> [ <a href="../index.htm">Main Index</a> | <a href="../xshix.htm">XSH</a> | <a href="../xcuix.htm">XCU</a> | <a href="../xbdix.htm">XBD</a> | <a href="../cursesix.htm">XCURSES</a> | <a href="../xnsix.htm">XNS</a> ]

</font></center><hr size=2 noshade>
</body></html>
