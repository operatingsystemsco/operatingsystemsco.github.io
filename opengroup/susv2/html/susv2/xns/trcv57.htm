<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<!-- Copyright 1997 The Open Group, All Rights Reserved -->
<title>t_rcv</title>
</head><body bgcolor=white>
<center>
<font size=2>
The Single UNIX &reg; Specification, Version 2<br>
Copyright &copy; 1997 The Open Group

</font></center><hr size=2 noshade>
<h4>NAME</h4><blockquote>
t_rcv - receive data or expedited data sent over a connection
</blockquote><h4>SYNOPSIS</h4><blockquote>
<pre><code>

#include &lt;<a href="xtih78.htm">xti.h</a>&gt;

int t_rcv(
    int fd,
    void *buf,
    unsigned int nbytes,
    int *flags)
</code>
</pre>
</blockquote><h4>DESCRIPTION</h4><blockquote>
<pre>
<P><table  bordercolor=#000000 border=1 align=center><tr valign=top><th align=center><b>Parameters</b>
<th align=center><b>Before call</b>
<th align=center><b>After call</b>
<tr valign=top><td align=left>fd
<td align=center>x
<td align=center>/
<tr valign=top><td align=left>buf
<td align=center>x
<td align=center>(x)
<tr valign=top><td align=left>nbytes
<td align=center>x
<td align=center>/
<tr valign=top><td align=left>flags
<td align=center>/
<td align=center>x
</table>
</pre>
<p>
This function receives either normal or expedited data.
The argument
<I>fd</I>
identifies the local transport endpoint through which data will arrive,
<I>buf</I>
points to a receive buffer where user data will be placed, and
<I>nbytes</I>
specifies the size of the receive buffer.
The argument
<I>flags</I>
may be set on return from
<i>t_rcv()</i>
and specifies optional flags as described below.
<p>
By default,
<i>t_rcv()</i>
operates in synchronous mode and will
wait for data to arrive if none is currently available.
However, if
O_NONBLOCK
is set (via
<i><a href="topen55.htm">t_open()</a></i>
or
<i><a href="fcntl.htm">fcntl()</a></i>),
<i>t_rcv()</i>
will execute in asynchronous mode and will
fail if no data is available.
(See [TNODATA] below.)
<p>
On return from the call,
if T_MORE is set in
<I>flags</I>,
this indicates that there is more data, and the current
transport service data unit (TSDU) or expedited transport
service data unit (ETSDU)
must be received in multiple
<i>t_rcv()</i>
calls.
In the asynchronous mode,
or under unusual conditions (for example, the
arrival of a signal or T_EXDATA event), 
the T_MORE flag may be set on return from the
<i>t_rcv()</i>
call even when the number of bytes received is less than the size of the
receive buffer specified.
Each
<i>t_rcv()</i>
with the T_MORE flag set indicates that another
<i>t_rcv()</i>
must follow to get more data for the current TSDU.
The end of the TSDU is identified by the return of a
<i>t_rcv()</i>
call with the T_MORE flag not set.
If the transport provider does not support the concept of a TSDU
as indicated in the
<I>info</I>
argument on return from
<i><a href="topen55.htm">t_open()</a></i>
or
<i><a href="tgeti50.htm">t_getinfo()</a></i>,
the T_MORE flag is not meaningful and should be ignored.  If
<I>nbytes</I>
is greater than zero on the call to
<i>t_rcv()</i>,
<i>t_rcv()</i>
will return 0 only if the end of a TSDU is being returned to the user.
<p>
On return, the data is expedited if T_EXPEDITED is set in
flags.  If T_MORE is also set, it indicates that the number of
expedited bytes exceeded nbytes, a signal has interrupted the 
call, or that an entire ETSDU was not available (only for     
transport protocols that support fragmentation of ETSDUs).  The
rest of the ETSDU will be returned by subsequent calls to       
<i>t_rcv()</i>
which will return with T_EXPEDITED set in flags. The end of
the ETSDU is identified by the return of a 
<i>t_rcv()</i>
call with T_EXPEDITED set and T_MORE cleared.  If the entire ETSDU is not
available it is possible for normal data fragments to be      
returned between the initial and final fragments of an ETSDU.
<p>
If a signal arrives,
<i>t_rcv()</i>
returns, giving the user any data
currently available.  If no data is available, 
<i>t_rcv()</i>
returns -1, sets 
<I>t_errno</I>
to [TSYSERR] and 
<I>errno</I>
to [EINTR].  If some
data is available, 
<i>t_rcv()</i>
returns the number of bytes received and T_MORE is set in flags.
<p>
In synchronous mode, the only way for the user to be notified of
the arrival of normal or expedited data is to issue this function
or check for the T_DATA or T_EXDATA events using the
<i><a href="tlook54.htm">t_look()</a></i>
function.  Additionally, the process can arrange to be notified via the EM
interface.
</blockquote><h4>VALID STATES</h4><blockquote>
T_DATAXFER, T_OUTREL
</blockquote><h4>ERRORS</h4><blockquote>
On failure,
<I>t_errno</I>
is set to one of the following:
<dl compact>

<dt>[TBADF]<dd>The specified file descriptor does not refer to a transport endpoint.

<dt>[TLOOK]<dd>An asynchronous event has occurred on this transport endpoint and requires
immediate attention.

<dt>[TNODATA]<dd>O_NONBLOCK
was set, but
no data is currently available from the transport provider.

<dt>[TNOTSUPPORT]<dd>This function is not supported by the underlying transport provider.

<dt>[TPROTO]<dd>This error indicates that a communication problem has been detected between
XTI and the transport provider for which there is no other suitable XTI
error
<I>(t_errno)</I>.

<dt>[TSYSERR]<dd>A system error has occurred during execution of this function.

</dl>
</blockquote><h4>RETURN VALUE</h4><blockquote>
On successful completion,
<i>t_rcv()</i>
returns the number of bytes received. Otherwise, it
returns -1 on failure and
<I>t_errno</I>
is set to indicate the error.
</blockquote><h4>SEE ALSO</h4><blockquote>
<i><a href="fcntl.htm">fcntl()</a></i>,
<i><a href="tgeti50.htm">t_getinfo()</a></i>,
<i><a href="tlook54.htm">t_look()</a></i>,
<i><a href="topen55.htm">t_open()</a></i>,
<i><a href="tsnd66.htm">t_snd()</a></i>.
</blockquote><hr size=2 noshade>
<center><font size=2>
UNIX &reg; is a registered Trademark of The Open Group.<br>
Copyright &copy; 1997 The Open Group
<br> [ <a href="../index.htm">Main Index</a> | <a href="../xshix.htm">XSH</a> | <a href="../xcuix.htm">XCU</a> | <a href="../xbdix.htm">XBD</a> | <a href="../cursesix.htm">XCURSES</a> | <a href="../xnsix.htm">XNS</a> ]

</font></center><hr size=2 noshade>
</body></html>
