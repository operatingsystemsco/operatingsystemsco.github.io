*** motif.orig/bitmaps/Imakefile	Wed May  3 05:12:34 2000
--- motif/bitmaps/Imakefile	Wed May 10 13:51:35 2000
***************
*** 56,59 ****
  
  all::
  
! InstallMultipleFlags($(HEADERS),$(INCDIR)/bitmaps,$(INSTINCFLAGS))
--- 56,59 ----
  
  all::
  
! InstallMultipleFlags($(HEADERS),$(XPROJECTROOT)/include/X11/bitmaps/,$(INSTINCFLAGS))
*** motif.orig/clients/mwm/Imakefile	Wed May  3 05:12:34 2000
--- motif/clients/mwm/Imakefile	Sat Jun  3 18:26:40 2000
***************
*** 77,89 ****
  XCOMM INCLUDES = -I. -I$(BMSLIBSRC)
  INCLUDES = -I.
  
! DEPLIBS = $(DEPXMLIB)  $(DEPXTOOLLIB) $(DEPXLIB)
  LOCAL_LIBRARIES = ./WmWsmLib/libWsm.a XmClientLibs
! SYS_LIBRARIES = -lm
  
  /** You must explicitly list the dependent libraries in DEPLIBS */
  
! #if defined(AlphaArchitecture)
  EXTRA_DEFINES = -DMULTIBYTE -DMINIMAL_DT -DALPHA_BUG_FIX -DOSF_v1_2_4
  SYS_LIBRARIES = -lm $(TTLIB)
  #endif
--- 77,89 ----
  XCOMM INCLUDES = -I. -I$(BMSLIBSRC)
  INCLUDES = -I.
  
!        DEPLIBS1 = ./WmWsmLib/libWsm.a XmClientDepLibs
  LOCAL_LIBRARIES = ./WmWsmLib/libWsm.a XmClientLibs
!   SYS_LIBRARIES = MathLibrary
  
  /** You must explicitly list the dependent libraries in DEPLIBS */
  
! #if defined(OSF1Architecture) && defined(AlphaArchitecture)
  EXTRA_DEFINES = -DMULTIBYTE -DMINIMAL_DT -DALPHA_BUG_FIX -DOSF_v1_2_4
  SYS_LIBRARIES = -lm $(TTLIB)
  #endif
***************
*** 129,134 ****
--- 129,138 ----
  EXTRA_DEFINES = -DMULTIBYTE -DMINIMAL_DT -DPORT_NOVFORK
  #endif /* SCOArchitecture */
  
+ #if defined (LinuxArchitecture)
+ EXTRA_DEFINES = MwmDefines
+ #endif /* LinuxArchitecture */
+ 
  XCOMM old         DEFINES = AutoDefines MwmDefines
  XCOMM old        INCLUDES = -I. -I$(INCLUDESRC) -I$(MINCLUDESRC)  AutoIncludes
  XCOMM old        DEPLIBS1 = ./WmWsmLib/libWsm.a XmClientDepLibs
***************
*** 170,176 ****
  XCOMM old Button.c
  
  NormalLibraryObjectRule()
! ComplexProgramTarget_1(mwm,$(LOCAL_LIBRARIES),$(SYSTEM_LIBRARIES))
  
  SpecialObjectRule(WmResParse.o,NullParameter,-DLIBDIR='"'$(XPROJECTROOT)/lib/X11'"')
  SpecialObjectRule(WmResource.o,NullParameter,-DBITMAPDIR='"'$(XPROJECTROOT)/include/X11/bitmaps/'"')
--- 174,180 ----
  XCOMM old Button.c
  
  NormalLibraryObjectRule()
! MComplexProgramTarget_1(mwm,$(LOCAL_LIBRARIES),$(SYSTEM_LIBRARIES))
  
  SpecialObjectRule(WmResParse.o,NullParameter,-DLIBDIR='"'$(XPROJECTROOT)/lib/X11'"')
  SpecialObjectRule(WmResource.o,NullParameter,-DBITMAPDIR='"'$(XPROJECTROOT)/include/X11/bitmaps/'"')
***************
*** 213,219 ****
  CppFileTarget(sys.mwmrc,sys.mwmrc.src,$(LOCAL_CPP_DEFINES),)
  */
  
! InstallNonExecFile(system.mwmrc,$(LIBDIR))
  InstallAppDefaults(Mwm)
  
  MessageCatalogRule(Mwm)
--- 217,223 ----
  CppFileTarget(sys.mwmrc,sys.mwmrc.src,$(LOCAL_CPP_DEFINES),)
  */
  
! InstallNonExecFile(system.mwmrc,$(XPROJECTROOT)/lib/X11)
  InstallAppDefaults(Mwm)
  
  MessageCatalogRule(Mwm)
*** motif.orig/clients/mwm/system.mwmrc	Wed May  3 05:12:34 2000
--- motif/clients/mwm/system.mwmrc	Sat Jun  3 18:27:23 2000
***************
*** 39,45 ****
  ! 
  
  !!
! !!  DEFAULT Mwm 1.2 RESOURCE DESCRIPTION FILE (system.mwmrc)
  !!
  !!  NOTE: To personalize this file, copy this file before editing it.
  !!  	  Personalize copies of the Mwm resource file typically
--- 39,45 ----
  ! 
  
  !!
! !!  DEFAULT Mwm RESOURCE DESCRIPTION FILE (system.mwmrc)
  !!
  !!  NOTE: To personalize this file, copy this file before editing it.
  !!  	  Personalize copies of the Mwm resource file typically
***************
*** 63,69 ****
  !	"Toggle Behavior..."	f.set_behavior
  	 no-label		f.separator
  	"Restart..."		f.restart
! !	"Quit..."		f.quit_mwm
  
  }
  
--- 63,69 ----
  !	"Toggle Behavior..."	f.set_behavior
  	 no-label		f.separator
  	"Restart..."		f.restart
! 	"Quit..."		f.quit_mwm
  
  }
  
*** motif.orig/clients/mwm/WmEvent.c	Tue May  2 11:53:42 2000
--- motif/clients/mwm/WmEvent.c	Sat Jun  3 19:10:27 2000
***************
*** 243,249 ****
      unsigned int mask;
  
      /* count the number of masks in the lock sequence */
!     for (num_masks=0; wmGD.pLockMaskSequence[num_masks] != NULL; num_masks++);
  
      /* insure we have enough space for our returned masks */
      if ((pRetMasks == NULL) || (len_ret_masks < num_masks+2))
--- 243,249 ----
      unsigned int mask;
  
      /* count the number of masks in the lock sequence */
!     for (num_masks=0; wmGD.pLockMaskSequence[num_masks] != 0; num_masks++);
  
      /* insure we have enough space for our returned masks */
      if ((pRetMasks == NULL) || (len_ret_masks < num_masks+2))
*** motif.orig/clients/mwm/WmFunction.c	Tue May  2 11:53:42 2000
--- motif/clients/mwm/WmFunction.c	Thu Jun  8 17:43:21 2000
***************
*** 53,58 ****
--- 53,73 ----
   */
  
  #include "WmGlobal.h"
+ #include <sys/types.h>
+ #ifndef X_NOT_STDC_ENV
+ #include <stdlib.h>
+ #include <unistd.h>
+ #include <sys/wait.h>
+ #else
+ extern int putenv();
+ extern char *getenv();
+ extern int atoi();
+ extern pid_t wait();
+ 
+ #ifndef PORT_NOVFORK
+ extern pid_t vfork();
+ #endif /* PORT_NOVFORK */
+ #endif
  #ifndef WSM
  #include <signal.h>
  #endif
***************
*** 107,118 ****
  #include <Xm/RowColumnP.h> /* for MS_LastManagedMenuTime */
  extern XmMenuState _XmGetMenuState();
  
- extern int putenv ();
- extern char * getenv ();
- #ifndef PORT_NOVFORK
- extern pid_t vfork();
- #endif /* PORT_NOVFORK */
- 
  static unsigned int GetEventInverseMask(XEvent *event);
  
  #ifdef WSM
--- 122,127 ----
***************
*** 1009,1014 ****
--- 1018,1024 ----
  #ifndef WSM
      void (*intStat) ();
      void (*quitStat) ();
+     void (*chldStat) ();
  #endif /* WSM */
      char *shell;
      char *shellname;
***************
*** 1031,1036 ****
--- 1041,1059 ----
      }
  #endif /* PANELIST */
  
+ #ifndef WSM
+     /* For now use only for non WSM code.  May integrate to WSM later. */
+     /*
+      * Disable SIGCHLD while we wait for this child to exit, otherwise
+      * we will go into the ChildProcSignalHandler and will never get the
+      * correct child pid in the while loop below. pgw@ixi 30-5-95 IBIS 20585.
+      *
+      * Moved before fork() to avoid race condition.
+      * Change handler to SIG_DFL, SIG_IGN causes bug. paulsh@sequent 31-08-95.
+      */
+     chldStat = (void (*)())signal (SIGCHLD, SIG_DFL); 
+ #endif
+ 
      /*
       * Fork a process to exec a shell to run the specified command:
       */
***************
*** 1043,1049 ****
      {
  
  #ifndef NO_SETPGRP
! #if defined(SVR4) || defined(__OSF1__) || defined(__osf__) || defined(linux)
  	setsid();
  #else
  #ifdef SYSV
--- 1066,1072 ----
      {
  
  #ifndef NO_SETPGRP
! #if defined(SVR4) || defined(__OSF1__) || defined(__osf__) || defined(_POSIX_JOB_CONTROL)
  	setsid();
  #else
  #ifdef SYSV
***************
*** 1142,1147 ****
--- 1165,1176 ----
  #else /* WSM */
      while ((w = wait (&status)) != pid && (w != -1));
  
+     /*
+      * Currently the only purpose for setting the local variable "status"
+      * here is as a convenience for setting break points or querying the
+      * value of "status" when using a debugger.
+      * Otherwise the value of "status" is unused beyond this point.
+      */
      if (w == -1)
      {
  	status = -1;
***************
*** 1151,1156 ****
--- 1180,1186 ----
  #ifndef WSM
      signal (SIGINT, intStat);
      signal (SIGQUIT, quitStat);
+     signal (SIGCHLD, chldStat);
  #endif /* WSM */
  
      /*
***************
*** 1770,1776 ****
  		   /* user clicked on the frame but we don't want the focus */
  		   /* set it to the client's frame */
  		   XSetInputFocus (DISPLAY, pcdFocus->clientBaseWin,
! 				RevertToPointerRoot, focusTime);
  		  }
  		  else if ( !(flags & CLIENT_AREA_FOCUS)                   &&
  		       !(pcdFocus->protocolFlags & PROTOCOL_WM_TAKE_FOCUS) &&
--- 1800,1806 ----
  		   /* user clicked on the frame but we don't want the focus */
  		   /* set it to the client's frame */
  		   XSetInputFocus (DISPLAY, pcdFocus->clientBaseWin,
! 				RevertToPointerRoot, CurrentTime);
  		  }
  		  else if ( !(flags & CLIENT_AREA_FOCUS)                   &&
  		       !(pcdFocus->protocolFlags & PROTOCOL_WM_TAKE_FOCUS) &&
***************
*** 1778,1789 ****
  		     )
  		  {
  		    XSetInputFocus (DISPLAY, focusWindow,
! 				    RevertToPointerRoot, focusTime);
  		  }
  		  else
  		  {
  		    XSetInputFocus (DISPLAY, focusWindow,
! 				      RevertToParent, focusTime);
  		  }
  		}
  		else
--- 1808,1819 ----
  		     )
  		  {
  		    XSetInputFocus (DISPLAY, focusWindow,
! 				    RevertToPointerRoot, CurrentTime);
  		  }
  		  else
  		  {
  		    XSetInputFocus (DISPLAY, focusWindow,
! 				      RevertToParent, CurrentTime);
  		  }
  		}
  		else
*** motif.orig/clients/mwm/WmGlobal.h	Tue May  2 11:53:42 2000
--- motif/clients/mwm/WmGlobal.h	Sat Jun  3 19:34:43 2000
***************
*** 2023,2028 ****
--- 2023,2032 ----
  /* global return buffer */
  #define MAXWMPATH				1023
  #define MAXBUF				(MAXWMPATH+1)
+ 
+ #define PIXMAP_IS_VALID(pix) \
+   ((pix) != XmUNSPECIFIED_PIXMAP && (pix) != None && (pix) != (Pixmap)NULL)
+   
  #ifdef WSM
  
  /*************************************<->*************************************
*** motif.orig/clients/mwm/WmImage.c	Tue May  2 11:53:42 2000
--- motif/clients/mwm/WmImage.c	Sat Jun  3 19:34:43 2000
***************
*** 120,173 ****
  	Pixmap iconBitmap, 
  	Pixmap iconMask)
  {
!     Window root;
!     int x;
!     int y;
!     unsigned int bitmapWidth;
!     unsigned int bitmapHeight;
!     unsigned int border;
!     unsigned int depth;
! 
      
!     /*
!      * Check out the attributes of the bitmap to insure that it is usable.
!      */
! 
!     if (!XGetGeometry (DISPLAY, iconBitmap, &root, &x, &y,
! 	     &bitmapWidth, &bitmapHeight, &border, &depth))
!     {
! 	Warning (((char *)GETMESSAGE(38, 1, "Invalid icon bitmap")));
! 	return ((Pixmap)NULL);
!     }
! 
!     if (ROOT_FOR_CLIENT(pCD) != root)
!     {
! 	/*
! 	 * The bitmap was not made with usable parameters.
! 	 */
! #ifdef WSM
! 	Warning (((char *)GETMESSAGE(38, 9, "Icon bitmap cannot be used on this screen")));
! #else /* WSM */
! 	Warning ("Invalid root for icon bitmap");
! #endif /* WSM */
! 	return ((Pixmap)NULL);
!     }
! 
! #ifdef DISALLOW_DEEP_ICONS
!     if (depth != 1)
!     {
! 	Warning (((char *)GETMESSAGE(38, 10, "Color icon pixmap not supported")));
! 	return ((Pixmap)NULL);
!     }
! #endif
! 
!     /*
!      * Color the bitmap, center it in a pixmap ....
!      */
! 
!     return (MakeIconPixmap (pCD, iconBitmap, (Pixmap)iconMask, 
! 	    bitmapWidth, bitmapHeight, depth));
! 
  
  } /* END OF FUNCTION MakeClientIconPixmap */
  
--- 120,155 ----
  	Pixmap iconBitmap, 
  	Pixmap iconMask)
  {
!   Window root;
!   int x;
!   int y;
!   unsigned int  bitmapWidth;
!   unsigned int  bitmapHeight;
!   unsigned int  border;
!   unsigned int  depth;
!   WmScreenData *pSD;
! 
!   if (pCD)
!     pSD = pCD->pSD;
!   else
!     pSD = wmGD.pActiveSD;
      
!   /*
!    * Get pixmap attributes and ensure that it is usable.
!    */
!    
!   if (!XGetGeometry (DISPLAY, iconBitmap, &root, &x, &y,
!       &bitmapWidth, &bitmapHeight, &border, &depth))
!   {
!     Warning (((char *)GETMESSAGE(38, 1, "Invalid icon pixmap")));
!     return ((Pixmap)NULL);
!   }
! 
!   /*
!    * Color the bitmap, center it in a pixmap ....
!    */
!   return (MakeIconPixmap (pCD, iconBitmap, iconMask, 
! 			  bitmapWidth, bitmapHeight, depth));
  
  } /* END OF FUNCTION MakeClientIconPixmap */
  
***************
*** 175,401 ****
  
  /*************************************<->*************************************
   *
!  *  MakeNamedIconPixmap (pCD, iconName)
   *
   *
   *  Description:
   *  -----------
!  *  This function makes an icon pixmap for a particular client given the
!  *  name of a bitmap file.
!  *
   *
   *  Inputs:
   *  ------
-  *  pCD      = (nonNULL) pointer to client data
   *  iconName = pointer to the icon name (bitmap file path name or NULL)
   *
   * 
   *  Outputs:
   *  -------
!  *  RETURN = icon pixmap or NULL
   * 
   *************************************<->***********************************/
  
! Pixmap MakeNamedIconPixmap (ClientData *pCD, String iconName)
  {
!     int          bitmapIndex;
! #ifdef WSM
!     Pixmap	pixmap, pixmap_r, mask;
!     Window	root;
!     int		x, y;
!     unsigned int	width, height, border_width, depth;
!     String	sIconFileName;
!     int		iconSizeDesired;
! #endif /* WSM */
  
      /*
!      * Get the bitmap cache entry (will read data from file if necessary).
!      * If unable to find the iconName file return NULL.
       */
! 
! #ifdef WSM
!     if ((bitmapIndex = GetBitmapIndex (PSD_FOR_CLIENT(pCD), iconName,
! 			False)) < 0)
! #else /* WSM */
!     if ((bitmapIndex = GetBitmapIndex (PSD_FOR_CLIENT(pCD), iconName)) < 0)
! #endif /* WSM */
!     {
! #ifdef WSM
!        if ((PSD_FOR_CLIENT(pCD)->displayResolutionType == LOW_RES_DISPLAY) ||
!            (PSD_FOR_CLIENT(pCD)->displayResolutionType == VGA_RES_DISPLAY))
!        {
!           iconSizeDesired = XmMEDIUM_ICON_SIZE;
!        }
!        else
!        {
!           iconSizeDesired = XmLARGE_ICON_SIZE;
!        }
! 
!        pixmap = XmUNSPECIFIED_PIXMAP;
! 
!        sIconFileName = XmGetIconFileName( 
! 			XtScreen(PSD_FOR_CLIENT(pCD)->screenTopLevelW1),
! 			NULL,
! 			iconName,
! 			NULL,
! 			iconSizeDesired);
! 
!        if (sIconFileName != NULL)
!        {
! 	   pixmap = XmGetPixmap (
! 			XtScreen (PSD_FOR_CLIENT(pCD)->screenTopLevelW1), 
! 			sIconFileName,
! 			pCD->iconImageForeground, 
! 			pCD->iconImageBackground);
!        }
! 
!        if (pixmap == XmUNSPECIFIED_PIXMAP)
!        {
! 	   pixmap = XmGetPixmap (
! 			XtScreen (PSD_FOR_CLIENT(pCD)->screenTopLevelW1), 
! 			iconName,
! 			pCD->iconImageForeground, 
! 			pCD->iconImageBackground);
!        }
! 
!        if (pixmap == XmUNSPECIFIED_PIXMAP)
!        {
!             MWarning (((char *)GETMESSAGE(38, 7, "Unable to read bitmap file %s\n")), iconName);
!        }
!        else
!        {
! 	   mask = _DtGetMask (XtScreen(PSD_FOR_CLIENT(pCD)->screenTopLevelW1), 
! 			(sIconFileName == NULL) ? iconName : sIconFileName);
! 	   if (mask == XmUNSPECIFIED_PIXMAP) 
! 	   {
! 	       mask = (Pixmap) NULL;
! 	   }
! 
! 	   if (sIconFileName != NULL)
! 	       XtFree(sIconFileName);
! 
! 	   /*
! 	    * We need to synchronize DISPLAY1 here because the pixmap and mask 
! 	    * were created on that display connection, and we must ensure that 
! 	    * the server has processed those requests before we attempt to use 
! 	    * the pixmap and mask on DISPLAY.  We thus assume that the 
! 	    * subsequent XGetGeometry() call is successful.
! 	    */
! 	   XSync(DISPLAY1, False);	
! 
! 	   (void) XGetGeometry (DISPLAY, pixmap, &root, &x, &y, &width,
! 		       &height, &border_width, &depth);
! 
! 	   pixmap_r = MakeIconPixmap (pCD, pixmap, mask,
! 				     width, height, depth);
! 
! 	   XmDestroyPixmap (XtScreen (PSD_FOR_CLIENT(pCD)->screenTopLevelW1), 
! 				pixmap);
! 	   if (mask)
! 	       XmDestroyPixmap (
! 		   XtScreen (PSD_FOR_CLIENT(pCD)->screenTopLevelW1), mask);
! 
! 	   return (pixmap_r);
!        }
! 
!        if (sIconFileName != NULL)
! 	   XtFree (sIconFileName);
! #endif /* WSM */
! 	return ((Pixmap)NULL);
!     }
  
      /*
!      * Color the bitmap, center it in a pixmap ....
       */
! 
!     return (MakeCachedIconPixmap (pCD, bitmapIndex, (Pixmap)NULL));
! 
! } /* END OF FUNCTION MakeNamedIconPixmap */
! 
  
  
  
  /*************************************<->*************************************
   *
!  *  Pixmap
!  *  MakeCachedIconPixmap (pCD, bitmapIndex, mask)
   *
   *
   *  Description:
   *  -----------
!  *  Convert the cached bitmap and mask into an icon pixmap.
   *
   *
   *  Inputs:
   *  ------
!  *  pCD		- (nonNULL) pointer to client data (icon colors and tiles)
!  *  bitmapIndex	- bitmap cache index of image to be converted
!  *  mask	- bitmap mask, 1 for bits of "bitmap" to be kept
   *
   * 
   *  Outputs:
   *  -------
!  *  RETURN 	- icon pixmap or NULL
!  *
!  *
!  *  Comments:
!  *  --------
!  *  o "mask" is not used.
   * 
   *************************************<->***********************************/
- Pixmap MakeCachedIconPixmap (ClientData *pCD, int bitmapIndex, Pixmap mask)
- {
-     BitmapCache  *bitmapc;
-     PixmapCache  *pixmapc;
-     Pixmap        pixmap = (Pixmap)NULL;
-     WmScreenData *pSD = PSD_FOR_CLIENT(pCD);
  
!     if (bitmapIndex < 0)
!     {
! 	return ((Pixmap)NULL);
!     }
!     bitmapc = &(pSD->bitmapCache[bitmapIndex]);
! 
!     /*
!      * Search for an icon pixmap matching the client icon colors.
!      */
! 
!     pixmapc = bitmapc->pixmapCache;
!     while (pixmapc)
!     {
!         if ((pixmapc->pixmapType == ICON_PIXMAP) &&
! 	    (pixmapc->foreground == pCD->iconImageForeground) &&
! 	    (pixmapc->background == pCD->iconImageBackground))
!         {
! 	    pixmap = pixmapc->pixmap;
! 	    break;
!         }
! 	pixmapc = pixmapc->next;
!     }
! 
!     /* 
!      * If a matching pixmap was not found in the pixmap cache for this bitmap
!      *   then create the icon pixmap with the appropriate colors.
!      * If have sufficient memory, save the pixmap info in the pixmapCache.
!      */
  
!     if (!pixmap &&
!         (pixmap = MakeIconPixmap (pCD, bitmapc->bitmap, mask,
! 				     bitmapc->width, bitmapc->height, 1)) &&
! 	(pixmapc = (PixmapCache *) XtMalloc (sizeof (PixmapCache))))
      {
! 
!         pixmapc->pixmapType = ICON_PIXMAP;
! 	pixmapc->foreground = pCD->iconImageForeground;
! 	pixmapc->background = pCD->iconImageBackground;
! 	pixmapc->pixmap = pixmap;
! 	pixmapc->next = bitmapc->pixmapCache;
! 	bitmapc->pixmapCache = pixmapc;
      }
  
!     return (pixmap);
  
! } /* END OF FUNCTION MakeCachedIconPixmap */
  
  
  
--- 157,293 ----
  
  /*************************************<->*************************************
   *
!  *  GetNamedPixmap (pCD, iconName)
   *
   *
   *  Description:
   *  -----------
!  *  This function gets the named pixmap.  bitmapDirectory is searched first
!  *  then, if not set, /usr/lib/X11/bitmaps is searched.  Finally, if that
!  *  also fails, XMBLANGPATH is used.
   *
   *  Inputs:
   *  ------
   *  iconName = pointer to the icon name (bitmap file path name or NULL)
   *
   * 
   *  Outputs:
   *  -------
!  *  RETURN = icon pixmap or XmUNSPECIFIED_PIXMAP
   * 
   *************************************<->***********************************/
  
! Pixmap GetNamedPixmap (Screen *scr, String iconName,
! 		       Pixel fg, Pixel bg, int depth)
  {
!   Pixmap       pixmap = XmUNSPECIFIED_PIXMAP;
  
+ 
+   if (iconName) {
      /*
!      * If name is not absolute, then try the bitmapDirectory location.
!      * Note that bitmapDirectory defaults to "/usr/lib/X11/bitmaps" if
!      * not set.  The user could have set bitmapDirectory to "" though.
!      */
!     if ((iconName[0] != '/') && (wmGD.bitmapDirectory))
!       {
! 	char *fullPathName;
! 	
! 	
! 	fullPathName = (char*) XtMalloc(strlen(wmGD.bitmapDirectory) +
! 					strlen(iconName) + 2);
! 	sprintf(fullPathName, "%s/%s", wmGD.bitmapDirectory, iconName);
! 	
! 	pixmap = XmGetPixmapByDepth(scr, fullPathName, fg, bg, depth);
! 	
! 	XtFree(fullPathName);
!       }
!     
!     /*
!      * If failed to get pixmap with bitmapDirectory, try
!      * using XBMLANGPATH.
       */
!     if (!PIXMAP_IS_VALID( pixmap ))
!       pixmap = XmGetPixmapByDepth(scr, iconName, fg, bg, depth);
  
      /*
!      * Warning message handling on error left to the calling routine.
       */
!   }
!   
!   return (pixmap);
! }
  
  
  
  /*************************************<->*************************************
   *
!  *  MakeNamedIconPixmap (pCD, iconName)
   *
   *
   *  Description:
   *  -----------
!  *  This function makes an icon pixmap for a particular client given the
!  *  name of a bitmap file.
   *
   *
   *  Inputs:
   *  ------
!  *  pCD      = (nonNULL) pointer to client data
!  *  iconName = pointer to the icon name (bitmap file path name or NULL)
   *
   * 
   *  Outputs:
   *  -------
!  *  RETURN = icon pixmap or NULL
   * 
   *************************************<->***********************************/
  
! Pixmap MakeNamedIconPixmap (ClientData *pCD, String iconName)
! {
!   Pixmap pixmap;
!   unsigned int width, height;
!   int depth;
! 
! 
!   if (iconName)
!     {
!       pixmap = GetNamedPixmap (ScreenOfDisplay(DISPLAY, pCD->pSD->screen),
! 			       iconName,
! 			       pCD->iconImageForeground,
! 			       pCD->iconImageBackground, 
! 			       DefaultDepth(DISPLAY, pCD->pSD->screen));
!       
!       if (!PIXMAP_IS_VALID( pixmap ))
! 	{
! 	  Warning (((char *)GETMESSAGE(38, 1, "Invalid icon pixmap")));
! 	}
!       else
! 	{
! 	  XmeGetPixmapData(ScreenOfDisplay(DISPLAY, pCD->pSD->screen), pixmap,
! 			   NULL, &depth, NULL, NULL, NULL, NULL,
! 			   &width, &height);
!       
! 	  pixmap = MakeIconPixmap (pCD, pixmap, XmUNSPECIFIED_PIXMAP,
! 				   width, height, depth);
! 	}
!     }
! 
!   /*
!    * If no name was given or we couldn't find the specified pixmap,
!    * then use the default.
!    */
  
!   if (!iconName || (!PIXMAP_IS_VALID( pixmap )))
      {
!       pixmap = MakeIconPixmap (pCD, pCD->pSD->builtinIconPixmap, XmUNSPECIFIED_PIXMAP,
! 			       iImage_width, iImage_height, 1);
      }
+   
  
!   return (pixmap);
  
! } /* END OF FUNCTION MakeNamedIconPixmap */
  
  
  
*** motif.orig/clients/mwm/WmInitWs.c	Tue May  2 11:53:42 2000
--- motif/clients/mwm/WmInitWs.c	Thu Jun  8 19:58:47 2000
***************
*** 71,76 ****
--- 71,77 ----
  #include <X11/Shell.h>
  #include <X11/Core.h>
  #include <X11/keysym.h>
+ #include <Xm/AtomMgr.h>
  #ifndef NO_HP_KEY_REMAP
  #include <Xm/VirtKeysP.h>
  
*** motif.orig/clients/mwm/WmMain.c	Tue May  2 11:53:42 2000
--- motif/clients/mwm/WmMain.c	Sat Jun  3 19:09:29 2000
***************
*** 50,58 ****
  
  #include "WmGlobal.h"
  
! #ifndef NO_MULTIBYTE
! #include <locale.h>
! #endif
  #ifdef WSM
  #include <Dt/Message.h>
  #include <Dt/EnvControlP.h>
--- 50,56 ----
  
  #include "WmGlobal.h"
  
! #include <X11/Xlocale.h>
  #ifdef WSM
  #include <Dt/Message.h>
  #include <Dt/EnvControlP.h>
*** motif.orig/clients/mwm/WmManage.c	Tue May  2 11:53:42 2000
--- motif/clients/mwm/WmManage.c	Sat Jun  3 19:37:44 2000
***************
*** 1202,1208 ****
       * Free the icon associated with the client window:
       */
  
!     if ((pCD->iconFlags & ICON_HINTS_PIXMAP) && pCD->iconPixmap)
      {
  	XFreePixmap (DISPLAY, pCD->iconPixmap);
      }
--- 1202,1208 ----
       * Free the icon associated with the client window:
       */
  
!     if (PIXMAP_IS_VALID( pCD->iconPixmap )) 
      {
  	XFreePixmap (DISPLAY, pCD->iconPixmap);
      }
*** motif.orig/clients/mwm/WmMenu.c	Tue May  2 11:53:42 2000
--- motif/clients/mwm/WmMenu.c	Thu Jun  8 17:43:20 2000
***************
*** 60,65 ****
--- 60,66 ----
  # include "WmDebug.h"
  #endif /* !defined(WSM) || defined(MWM_QATS_PROTOCOL) */
  #include <stdio.h>
+ #include <ctype.h>
  
  #include <X11/Shell.h>
  
***************
*** 4459,4465 ****
      KeySpec     *accelKeySpec;
      KeySpec     *nextAccelKeySpec;
  
!     if ((menuSpec == NULL) || (menuSpec->name != NULL))
      /* we only destroy custom menus! */
      {
  	return;
--- 4460,4469 ----
      KeySpec     *accelKeySpec;
      KeySpec     *nextAccelKeySpec;
  
!     /* Fix memory leak: use menuSpec->clientLocal to identify
!        custom menus instead of menuSpec->name */
! 
!     if ((menuSpec == NULL) || (menuSpec->clientLocal == FALSE))
      /* we only destroy custom menus! */
      {
  	return;
***************
*** 4477,4482 ****
--- 4481,4489 ----
       * End fix for CR 5450
       */
   
+     if (menuSpec->name != NULL)
+         XtFree(menuSpec->name);
+ 
      menuItem = menuSpec->menuItems;
      while (menuItem)
      {
*** motif.orig/clients/mwm/WmProtocol.c	Tue May  2 11:53:42 2000
--- motif/clients/mwm/WmProtocol.c	Sat Jun  3 19:08:31 2000
***************
*** 72,77 ****
--- 72,79 ----
  # include "WmDebug.h"
  #endif /* !defined(WSM) || defined(MWM_QATS_PROTOCOL) */
  
+ #include <Xm/TransferP.h>
+ 
  /*
   * Function Declarations:
   */
*** motif.orig/clients/mwm/WmResource.c	Tue May  2 11:53:42 2000
--- motif/clients/mwm/WmResource.c	Sat Jun  3 19:11:13 2000
***************
*** 215,221 ****
      gotItAll = True;
      if(gotItAll)
      {
! #ifdef sun
          tmpString = ((char *)GETMESSAGE(62, 60, "Restore _R  Alt<Key>F5 f.restore"));
  #else
          tmpString = ((char *)GETMESSAGE(62, 49, "Restore _R  f.restore"));
--- 215,221 ----
      gotItAll = True;
      if(gotItAll)
      {
! #if 1
          tmpString = ((char *)GETMESSAGE(62, 60, "Restore _R  Alt<Key>F5 f.restore"));
  #else
          tmpString = ((char *)GETMESSAGE(62, 49, "Restore _R  f.restore"));
***************
*** 233,239 ****
      }
      if(gotItAll)
      {
! #ifdef sun
          tmpString = ((char *)GETMESSAGE(62, 61, "Move _M  Alt<Key>F7 f.move"));
  #else
          tmpString = ((char *)GETMESSAGE(62, 50, "Move _M  f.move"));
--- 233,239 ----
      }
      if(gotItAll)
      {
! #if 1
          tmpString = ((char *)GETMESSAGE(62, 61, "Move _M  Alt<Key>F7 f.move"));
  #else
          tmpString = ((char *)GETMESSAGE(62, 50, "Move _M  f.move"));
***************
*** 251,257 ****
      }
      if(gotItAll)
      {
! #ifdef sun
          tmpString = ((char *)GETMESSAGE(62, 62, "Size _S  Alt<Key>F8 f.resize"));
  #else
          tmpString = ((char *)GETMESSAGE(62, 51, "Size _S  f.resize"));
--- 251,257 ----
      }
      if(gotItAll)
      {
! #if 1
          tmpString = ((char *)GETMESSAGE(62, 62, "Size _S  Alt<Key>F8 f.resize"));
  #else
          tmpString = ((char *)GETMESSAGE(62, 51, "Size _S  f.resize"));
***************
*** 269,275 ****
      }
      if(gotItAll)
      {
! #ifdef sun
          tmpString = ((char *)GETMESSAGE(62, 63, "Minimize _n  Alt<Key>F9 f.minimize"));
  #else
          tmpString = ((char *)GETMESSAGE(62, 52, "Minimize _n  f.minimize"));
--- 269,275 ----
      }
      if(gotItAll)
      {
! #if 1
          tmpString = ((char *)GETMESSAGE(62, 63, "Minimize _n  Alt<Key>F9 f.minimize"));
  #else
          tmpString = ((char *)GETMESSAGE(62, 52, "Minimize _n  f.minimize"));
***************
*** 287,293 ****
      }
      if(gotItAll)
      {
! #ifdef sun
  	tmpString = ((char *)GETMESSAGE(62, 64, "Maximize _x  Alt<Key>F10 f.maximize"));
  #else
  	tmpString = ((char *)GETMESSAGE(62, 53, "Maximize _x  f.maximize"));
--- 287,293 ----
      }
      if(gotItAll)
      {
! #if 1
  	tmpString = ((char *)GETMESSAGE(62, 64, "Maximize _x  Alt<Key>F10 f.maximize"));
  #else
  	tmpString = ((char *)GETMESSAGE(62, 53, "Maximize _x  f.maximize"));
***************
*** 305,311 ****
      }
      if(gotItAll)
      {
! #ifdef sun
          tmpString = ((char *)GETMESSAGE(62, 65, "Lower _L  Alt<Key>F3 f.lower"));
  #else
          tmpString = ((char *)GETMESSAGE(62, 54, "Lower _L  f.lower"));
--- 305,311 ----
      }
      if(gotItAll)
      {
! #if 1
          tmpString = ((char *)GETMESSAGE(62, 65, "Lower _L  Alt<Key>F3 f.lower"));
  #else
          tmpString = ((char *)GETMESSAGE(62, 54, "Lower _L  f.lower"));
*** motif.orig/clients/mwm/WmResParse.c	Tue May  2 11:53:42 2000
--- motif/clients/mwm/WmResParse.c	Sun Jun  4 16:53:38 2000
***************
*** 77,83 ****
  #include <X11/Xatom.h>
  #include <ctype.h>
  
! #include <locale.h>
  
  #ifndef NO_MULTIBYTE
  #include <stdlib.h>
--- 77,83 ----
  #include <X11/Xatom.h>
  #include <ctype.h>
  
! #include <X11/Xlocale.h>
  
  #ifndef NO_MULTIBYTE
  #include <stdlib.h>
***************
*** 101,106 ****
--- 101,109 ----
  #define MAX_CONTEXT_STRLEN    20
  #define MAX_GROUP_STRLEN      20
  
+ #ifdef min
+ #undef min
+ #endif
  #define min(a,b)	((a)>(b) ? (b) : (a))
  
  #define MAXLINE     (MAXWMPATH+1)
***************
*** 2667,2672 ****
--- 2670,2676 ----
  #if ((!defined(WSM)) || defined(MWM_QATS_PROTOCOL))
      menuSpec->exclusions = NULL;
      menuSpec->clientLocal = FALSE;
+     menuSpec->commandID = 0;
  #endif /* !defined(WSM) || defined(MWM_QATS_PROTOCOL) */
      menuSpec->nextMenuSpec = NULL;
  
***************
*** 2922,2928 ****
  
  	if (!ParseWmAccelerator (&lineP, menuItem))
  	{
! 	    XtFree ((char *)menuItem);
  	    continue;
  	}
  	/*
--- 2926,2932 ----
  
  	if (!ParseWmAccelerator (&lineP, menuItem))
  	{
! 	    FreeMenuItem (menuItem);
  	    continue;
  	}
  	/*
***************
*** 3133,3139 ****
  
  Boolean IsClientCommand (String string)
  {
!     if ((mblen ((char *)string, MB_CUR_MAX) == 1 && *string == '<') ||
  	(strncmp(string, "-><", 3) == 0) ||
  	(strncmp(string, "=<", 2) == 0)  ||
  	(strncmp(string, "=><", 3) == 0) ||
--- 3137,3147 ----
  
  Boolean IsClientCommand (String string)
  {
!     if ((
! #ifndef NO_MULTIBYTE
! 	 mblen ((char *)string, MB_CUR_MAX) == 1 &&
! #endif
! 	 *string == '<') ||
  	(strncmp(string, "-><", 3) == 0) ||
  	(strncmp(string, "=<", 2) == 0)  ||
  	(strncmp(string, "=><", 3) == 0) ||
***************
*** 3243,3252 ****
--- 3251,3262 ----
  	token = PRS_NO_STATE;
  	while (token == PRS_NO_STATE)
  	{
+ #ifndef NO_MULTIBYTE
  	    if (mblen ((char *)stream, MB_CUR_MAX) > 1) {
  	      token = PRS_ERROR;
  	      continue;
  	    }
+ #endif
  
  	    switch (*stream)
  	    {
***************
*** 3259,3268 ****
--- 3269,3280 ----
  	      case '-':
  		/* This should be a cascade-force modifier */
  		++stream;
+ #ifndef NO_MULTIBYTE
  		if (mblen ((char *)stream, MB_CUR_MAX) > 1) {
  		  token = PRS_ERROR;
  		  continue;
  		}
+ #endif
  		if (*stream == '>')
  		{
  		    ++stream; token = PRS_MODIFIER;
***************
*** 3274,3283 ****
--- 3286,3297 ----
  		   a combination separators and cascade-force
  		   modifier */
  		++stream;
+ #ifndef NO_MULTIBYTE
  		if (mblen ((char *)stream, MB_CUR_MAX) > 1) {
  		  token = PRS_ERROR;
  		  continue;
  		}
+ #endif
  		if (*stream == '>') ++stream;
  		token = PRS_MODIFIER;
  		*use_separators = TRUE;
***************
*** 3296,3339 ****
  
  		/* This should be the beginning of a reference. First
  		   skip any leading whitespace. */
  		if (mblen ((char *)stream, MB_CUR_MAX) > 1) {
  		  token = PRS_ERROR;
  		  continue;
  		}
! 		while (mblen ((char *)stream, MB_CUR_MAX) == 1 && 
  		       (*stream == ' ' || *stream == '\t')) 
  		  ++stream;
  
  		if (mblen ((char *)stream, MB_CUR_MAX) > 1) {
  		  token = PRS_ERROR;
  		  continue;
  		}
  		/* Now check for a reference name wild card or a
  		   full reference name */
  		if (*stream == '*')
  		  ++stream;
  		else
  		{
! 		    while (mblen ((char *)stream, MB_CUR_MAX) == 1 && 
  			   (isalnum(*stream) || *stream == ' ' ||
  			    *stream == '\t'  || *stream == '_' ))
  		      ++stream;
  		}
  		
  		if (mblen ((char *)stream, MB_CUR_MAX) > 1) {
  		  token = PRS_ERROR;
  		  continue;
  		}
  
  		/* Now skip past any trailing white space */
! 		while (mblen ((char *)stream, MB_CUR_MAX) == 1 && 
  		       (*stream == ' ' || *stream == '\t'))
  		  ++stream;
  
  		if (mblen ((char *)stream, MB_CUR_MAX) > 1) {
  		  token = PRS_ERROR;
  		  continue;
  		}
  		/* At this point, we should be looking at the close
  		   of the reference */
  		if (*stream == '>')
--- 3310,3370 ----
  
  		/* This should be the beginning of a reference. First
  		   skip any leading whitespace. */
+ #ifndef NO_MULTIBYTE
  		if (mblen ((char *)stream, MB_CUR_MAX) > 1) {
  		  token = PRS_ERROR;
  		  continue;
  		}
! #endif
! 		while (
! #ifndef NO_MULTIBYTE
! 		       mblen ((char *)stream, MB_CUR_MAX) == 1 &&
! #endif
  		       (*stream == ' ' || *stream == '\t')) 
  		  ++stream;
  
+ #ifndef NO_MULTIBYTE
  		if (mblen ((char *)stream, MB_CUR_MAX) > 1) {
  		  token = PRS_ERROR;
  		  continue;
  		}
+ #endif
  		/* Now check for a reference name wild card or a
  		   full reference name */
  		if (*stream == '*')
  		  ++stream;
  		else
  		{
! 		    while (
! #ifndef NO_MULTIBYTE
! 			   mblen ((char *)stream, MB_CUR_MAX) == 1 &&
! #endif
  			   (isalnum(*stream) || *stream == ' ' ||
  			    *stream == '\t'  || *stream == '_' ))
  		      ++stream;
  		}
  		
+ #ifndef NO_MULTIBYTE
  		if (mblen ((char *)stream, MB_CUR_MAX) > 1) {
  		  token = PRS_ERROR;
  		  continue;
  		}
+ #endif
  
  		/* Now skip past any trailing white space */
! 		while (
! #ifndef NO_MULTIBYTE
! 		       mblen ((char *)stream, MB_CUR_MAX) == 1 &&
! #endif
  		       (*stream == ' ' || *stream == '\t'))
  		  ++stream;
  
+ #ifndef NO_MULTIBYTE
  		if (mblen ((char *)stream, MB_CUR_MAX) > 1) {
  		  token = PRS_ERROR;
  		  continue;
  		}
+ #endif
  		/* At this point, we should be looking at the close
  		   of the reference */
  		if (*stream == '>')
***************
*** 3734,3747 ****
  static void ParseMenuItemName (unsigned char **linePP, MenuItem *menuItem)
  {
      unsigned char *lineP, *endquote;
      int chlen;
  
      /* Skip past any whitespace */
      ScanWhitespace (linePP);
      lineP = *linePP;
  
      /* Look for a double quote */
!     if (mblen ((char *)lineP, MB_CUR_MAX) == 1 && *lineP == '"')
      {
  	/* Move past the first quote. */
  	++lineP;
--- 3765,3784 ----
  static void ParseMenuItemName (unsigned char **linePP, MenuItem *menuItem)
  {
      unsigned char *lineP, *endquote;
+ #ifndef NO_MULTIBYTE
      int chlen;
+ #endif
  
      /* Skip past any whitespace */
      ScanWhitespace (linePP);
      lineP = *linePP;
  
      /* Look for a double quote */
!     if (
! #ifndef NO_MULTIBYTE
! 	mblen ((char *)lineP, MB_CUR_MAX) == 1 &&
! #endif
! 	*lineP == '"')
      {
  	/* Move past the first quote. */
  	++lineP;
***************
*** 3749,3754 ****
--- 3786,3792 ----
  	endquote = lineP;
  
  	/* Search for closing quote */
+ #ifndef NO_MULTIBYTE
  	while (*endquote != '\0' &&
  	       (chlen = mblen ((char *)endquote, MB_CUR_MAX)) > 0 && 
  	       (chlen > 1 || *endquote != '"'))
***************
*** 3759,3764 ****
--- 3797,3808 ----
  	    endquote += chlen;
  	}
  	if (chlen < 0) return; /* invalid character */
+ #else
+ 	while (*endquote != '\0' && *endquote != '"') {
+ 	  if (*endquote == '\n' || *endquote == '\0') return;
+ 	  endquote++;
+ 	}
+ #endif
  
  	/* Well, we have a valid menu item name. Store it in the 
  	   client command name field. Don't include the double quotes. */
***************
*** 3772,3781 ****
--- 3816,3830 ----
      {
  	/* If there was no double quote, then just advance to the end
  	   of the line. */
+ #ifndef NO_MULTIBYTE
  	while (*lineP != '\0' && 
  	       ((chlen = mblen ((char *)lineP, MB_CUR_MAX)) > 1 ||
  		*lineP != '\n'))
  	  lineP += chlen > 0 ? chlen : 1;
+ #else
+ 	while (*lineP != '\0' && *lineP != '\n')
+ 	  lineP++;
+ #endif
  	*linePP = lineP;
      }
  }
***************
*** 4176,4181 ****
--- 4225,4235 ----
  	XtFree ((char *)menuItem->wmFuncArgs);
      }
  
+     if (menuItem->clientCommandName != NULL)
+     {
+ 	XtFree ((char *) menuItem->clientCommandName);
+     }
+ 
      XtFree ((char *)menuItem);
  
  } /* END OF FUNCTION FreeMenuItem */
***************
*** 8151,8158 ****
  		host_part = NULL;
  	    }
  
! 	    if ((mblen(file_part, MB_CUR_MAX) == 1) && 
  		(mblen(file_part+1, MB_CUR_MAX) == 1) &&
  		(*file_part == '~') &&
  		(*(file_part+1) == '/'))
  	    {
--- 8205,8215 ----
  		host_part = NULL;
  	    }
  
! 	    if (
! #ifndef NO_MULTIBYTE
! 	        (mblen(file_part, MB_CUR_MAX) == 1) && 
  		(mblen(file_part+1, MB_CUR_MAX) == 1) &&
+ #endif
  		(*file_part == '~') &&
  		(*(file_part+1) == '/'))
  	    {
***************
*** 8211,8218 ****
  
      if (sReturn == NULL)
      {
! 	if ((mblen(pchFile, MB_CUR_MAX) == 1) && 
  	    (mblen(pchFile+1, MB_CUR_MAX) == 1) &&
  	    (*pchFile == '~') &&
  	    (*(pchFile+1) == '/'))
  	{
--- 8268,8278 ----
  
      if (sReturn == NULL)
      {
! 	if (
! #ifndef NO_MULTIBYTE
! 	    (mblen(pchFile, MB_CUR_MAX) == 1) && 
  	    (mblen(pchFile+1, MB_CUR_MAX) == 1) &&
+ #endif
  	    (*pchFile == '~') &&
  	    (*(pchFile+1) == '/'))
  	{
***************
*** 8321,8327 ****
      item->labelBitmapIndex = -1;
      item->mnemonic = (KeySym) 0;
      item->accelState = 0;
!     item->accelKeyCode = (KeyCode) NULL;
      item->accelText = (String) NULL;
      item->wmFunction = (WmFunction) F_Separator;
      item->wmFuncArgs = (String) NULL;
--- 8381,8387 ----
      item->labelBitmapIndex = -1;
      item->mnemonic = (KeySym) 0;
      item->accelState = 0;
!     item->accelKeyCode = (KeyCode) 0;
      item->accelText = (String) NULL;
      item->wmFunction = (WmFunction) F_Separator;
      item->wmFuncArgs = (String) NULL;
*** motif.orig/clients/mwm/WmSignal.c	Tue May  2 11:53:42 2000
--- motif/clients/mwm/WmSignal.c	Sat Jun  3 19:36:30 2000
***************
*** 49,54 ****
--- 49,56 ----
   */
  
  #include "WmGlobal.h" /* This should be the first include */
+ #include <sys/types.h>
+ #include <sys/wait.h>
  #include <signal.h>
  
  
***************
*** 248,253 ****
--- 250,257 ----
      signal (SIGQUIT, QuitWmSignalHandler);
  
      signal (SIGTERM, QuitWmSignalHandler);
+ 
+     signal (SIGCHLD, ChildProcSignalHandler);
  #endif /* WSM */
  
  
***************
*** 279,281 ****
--- 283,321 ----
      }
  
  } /* END OF FUNCTION QuitWmSignalHandler */
+ 
+ 
+ /*************************************<->*************************************
+  *
+  *  ChildProcSignalHandler ()
+  *
+  *
+  *  Description:
+  *  -----------
+  *  This function is called on receipt of a signal that the child of the 
+  *  window manager has terminated.
+  *  This child signal handler is primarily used to wait() for child
+  *  processes that were inherited from the user's .xsession if the last
+  *  command in the .xsession is a "exec mwm".  These inherited child
+  *  processes were not spawned the WmFunction.c:F_Exec() routine and
+  *  therefore would not be reaped by the wait() in that routine until
+  *  a menu item using F_Exec() was invoked by the user.
+  *
+  *************************************<->***********************************/
+ 
+ void ChildProcSignalHandler (int dummy)
+ {
+    pid_t pid;
+    int status;
+    void (*intStat) ();
+    void (*quitStat) ();
+    
+    intStat = (void (*)())signal (SIGINT, SIG_IGN);
+    quitStat = (void (*)())signal (SIGQUIT, SIG_IGN);
+ 
+    pid = wait(&status);
+    signal(SIGCHLD, ChildProcSignalHandler); 
+ 
+    signal (SIGINT, intStat);
+    signal (SIGQUIT, quitStat);
+ }
*** motif.orig/clients/mwm/WmSignal.h	Tue May  2 11:53:42 2000
--- motif/clients/mwm/WmSignal.h	Sat Jun  3 19:36:30 2000
***************
*** 43,45 ****
--- 43,47 ----
  extern void SetupWmSignalHandlers (int);
  extern void QuitWmSignalHandler (int);
  extern void RestoreDefaultSignalHandlers (void);
+ extern void ChildProcSignalHandler (int);
+ 
*** motif.orig/clients/mwm/WmWinInfo.c	Tue May  2 11:53:42 2000
--- motif/clients/mwm/WmWinInfo.c	Sun Jun  4 16:53:38 2000
***************
*** 57,63 ****
  #include "WmIBitmap.h"
  
  #include <Xm/Xm.h>
! #include <locale.h>
  #ifdef PANELIST
  #include "WmPanelP.h"
  #endif /* PANELIST */
--- 57,63 ----
  #include "WmIBitmap.h"
  
  #include <Xm/Xm.h>
! #include <X11/Xlocale.h>
  #ifdef PANELIST
  #include "WmPanelP.h"
  #endif /* PANELIST */
*** motif.orig/clients/uil/Imakefile	Wed May  3 05:12:34 2000
--- motif/clients/uil/Imakefile	Wed May 10 13:43:34 2000
***************
*** 73,80 ****
  		UilSymNam.o	UilSymStor.o	UilData.o \
  		UilLstMac.o	UilSemVal.o	UilSemCSet.o	UilDB.o
  
  OBJS =		$(COMMON_OBJ)	UilParser.o
- OBJS2 =		$(COMMON_OBJ)	UilMain.o
  
  HEADERS = 	Uil.h		UilSymGl.h	UilDBDef.h	UilSymDef.h \
  		UilDef.h	XmAppl.uil
--- 73,96 ----
  		UilSymNam.o	UilSymStor.o	UilData.o \
  		UilLstMac.o	UilSemVal.o	UilSemCSet.o	UilDB.o
  
+ #if DoSharedLib && DoNormalLib
+ NORMAL_OBJ =	unshared/UilCmd.o	unshared/UilDiags.o \
+ 	unshared/UilKeyTab.o	unshared/UilLexAna.o	unshared/UilLexPars.o \
+ 	unshared/UilLstLst.o	unshared/UilP2Out.o	unshared/UilP2Reslv.o \
+ 	unshared/UilSarComp.o	unshared/UilSarExp.o	unshared/UilSarInc.o \
+ 	unshared/UilSarMod.o	unshared/UilSarObj.o	unshared/UilSarProc.o \
+ 	unshared/UilSarVal.o	unshared/UilSrcSrc.o	unshared/UilSymNam.o \
+ 	unshared/UilSymStor.o	unshared/UilData.o	unshared/UilLstMac.o \
+ 	unshared/UilSemVal.o	unshared/UilSemCSet.o	unshared/UilDB.o
+ 
+ OBJS2 =	$(NORMAL_OBJ)	unshared/UilMain.o
+ 
+ unshared/UilMain.o: UilMain.o
+ #else
+ OBJS2 =	$(COMMON_OBJ)	UilMain.o
+ #endif
+ 
  OBJS =		$(COMMON_OBJ)	UilParser.o
  
  HEADERS = 	Uil.h		UilSymGl.h	UilDBDef.h	UilSymDef.h \
  		UilDef.h	XmAppl.uil
***************
*** 92,97 ****
--- 108,115 ----
  LinkFile(UilParser.c,UilMain.c)
  SpecialLibObjectRule(UilParser.o,NullParameter,-DCALLABLE)
  
+ clean::
+ 	$(RM) $(PROGRAMS)
  
  DependTarget3($(COMMON_SRC),UilMain.c,UilParser.c)
  
*** motif.orig/clients/uil/UilLexAna.c	Wed May  3 05:12:34 2000
--- motif/clients/uil/UilLexAna.c	Sat Jun  3 18:58:05 2000
***************
*** 77,83 ****
--- 77,87 ----
  #include "UilDefI.h"
  #include <ctype.h>
  
+ #ifndef X_NOT_STDC_ENV
+ #include <stdlib.h>
+ #else
  double atof();
+ #endif
  
  #include <errno.h>	/* needed to support conversion functions */
  #ifdef X_NOT_STDC_ENV
*** motif.orig/clients/uil/UilLstLst.c	Wed May  3 05:12:34 2000
--- motif/clients/uil/UilLstLst.c	Sat Jun  3 18:59:39 2000
***************
*** 750,756 ****
  		sprintf ((char *)hex_longword, "%lX", (* code_ptr));
  	      }
  	      else{
!                 sprintf ((char *)hex_longword, "%08X", (* code_ptr));
  	      }
  
  		_move (& buffer [start_hex_long [j]],
--- 750,756 ----
  		sprintf ((char *)hex_longword, "%lX", (* code_ptr));
  	      }
  	      else{
!                 sprintf ((char *)hex_longword, "%08lX", (* code_ptr));
  	      }
  
  		_move (& buffer [start_hex_long [j]],
***************
*** 802,808 ****
  		      sprintf ((char *)hex_longword, "%lX", (* code_ptr));
  		    }
  		    else{
! 		      sprintf ((char *)hex_longword, "%08X", (*code_ptr));
  		    }
  
  		    _move (& buffer [start_hex_long [i]],
--- 802,808 ----
  		      sprintf ((char *)hex_longword, "%lX", (* code_ptr));
  		    }
  		    else{
! 		      sprintf ((char *)hex_longword, "%08lX", (*code_ptr));
  		    }
  
  		    _move (& buffer [start_hex_long [i]],
*** motif.orig/clients/uil/UilLstMac.c	Wed May  3 05:12:34 2000
--- motif/clients/uil/UilLstMac.c	Sat Jun  3 19:00:27 2000
***************
*** 210,216 ****
      az_src_rec = widget_entry->header.az_src_rec;
  
      if (widget_entry->resource_id != 0 ) {
! 	sprintf (buffer, "Resource ID: %08X", widget_entry->resource_id);
  	src_append_machine_code (
  		az_src_rec,
  		0,
--- 210,216 ----
      az_src_rec = widget_entry->header.az_src_rec;
  
      if (widget_entry->resource_id != 0 ) {
! 	sprintf (buffer, "Resource ID: %08lX", widget_entry->resource_id);
  	src_append_machine_code (
  		az_src_rec,
  		0,
***************
*** 926,932 ****
      az_src_rec = value_entry->header.az_src_rec;
  
      if (value_entry->resource_id != 0) {
! 	sprintf (buffer, "Resource ID: %08X", value_entry->resource_id);
  	src_append_machine_code (
  		az_src_rec,
  		0,
--- 926,932 ----
      az_src_rec = value_entry->header.az_src_rec;
  
      if (value_entry->resource_id != 0) {
! 	sprintf (buffer, "Resource ID: %08lX", value_entry->resource_id);
  	src_append_machine_code (
  		az_src_rec,
  		0,
***************
*** 982,988 ****
  	case sym_k_horizontal_integer_value:
  	case sym_k_vertical_integer_value:
  
! 	    sprintf (buffer, "value: %d",
  		     (* (unsigned long *) rc_buffer) );
  	    src_append_machine_code (
  		az_src_rec, 0, rc_size, rc_buffer, buffer );
--- 982,988 ----
  	case sym_k_horizontal_integer_value:
  	case sym_k_vertical_integer_value:
  
! 	    sprintf (buffer, "value: %ld",
  		     (* (unsigned long *) rc_buffer) );
  	    src_append_machine_code (
  		az_src_rec, 0, rc_size, rc_buffer, buffer );
***************
*** 996,1002 ****
  
  	    for (offset = 0; offset < (int)rc_size; offset += sizeof(int), index++)
  		{
! 		sprintf (buffer, "value[%d]: %d",
  			 index, ((unsigned long *) rc_buffer)[index] );
  		
  		src_append_machine_code
--- 996,1002 ----
  
  	    for (offset = 0; offset < (int)rc_size; offset += sizeof(int), index++)
  		{
! 		sprintf (buffer, "value[%d]: %ld",
  			 index, ((unsigned long *) rc_buffer)[index] );
  		
  		src_append_machine_code
*** motif.orig/clients/uil/UilMain.c	Wed May  3 05:12:34 2000
--- motif/clients/uil/UilMain.c	Sat Jun  3 19:03:10 2000
***************
*** 349,354 ****
--- 349,355 ----
  
      common_main();
  
+     return 0;    /* make compiler happy */
  }
  #endif /* !CALLABLE */
  
*** motif.orig/clients/uil/UilSymStor.c	Wed May  3 05:12:35 2000
--- motif/clients/uil/UilSymStor.c	Sat Jun  3 19:00:27 2000
***************
*** 1466,1477 ****
      case sym_k_integer_value:
      case sym_k_horizontal_integer_value:
      case sym_k_vertical_integer_value:
! 	_debug_output("  integer: %d \n", 
  		      az_value_entry->value.l_integer );
  	break;
  
      case sym_k_bool_value:
! 	_debug_output("  boolean: %d \n", 
  		      az_value_entry->value.l_integer );
  	break;
  
--- 1466,1477 ----
      case sym_k_integer_value:
      case sym_k_horizontal_integer_value:
      case sym_k_vertical_integer_value:
! 	_debug_output("  integer: %ld \n", 
  		      az_value_entry->value.l_integer );
  	break;
  
      case sym_k_bool_value:
! 	_debug_output("  boolean: %ld \n", 
  		      az_value_entry->value.l_integer );
  	break;
  
***************
*** 1521,1527 ****
  	_debug_output("  %s", special_type );
  
  	if (az_value_entry->obj_header.b_flags & sym_m_builtin)
! 	    _debug_output("  code: %d \n", az_value_entry->value.l_integer );
  	else
  	    output_text( az_value_entry->w_length, 
  			 az_value_entry->value.c_value);
--- 1521,1527 ----
  	_debug_output("  %s", special_type );
  
  	if (az_value_entry->obj_header.b_flags & sym_m_builtin)
! 	    _debug_output("  code: %ld \n", az_value_entry->value.l_integer );
  	else
  	    output_text( az_value_entry->w_length, 
  			 az_value_entry->value.c_value);
*** motif.orig/clients/xmbind/xmbind.c	Wed May  3 05:12:35 2000
--- motif/clients/xmbind/xmbind.c	Sat Jun  3 18:51:29 2000
***************
*** 48,54 ****
  extern Boolean _XmVirtKeysLoadFileBindings(char *fileName, String *binding);
  extern int _XmVirtKeysLoadFallbackBindings(Display *display, String *binding);
  
! void main(argc, argv)
      int argc;
      char **argv;
  {
--- 48,54 ----
  extern Boolean _XmVirtKeysLoadFileBindings(char *fileName, String *binding);
  extern int _XmVirtKeysLoadFallbackBindings(Display *display, String *binding);
  
! int main(argc, argv)
      int argc;
      char **argv;
  {
***************
*** 101,105 ****
--- 101,107 ----
      XtFree (bindings);
     
      exit(0);
+ 
+     return 0;    /* make compiler happy */
  }
  
*** motif.orig/config/cf/Motif.rules	Tue May  2 11:53:43 2000
--- motif/config/cf/Motif.rules	Fri Jun 30 16:38:12 2000
***************
*** 75,80 ****
--- 75,86 ----
  # define ImportMotif		NO
  #endif
  
+ #if UseInstalledMotif
+ #define ClientEnvSetup /**/
+ #else
+ #define ClientEnvSetup $(CLIENTENVSETUP)
+ #endif
+ 
  #ifndef MSimpleProgramTarget
  #define MSimpleProgramTarget(program)                                   @@\
  AllTarget(program)                                                      @@\
***************
*** 109,115 ****
  	                                                                @@\
  program.uid: program.uil $(DEPUIL)                                      @@\
  	RemoveTargetProgram($@)                                         @@\
! 	$(CLIENTENVSETUP) $(UIL) $(UILFLAGS) $(LOCAL_UILFLAGS) -o $@ program.uil $(UIL_INCLUDES)	@@\
  	                                                                @@\
  InstallNonExecFile(program.uid,$(UIDDIR))                               @@\
                                                                          @@\
--- 115,121 ----
  	                                                                @@\
  program.uid: program.uil $(DEPUIL)                                      @@\
  	RemoveTargetProgram($@)                                         @@\
! 	ClientEnvSetup $(UIL) $(UILFLAGS) $(LOCAL_UILFLAGS) -o $@ program.uil $(UIL_INCLUDES)	@@\
  	                                                                @@\
  InstallNonExecFile(program.uid,$(UIDDIR))                               @@\
                                                                          @@\
***************
*** 123,129 ****
  	                                                                @@\
  subdir/program.uid: subdir/program.uil $(DEPUIL)                        @@\
  	RemoveTargetProgram($@)                                         @@\
! 	$(CLIENTENVSETUP) $(UIL) $(UILFLAGS) $(LOCAL_UILFLAGS) -o $@ subdir/program.uil $(UIL_INCLUDES)	@@\
  	                                                                @@\
  InstallNamedTarget(install,subdir/program.uid,$(INSTDATFLAGS),$(UIDDIR)/subdir,program.uid) @@\
                                                                          @@\
--- 129,135 ----
  	                                                                @@\
  subdir/program.uid: subdir/program.uil $(DEPUIL)                        @@\
  	RemoveTargetProgram($@)                                         @@\
! 	ClientEnvSetup $(UIL) $(UILFLAGS) $(LOCAL_UILFLAGS) -o $@ subdir/program.uil $(UIL_INCLUDES)	@@\
  	                                                                @@\
  InstallNamedTarget(install,subdir/program.uid,$(INSTDATFLAGS),$(UIDDIR)/subdir,program.uid) @@\
                                                                          @@\
***************
*** 137,143 ****
  	                                                                @@\
  program.uid: program.uil $(DEPUIL)                                      @@\
  	RemoveTargetProgram($@)                                         @@\
! 	$(CLIENTENVSETUP) $(UIL) $(UILFLAGS) $(LOCAL_UILFLAGS) -o $@ program.uil $(UIL_INCLUDES)	@@\
  	                                                                @@\
  InstallNonExecFile(program.uid,$(LIBDIR)/locale/uid)                    @@\
                                                                          @@\
--- 143,149 ----
  	                                                                @@\
  program.uid: program.uil $(DEPUIL)                                      @@\
  	RemoveTargetProgram($@)                                         @@\
! 	ClientEnvSetup $(UIL) $(UILFLAGS) $(LOCAL_UILFLAGS) -o $@ program.uil $(UIL_INCLUDES)	@@\
  	                                                                @@\
  InstallNonExecFile(program.uid,$(LIBDIR)/locale/uid)                    @@\
                                                                          @@\
***************
*** 152,158 ****
  	                                                                @@\
  program.uid:  $(UILS1) $(DEPUIL)                                        @@\
  	RemoveTargetProgram($@)                                         @@\
! 	$(CLIENTENVSETUP) $(UIL) $(UILFLAGS) $(LOCAL_UILFLAGS_1) -o $@ program.uil $(UIL_INCLUDES)	@@\
  	                                                                @@\
  InstallNonExecFile(program.uid,$(UIDDIR))                               @@\
                                                                          @@\
--- 158,164 ----
  	                                                                @@\
  program.uid:  $(UILS1) $(DEPUIL)                                        @@\
  	RemoveTargetProgram($@)                                         @@\
! 	ClientEnvSetup $(UIL) $(UILFLAGS) $(LOCAL_UILFLAGS_1) -o $@ program.uil $(UIL_INCLUDES)	@@\
  	                                                                @@\
  InstallNonExecFile(program.uid,$(UIDDIR))                               @@\
                                                                          @@\
***************
*** 167,173 ****
  	                                                                @@\
  program.uid:  $(UILS2) $(DEPUIL)                                        @@\
  	RemoveTargetProgram($@)                                         @@\
! 	$(CLIENTENVSETUP) $(UIL) $(UILFLAGS) $(LOCAL_UILFLAGS_2) -o $@ program.uil $(UIL_INCLUDES)	@@\
  	                                                                @@\
  InstallNonExecFile(program.uid,$(UIDDIR))                               @@\
                                                                          @@\
--- 173,179 ----
  	                                                                @@\
  program.uid:  $(UILS2) $(DEPUIL)                                        @@\
  	RemoveTargetProgram($@)                                         @@\
! 	ClientEnvSetup $(UIL) $(UILFLAGS) $(LOCAL_UILFLAGS_2) -o $@ program.uil $(UIL_INCLUDES)	@@\
  	                                                                @@\
  InstallNonExecFile(program.uid,$(UIDDIR))                               @@\
                                                                          @@\
***************
*** 182,188 ****
  	                                                                @@\
  program.uid:  $(UILS3) $(DEPUIL)                                        @@\
  	RemoveTargetProgram($@)                                         @@\
! 	$(CLIENTENVSETUP) $(UIL) $(UILFLAGS) $(LOCAL_UILFLAGS_3) -o $@ program.uil $(UIL_INCLUDES)	@@\
  	                                                                @@\
  InstallNonExecFile(program.uid,$(UIDDIR))                               @@\
                                                                          @@\
--- 188,194 ----
  	                                                                @@\
  program.uid:  $(UILS3) $(DEPUIL)                                        @@\
  	RemoveTargetProgram($@)                                         @@\
! 	ClientEnvSetup $(UIL) $(UILFLAGS) $(LOCAL_UILFLAGS_3) -o $@ program.uil $(UIL_INCLUDES)	@@\
  	                                                                @@\
  InstallNonExecFile(program.uid,$(UIDDIR))                               @@\
                                                                          @@\
***************
*** 197,203 ****
  	                                                                @@\
  program.uid:  $(UILS4) $(DEPUIL)                                        @@\
  	RemoveTargetProgram($@)                                         @@\
! 	$(CLIENTENVSETUP) $(UIL) $(UILFLAGS) $(LOCAL_UILFLAGS_4) -o $@ program.uil $(UIL_INCLUDES)	@@\
  	                                                                @@\
  InstallNonExecFile(program.uid,$(UIDDIR))                               @@\
                                                                          @@\
--- 203,209 ----
  	                                                                @@\
  program.uid:  $(UILS4) $(DEPUIL)                                        @@\
  	RemoveTargetProgram($@)                                         @@\
! 	ClientEnvSetup $(UIL) $(UILFLAGS) $(LOCAL_UILFLAGS_4) -o $@ program.uil $(UIL_INCLUDES)	@@\
  	                                                                @@\
  InstallNonExecFile(program.uid,$(UIDDIR))                               @@\
                                                                          @@\
***************
*** 212,218 ****
  	                                                                @@\
  program.uid:  $(UILS5) $(DEPUIL)                                        @@\
  	RemoveTargetProgram($@)                                         @@\
! 	$(CLIENTENVSETUP) $(UIL) $(UILFLAGS) $(LOCAL_UILFLAGS_5) -o $@ program.uil $(UIL_INCLUDES)	@@\
  	                                                                @@\
  InstallNonExecFile(program.uid,$(UIDDIR))                               @@\
                                                                          @@\
--- 218,224 ----
  	                                                                @@\
  program.uid:  $(UILS5) $(DEPUIL)                                        @@\
  	RemoveTargetProgram($@)                                         @@\
! 	ClientEnvSetup $(UIL) $(UILFLAGS) $(LOCAL_UILFLAGS_5) -o $@ program.uil $(UIL_INCLUDES)	@@\
  	                                                                @@\
  InstallNonExecFile(program.uid,$(UIDDIR))                               @@\
                                                                          @@\
***************
*** 227,233 ****
  	                                                                @@\
  program.uid:  $(UILS6) $(DEPUIL)                                        @@\
  	RemoveTargetProgram($@)                                         @@\
! 	$(CLIENTENVSETUP) $(UIL) $(UILFLAGS) $(LOCAL_UILFLAGS_6) -o $@ program.uil $(UIL_INCLUDES)	@@\
  	                                                                @@\
  InstallNonExecFile(program.uid,$(UIDDIR))                               @@\
                                                                          @@\
--- 233,239 ----
  	                                                                @@\
  program.uid:  $(UILS6) $(DEPUIL)                                        @@\
  	RemoveTargetProgram($@)                                         @@\
! 	ClientEnvSetup $(UIL) $(UILFLAGS) $(LOCAL_UILFLAGS_6) -o $@ program.uil $(UIL_INCLUDES)	@@\
  	                                                                @@\
  InstallNonExecFile(program.uid,$(UIDDIR))                               @@\
                                                                          @@\
***************
*** 242,248 ****
  	                                                                @@\
  program.uid:  $(UILS7) $(DEPUIL)                                        @@\
  	RemoveTargetProgram($@)                                         @@\
! 	$(CLIENTENVSETUP) $(UIL) $(UILFLAGS) $(LOCAL_UILFLAGS_7) -o $@ program.uil $(UIL_INCLUDES)	@@\
  	                                                                @@\
  InstallNonExecFile(program.uid,$(UIDDIR))                               @@\
                                                                          @@\
--- 248,254 ----
  	                                                                @@\
  program.uid:  $(UILS7) $(DEPUIL)                                        @@\
  	RemoveTargetProgram($@)                                         @@\
! 	ClientEnvSetup $(UIL) $(UILFLAGS) $(LOCAL_UILFLAGS_7) -o $@ program.uil $(UIL_INCLUDES)	@@\
  	                                                                @@\
  InstallNonExecFile(program.uid,$(UIDDIR))                               @@\
                                                                          @@\
***************
*** 257,263 ****
  	                                                                @@\
  program.uid:  $(UILS8) $(DEPUIL)                                        @@\
  	RemoveTargetProgram($@)                                         @@\
! 	$(CLIENTENVSETUP) $(UIL) $(UILFLAGS) $(LOCAL_UILFLAGS_8) -o $@ program.uil $(UIL_INCLUDES)	@@\
  	                                                                @@\
  InstallNonExecFile(program.uid,$(UIDDIR))                               @@\
                                                                          @@\
--- 263,269 ----
  	                                                                @@\
  program.uid:  $(UILS8) $(DEPUIL)                                        @@\
  	RemoveTargetProgram($@)                                         @@\
! 	ClientEnvSetup $(UIL) $(UILFLAGS) $(LOCAL_UILFLAGS_8) -o $@ program.uil $(UIL_INCLUDES)	@@\
  	                                                                @@\
  InstallNonExecFile(program.uid,$(UIDDIR))                               @@\
                                                                          @@\
***************
*** 272,278 ****
  	                                                                @@\
  program.uid:  $(UILS9) $(DEPUIL)                                        @@\
  	RemoveTargetProgram($@)                                         @@\
! 	$(CLIENTENVSETUP) $(UIL) $(UILFLAGS) $(LOCAL_UILFLAGS_9) -o $@ program.uil $(UIL_INCLUDES)	@@\
  	                                                                @@\
  InstallNonExecFile(program.uid,$(UIDDIR))                               @@\
                                                                          @@\
--- 278,284 ----
  	                                                                @@\
  program.uid:  $(UILS9) $(DEPUIL)                                        @@\
  	RemoveTargetProgram($@)                                         @@\
! 	ClientEnvSetup $(UIL) $(UILFLAGS) $(LOCAL_UILFLAGS_9) -o $@ program.uil $(UIL_INCLUDES)	@@\
  	                                                                @@\
  InstallNonExecFile(program.uid,$(UIDDIR))                               @@\
                                                                          @@\
***************
*** 287,293 ****
  	                                                                @@\
  program.uid:  $(UILS10) $(DEPUIL)                                       @@\
  	RemoveTargetProgram($@)                                         @@\
! 	$(CLIENTENVSETUP) $(UIL) $(UILFLAGS) $(LOCAL_UILFLAGS_10) -o $@ program.uil $(UIL_INCLUDES)	@@\
  	                                                                @@\
  InstallNonExecFile(program.uid,$(UIDDIR))                               @@\
                                                                          @@\
--- 293,299 ----
  	                                                                @@\
  program.uid:  $(UILS10) $(DEPUIL)                                       @@\
  	RemoveTargetProgram($@)                                         @@\
! 	ClientEnvSetup $(UIL) $(UILFLAGS) $(LOCAL_UILFLAGS_10) -o $@ program.uil $(UIL_INCLUDES)	@@\
  	                                                                @@\
  InstallNonExecFile(program.uid,$(UIDDIR))                               @@\
                                                                          @@\
***************
*** 439,444 ****
--- 445,487 ----
  InstallProgram(program,$(BINDIR))
  #endif
  
+ /*
+  * InstallMotifHelpFile - Install a Motif demo program help file
+  */
+ #ifndef InstallMotifHelpFile
+ #define InstallMotifHelpFile(file)					@@\
+ InstallNamedTarget(install,file.help,$(INSTDATFLAGS),$(LIBDIR)/help,file.help)
+ #endif
+ 
+ /*
+  * InstallMotifManPage - Install a Motif man page
+  */
+ #if defined(FreeBSDArchitecture) && CompressManPages
+ 
+ #ifndef CompressManPage
+ #define CompressManPage(file)						@@\
+ file.gz: file								@@\
+ 	-$(COMPRESSMANCMD) -c file > file.gz				@@\
+ 									@@\
+ clean::									@@\
+ 	$(RM) file.gz
+ #endif
+ 
+ #ifndef InstallMotifManPage
+ #define InstallMotifManPage(file,section)				@@\
+ CompressManPage(file.section)						@@\
+ 									@@\
+ install.man:: file.section.gz						@@\
+ 	$(INSTALL) $(INSTALLFLAGS) $(INSTMANFLAGS) file.section.gz $(DESTDIR)$(MANDIR)/file.$(MANSUFFIX).gz
+ #endif
+ #else /* FreeBSDArchitecture */
+ #ifndef InstallMotifManPage
+ #define InstallMotifManPage(file,section)				@@\
+ install.man:: file.section						@@\
+ 	$(INSTALL) $(INSTALLFLAGS) $(INSTMANFLAGS) file.section $(DESTDIR)$(MANDIR)/file.$(MANSUFFIX)
+ #endif
+ #endif
+ 
  #ifdef AUTOMATION
  #ifndef TestPPTarget
  #define TestPPTarget(root)						@@\
***************
*** 735,741 ****
  #endif
  
  #ifndef MotifProjectDefines
! # define MotifProjectDefines	MotifDefines MessageCatalogDefines
  #endif
  #ifdef ProjectDefines
  # undef ProjectDefines
--- 778,788 ----
  #endif
  
  #ifndef MotifProjectDefines
! #if UseInstalledMotif
! #  define MotifProjectDefines	/**/
! # else
! #  define MotifProjectDefines	MotifDefines MessageCatalogDefines
! # endif
  #endif
  #ifdef ProjectDefines
  # undef ProjectDefines
*** motif.orig/config/cf/Motif.tmpl	Fri Jul  7 14:12:55 2000
--- motif/config/cf/Motif.tmpl	Sat Jun  3 18:49:15 2000
***************
*** 396,406 ****
  /* hardcoded default path.  Contrary to the original duplicate of USRLIBDIR
     in the Imakefiles. */
  #ifndef VirtualBindingsPath
! # define VirtualBindingsPath /usr/lib/Xm/bindings
  #endif
  
                MTOP = MTop
  TOP_MOTIF_INCLUDES = -I$(MINCLUDESRC)
  #if defined(UseInstalled) || (UseInstalledMotif && UseInstalledX11)
        UIL_INCLUDES = -I$(USRINCDIR)/uil
  #else
--- 396,408 ----
  /* hardcoded default path.  Contrary to the original duplicate of USRLIBDIR
     in the Imakefiles. */
  #ifndef VirtualBindingsPath
! # define VirtualBindingsPath $(USRLIBDIR)/Xm/bindings
  #endif
  
                MTOP = MTop
+ #if !UseInstalledMotif
  TOP_MOTIF_INCLUDES = -I$(MINCLUDESRC)
+ #endif
  #if defined(UseInstalled) || (UseInstalledMotif && UseInstalledX11)
        UIL_INCLUDES = -I$(USRINCDIR)/uil
  #else
*** motif.orig/doc/man/Imakefile	Fri Jul  7 14:45:07 2000
--- motif/doc/man/Imakefile	Wed May 10 11:03:01 2000
***************
*** 0 ****
--- 1,17 ----
+ XCOMM Imakefile
+ 
+ #define IHaveSubdirs
+ #define PassCDebugFlags
+ 
+ SUBDIRS = man1 man3 man4 man5
+ 
+ all::
+ 
+ install.man::
+ 	MakeDir($(DESTDIR)$(MANDIR))
+ 	MakeDir($(DESTDIR)$(LIBMANDIR))
+ 	MakeDir($(DESTDIR)$(FILEMANDIR))
+ 	MakeDir($(DESTDIR)$(MISCMANDIR))
+ 
+ MakeSubdirs($(SUBDIRS))
+ DependSubdirs($(SUBDIRS))
*** motif.orig/doc/man/man1/Imakefile	Fri Jul  7 14:45:07 2000
--- motif/doc/man/man1/Imakefile	Wed May 10 11:01:57 2000
***************
*** 0 ****
--- 1,7 ----
+ XCOMM Imakefile
+ 
+ all::
+ 
+ InstallMotifManPage(mwm,1)
+ InstallMotifManPage(uil,1)
+ InstallMotifManPage(xmbind,1)
*** motif.orig/doc/man/man1/mwm.1	Fri Apr 28 11:05:27 2000
--- motif/doc/man/man1/mwm.1	Wed May 10 13:09:33 2000
***************
*** 70,78 ****
  This option specifies a resource string to use\&.
  .IP "\fI-multiscreen\fP" 10
  This option causes \fBmwm\fP to manage all screens on
! the display\&. Since \fBmwm\fP does this by default, this option
! is of limited use\&. See the \fImultiScreen\fP resource for information
! on managing a single screen\&.
  .IP "\fI-name\fP\ \fBname\fP" 10
  This option causes \fBmwm\fP to retrieve its resources
  using the specified name, as in \fBname*resource\fP\&.
--- 70,76 ----
  This option specifies a resource string to use\&.
  .IP "\fI-multiscreen\fP" 10
  This option causes \fBmwm\fP to manage all screens on
! the display\&. The default is to manage only a single screen.
  .IP "\fI-name\fP\ \fBname\fP" 10
  This option causes \fBmwm\fP to retrieve its resources
  using the specified name, as in \fBname*resource\fP\&.
***************
*** 368,374 ****
  database\&. This database is built from the following sources\&. They are listed
  in order of precedence, low to high:
  .PP
! \fB/usr/lib/X11/app-defaults/Mwm\fP
  .PP
  \fB$HOME/Mwm\fP
  .PP
--- 366,372 ----
  database\&. This database is built from the following sources\&. They are listed
  in order of precedence, low to high:
  .PP
! \fB/usr/X11R6/lib/X11/app-defaults/Mwm\fP
  .PP
  \fB$HOME/Mwm\fP
  .PP
***************
*** 378,384 ****
  .PP
  \fBmwm\fP command line options
  .PP
! The file names \fB/usr/lib/X11/app-defaults/Mwm\fP and \fB$HOME/Mwm\fP represent customary locations for these files\&. The actual
  location of the system-wide class resource file may depend on the \fBXFILESEARCHPATH\fP environment variable and the
  current language environment\&. The actual location of the user-specific class
  resource file may depend on the \fBXUSERFILESEARCHPATH\fP and \fBXAPPLRESDIR\fP
--- 376,382 ----
  .PP
  \fBmwm\fP command line options
  .PP
! The file names \fB/usr/X11R6/lib/X11/app-defaults/Mwm\fP and \fB$HOME/Mwm\fP represent customary locations for these files\&. The actual
  location of the system-wide class resource file may depend on the \fBXFILESEARCHPATH\fP environment variable and the
  current language environment\&. The actual location of the user-specific class
  resource file may depend on the \fBXUSERFILESEARCHPATH\fP and \fBXAPPLRESDIR\fP
***************
*** 597,603 ****
  NameClassValue TypeDefault
  autoKeyFocusAutoKeyFocusT/FT
  autoRaiseDelayAutoRaiseDelaymillisec500
! bitmap-Bitmap-directory/usr/include-
  DirectoryDirectory/X11/bitmaps
  clientAutoPlaceClientAutoPlaceT/FT
  colormapFocus-ColormapFocus-stringkeyboard
--- 595,601 ----
  NameClassValue TypeDefault
  autoKeyFocusAutoKeyFocusT/FT
  autoRaiseDelayAutoRaiseDelaymillisec500
! bitmap-Bitmap-directory/usr/X11R6/include-
  DirectoryDirectory/X11/bitmaps
  clientAutoPlaceClientAutoPlaceT/FT
  colormapFocus-ColormapFocus-stringkeyboard
***************
*** 616,622 ****
  PolicyPolicy
  lowerOnIconifyLowerOnIconifyT/FT
  moveThresholdMoveThresholdpixels4
! multiScreenMultiScreenT/FT
  passButtonsPassButtonsT/FF
  passSelectButtonPassSelectButtonT/FT
  positionIsFramePositionIsFrameT/FT
--- 614,620 ----
  PolicyPolicy
  lowerOnIconifyLowerOnIconifyT/FT
  moveThresholdMoveThresholdpixels4
! multiScreenMultiScreenT/FF
  passButtonsPassButtonsT/FF
  passSelectButtonPassSelectButtonT/FT
  positionIsFramePositionIsFrameT/FT
***************
*** 626,632 ****
  refreshByClearingRefreshByClearingT/FT
  rootButtonClickRootButtonClickT/FF
  screensScreensstringvaries
! sessionClientDBSessionClientDBstring\fB$HOME/\&.mwmclientdb\fP
  showFeedbackShowFeedbackstringall
  startupKeyFocusStartupKeyFocusT/FT
  wMenuButtonClickWMenuButtonClickT/FT
--- 624,630 ----
  refreshByClearingRefreshByClearingT/FT
  rootButtonClickRootButtonClickT/FF
  screensScreensstringvaries
! sessionClientDBSessionClientDBstring$HOME/\&.mwmclientdb
  showFeedbackShowFeedbackstringall
  startupKeyFocusStartupKeyFocusT/FT
  wMenuButtonClickWMenuButtonClickT/FT
***************
*** 652,658 ****
  This resource identifies a directory to be searched for bitmaps referenced
  by \fBmwm\fP resources\&. This directory is searched if a bitmap
  is specified without an absolute pathname\&. The default value for this resource
! is BR /usr/include/X11/bitmaps\&. The directory \fB/usr/include/X11/bitmaps\fP
  represents the customary locations for this directory\&. The actual
  location of this directory may vary on some systems\&. If the bitmap is not
  found in the specified directory, \fBXBMLANGPATH\fP is searched\&.
--- 650,656 ----
  This resource identifies a directory to be searched for bitmaps referenced
  by \fBmwm\fP resources\&. This directory is searched if a bitmap
  is specified without an absolute pathname\&. The default value for this resource
! is \fB/usr/X11R6/include/X11/bitmaps\fP\&. The directory \fB/usr/X11R6/include/X11/bitmaps\fP
  represents the customary locations for this directory\&. The actual
  location of this directory may vary on some systems\&. If the bitmap is not
  found in the specified directory, \fBXBMLANGPATH\fP is searched\&.
***************
*** 680,688 ****
  \fB$HOME\fP/\fBconfigFile\fP\&. If the \fIconfigFile\fP pathname does not begin with "~/" or "/", \fBmwm\fP considers it to be relative to the current working directory\&. If
  the \fIconfigFile\fP resource is not specified
  or if that file does not exist, \fBmwm\fP uses several default
! paths to find a configuration file\&. The order of the search is shown below: \fB$HOME/\&.dt/$LANG/mwmrc\fP \fB$HOME/\&.dt/mwmrc\fP \fB/etc/dt/config/$LANG/sys\&.mwmrc\fP\(dg
! \fB/etc/dt/config/sys\&.mwmrc\fP\(dg \fB/usr/dt/config/$LANG/sys\&.mwmrc\fP\(dg
! \fB/usr/dt/config/sys\&.mwmrc\fP\(dg Paths marked with \&'\(dg\&' are
  implementation dependent\&.
  .IP "\fIdeiconifyKeyFocus\fP\ (class\  \fIDeiconifyKeyFocus\fP)" 10
  This resource applies only when the keyboard input focus policy is explicit\&.
--- 678,685 ----
  \fB$HOME\fP/\fBconfigFile\fP\&. If the \fIconfigFile\fP pathname does not begin with "~/" or "/", \fBmwm\fP considers it to be relative to the current working directory\&. If
  the \fIconfigFile\fP resource is not specified
  or if that file does not exist, \fBmwm\fP uses several default
! paths to find a configuration file\&. The order of the search is shown below: \fB/usr/X11R6/lib/X11/$LANG/system\&.mwmrc\fP\(dg
! \fB/usr/X11R6/lib/X11/system\&.mwmrc\fP\(dg Paths marked with \&'\(dg\&' are
  implementation dependent\&.
  .IP "\fIdeiconifyKeyFocus\fP\ (class\  \fIDeiconifyKeyFocus\fP)" 10
  This resource applies only when the keyboard input focus policy is explicit\&.
***************
*** 752,758 ****
  .IP "\fImultiScreen\fP\ (class\  \fIMultiScreen\fP)" 10
  This resource, if True, causes \fBmwm\fP to manage all
  the screens on the display\&. If False, \fBmwm\fP manages only
! a single screen\&. The default value is True\&.
  .IP "\fIpassButtons\fP\ (class\  \fIPassButtons\fP)" 10
  This resource indicates whether or not button press events are passed
  to clients after they are used to do a window manager function in the client
--- 749,755 ----
  .IP "\fImultiScreen\fP\ (class\  \fIMultiScreen\fP)" 10
  This resource, if True, causes \fBmwm\fP to manage all
  the screens on the display\&. If False, \fBmwm\fP manages only
! a single screen\&. The default value is False\&.
  .IP "\fIpassButtons\fP\ (class\  \fIPassButtons\fP)" 10
  This resource indicates whether or not button press events are passed
  to clients after they are used to do a window manager function in the client
***************
*** 848,854 ****
  T}
  quitConfirm quitting \fBmwm\fP\&.
  resizeShow size during resize\&.
! restartConfirm \fBmwm restart\fP\&.
  .TE
  .PP
  The following command line illustrates the syntax for showFeedback:
--- 845,851 ----
  T}
  quitConfirm quitting \fBmwm\fP\&.
  resizeShow size during resize\&.
! restartConfirm \fBmwm\fP restart\&.
  .TE
  .PP
  The following command line illustrates the syntax for showFeedback:
***************
*** 1347,1357 ****
  function\&.
  .SS "Files"
  .PP
! \fB/usr/lib/X11/$LANG/system\&.mwmrc\fP
  .PP
! \fB/usr/lib/X11/system\&.mwmrc\fP
  .PP
! \fB/usr/lib/X11/app-defaults/Mwm\fP
  .PP
  \fB$HOME/Mwm\fP
  .PP
--- 1344,1354 ----
  function\&.
  .SS "Files"
  .PP
! \fB/usr/X11R6/lib/X11/$LANG/system\&.mwmrc\fP
  .PP
! \fB/usr/X11R6/lib/X11/system\&.mwmrc\fP
  .PP
! \fB/usr/X11R6/lib/X11/app-defaults/Mwm\fP
  .PP
  \fB$HOME/Mwm\fP
  .PP
*** motif.orig/doc/man/man3/Imakefile	Fri Jul  7 14:45:07 2000
--- motif/doc/man/man3/Imakefile	Wed May 10 11:03:01 2000
***************
*** 0 ****
--- 1,556 ----
+ XCOMM Imakefile
+ 
+ MANDIR = $(LIBMANDIR)
+ MANSUFFIX = $(LIBMANSUFFIX)
+ 
+ all::
+ 
+ InstallMotifManPage(ApplicationShell,3)
+ InstallMotifManPage(Composite,3)
+ InstallMotifManPage(Constraint,3)
+ InstallMotifManPage(Core,3)
+ InstallMotifManPage(MrmCloseHierarchy,3)
+ InstallMotifManPage(MrmFetchBitmapLiteral,3)
+ InstallMotifManPage(MrmFetchColorLiteral,3)
+ InstallMotifManPage(MrmFetchIconLiteral,3)
+ InstallMotifManPage(MrmFetchLiteral,3)
+ InstallMotifManPage(MrmFetchSetValues,3)
+ InstallMotifManPage(MrmFetchWidget,3)
+ InstallMotifManPage(MrmFetchWidgetOverride,3)
+ InstallMotifManPage(MrmInitialize,3)
+ InstallMotifManPage(MrmOpenHierarchy,3)
+ InstallMotifManPage(MrmOpenHierarchyFromBuffer,3)
+ InstallMotifManPage(MrmOpenHierarchyPerDisplay,3)
+ InstallMotifManPage(MrmRegisterClass,3)
+ InstallMotifManPage(MrmRegisterNames,3)
+ InstallMotifManPage(MrmRegisterNamesInHierarchy,3)
+ InstallMotifManPage(Object,3)
+ InstallMotifManPage(OverrideShell,3)
+ InstallMotifManPage(RectObj,3)
+ InstallMotifManPage(Shell,3)
+ InstallMotifManPage(TopLevelShell,3)
+ InstallMotifManPage(TransientShell,3)
+ InstallMotifManPage(Uil,3)
+ InstallMotifManPage(UilDumpSymbolTable,3)
+ InstallMotifManPage(VendorShell,3)
+ InstallMotifManPage(VirtualBindings,3)
+ InstallMotifManPage(WMShell,3)
+ InstallMotifManPage(XmActivateProtocol,3)
+ InstallMotifManPage(XmActivateWMProtocol,3)
+ InstallMotifManPage(XmAddProtocolCallback,3)
+ InstallMotifManPage(XmAddProtocols,3)
+ InstallMotifManPage(XmAddTabGroup,3)
+ InstallMotifManPage(XmAddToPostFromList,3)
+ InstallMotifManPage(XmAddWMProtocolCallback,3)
+ InstallMotifManPage(XmAddWMProtocols,3)
+ InstallMotifManPage(XmArrowButton,3)
+ InstallMotifManPage(XmArrowButtonGadget,3)
+ InstallMotifManPage(XmBulletinBoard,3)
+ InstallMotifManPage(XmCascadeButton,3)
+ InstallMotifManPage(XmCascadeButtonGadget,3)
+ InstallMotifManPage(XmCascadeButtonGadgetHighlight,3)
+ InstallMotifManPage(XmCascadeButtonHighlight,3)
+ InstallMotifManPage(XmChangeColor,3)
+ InstallMotifManPage(XmClipboardCancelCopy,3)
+ InstallMotifManPage(XmClipboardCopy,3)
+ InstallMotifManPage(XmClipboardCopyByName,3)
+ InstallMotifManPage(XmClipboardEndCopy,3)
+ InstallMotifManPage(XmClipboardEndRetrieve,3)
+ InstallMotifManPage(XmClipboardInquireCount,3)
+ InstallMotifManPage(XmClipboardInquireFormat,3)
+ InstallMotifManPage(XmClipboardInquireLength,3)
+ InstallMotifManPage(XmClipboardInquirePendingItems,3)
+ InstallMotifManPage(XmClipboardLock,3)
+ InstallMotifManPage(XmClipboardRegisterFormat,3)
+ InstallMotifManPage(XmClipboardRetrieve,3)
+ InstallMotifManPage(XmClipboardStartCopy,3)
+ InstallMotifManPage(XmClipboardStartRetrieve,3)
+ InstallMotifManPage(XmClipboardUndoCopy,3)
+ InstallMotifManPage(XmClipboardUnlock,3)
+ InstallMotifManPage(XmClipboardWithdrawFormat,3)
+ InstallMotifManPage(XmComboBox,3)
+ InstallMotifManPage(XmComboBoxAddItem,3)
+ InstallMotifManPage(XmComboBoxDeletePos,3)
+ InstallMotifManPage(XmComboBoxSelectItem,3)
+ InstallMotifManPage(XmComboBoxSetItem,3)
+ InstallMotifManPage(XmComboBoxUpdate,3)
+ InstallMotifManPage(XmCommand,3)
+ InstallMotifManPage(XmCommandAppendValue,3)
+ InstallMotifManPage(XmCommandError,3)
+ InstallMotifManPage(XmCommandGetChild,3)
+ InstallMotifManPage(XmCommandSetValue,3)
+ InstallMotifManPage(XmContainer,3)
+ InstallMotifManPage(XmContainerCopy,3)
+ InstallMotifManPage(XmContainerCopyLink,3)
+ InstallMotifManPage(XmContainerCut,3)
+ InstallMotifManPage(XmContainerGetItemChildren,3)
+ InstallMotifManPage(XmContainerPaste,3)
+ InstallMotifManPage(XmContainerPasteLink,3)
+ InstallMotifManPage(XmContainerRelayout,3)
+ InstallMotifManPage(XmContainerReorder,3)
+ InstallMotifManPage(XmConvertStringToUnits,3)
+ InstallMotifManPage(XmConvertUnits,3)
+ InstallMotifManPage(XmCreateArrowButton,3)
+ InstallMotifManPage(XmCreateArrowButtonGadget,3)
+ InstallMotifManPage(XmCreateBulletinBoard,3)
+ InstallMotifManPage(XmCreateBulletinBoardDialog,3)
+ InstallMotifManPage(XmCreateCascadeButton,3)
+ InstallMotifManPage(XmCreateCascadeButtonGadget,3)
+ InstallMotifManPage(XmCreateComboBox,3)
+ InstallMotifManPage(XmCreateCommand,3)
+ InstallMotifManPage(XmCreateCommandDialog,3)
+ InstallMotifManPage(XmCreateContainer,3)
+ InstallMotifManPage(XmCreateDialogShell,3)
+ InstallMotifManPage(XmCreateDragIcon,3)
+ InstallMotifManPage(XmCreateDrawingArea,3)
+ InstallMotifManPage(XmCreateDrawnButton,3)
+ InstallMotifManPage(XmCreateDropDownComboBox,3)
+ InstallMotifManPage(XmCreateDropDownList,3)
+ InstallMotifManPage(XmCreateErrorDialog,3)
+ InstallMotifManPage(XmCreateFileSelectionBox,3)
+ InstallMotifManPage(XmCreateFileSelectionDialog,3)
+ InstallMotifManPage(XmCreateForm,3)
+ InstallMotifManPage(XmCreateFormDialog,3)
+ InstallMotifManPage(XmCreateFrame,3)
+ InstallMotifManPage(XmCreateIconGadget,3)
+ InstallMotifManPage(XmCreateInformationDialog,3)
+ InstallMotifManPage(XmCreateLabel,3)
+ InstallMotifManPage(XmCreateLabelGadget,3)
+ InstallMotifManPage(XmCreateList,3)
+ InstallMotifManPage(XmCreateMainWindow,3)
+ InstallMotifManPage(XmCreateMenuBar,3)
+ InstallMotifManPage(XmCreateMenuShell,3)
+ InstallMotifManPage(XmCreateMessageBox,3)
+ InstallMotifManPage(XmCreateMessageDialog,3)
+ InstallMotifManPage(XmCreateNotebook,3)
+ InstallMotifManPage(XmCreateOptionMenu,3)
+ InstallMotifManPage(XmCreatePanedWindow,3)
+ InstallMotifManPage(XmCreatePopupMenu,3)
+ InstallMotifManPage(XmCreatePromptDialog,3)
+ InstallMotifManPage(XmCreatePulldownMenu,3)
+ InstallMotifManPage(XmCreatePushButton,3)
+ InstallMotifManPage(XmCreatePushButtonGadget,3)
+ InstallMotifManPage(XmCreateQuestionDialog,3)
+ InstallMotifManPage(XmCreateRadioBox,3)
+ InstallMotifManPage(XmCreateRowColumn,3)
+ InstallMotifManPage(XmCreateScale,3)
+ InstallMotifManPage(XmCreateScrollBar,3)
+ InstallMotifManPage(XmCreateScrolledList,3)
+ InstallMotifManPage(XmCreateScrolledText,3)
+ InstallMotifManPage(XmCreateScrolledWindow,3)
+ InstallMotifManPage(XmCreateSelectionBox,3)
+ InstallMotifManPage(XmCreateSelectionDialog,3)
+ InstallMotifManPage(XmCreateSeparator,3)
+ InstallMotifManPage(XmCreateSeparatorGadget,3)
+ InstallMotifManPage(XmCreateSimpleCheckBox,3)
+ InstallMotifManPage(XmCreateSimpleMenuBar,3)
+ InstallMotifManPage(XmCreateSimpleOptionMenu,3)
+ InstallMotifManPage(XmCreateSimplePopupMenu,3)
+ InstallMotifManPage(XmCreateSimplePulldownMenu,3)
+ InstallMotifManPage(XmCreateSimpleRadioBox,3)
+ InstallMotifManPage(XmCreateSimpleSpinBox,3)
+ InstallMotifManPage(XmCreateSpinBox,3)
+ InstallMotifManPage(XmCreateTemplateDialog,3)
+ InstallMotifManPage(XmCreateText,3)
+ InstallMotifManPage(XmCreateTextField,3)
+ InstallMotifManPage(XmCreateToggleButton,3)
+ InstallMotifManPage(XmCreateToggleButtonGadget,3)
+ InstallMotifManPage(XmCreateWarningDialog,3)
+ InstallMotifManPage(XmCreateWorkArea,3)
+ InstallMotifManPage(XmCreateWorkingDialog,3)
+ InstallMotifManPage(XmCvtByteStreamToXmString,3)
+ InstallMotifManPage(XmCvtCTToXmString,3)
+ InstallMotifManPage(XmCvtStringToUnitType,3)
+ InstallMotifManPage(XmCvtTextPropertyToXmStringTable,3)
+ InstallMotifManPage(XmCvtXmStringTableToTextProperty,3)
+ InstallMotifManPage(XmCvtXmStringToByteStream,3)
+ InstallMotifManPage(XmCvtXmStringToCT,3)
+ InstallMotifManPage(XmDeactivateProtocol,3)
+ InstallMotifManPage(XmDeactivateWMProtocol,3)
+ InstallMotifManPage(XmDestroyPixmap,3)
+ InstallMotifManPage(XmDialogShell,3)
+ InstallMotifManPage(XmDirection,3)
+ InstallMotifManPage(XmDirectionMatch,3)
+ InstallMotifManPage(XmDirectionMatchPartial,3)
+ InstallMotifManPage(XmDirectionToStringDirection,3)
+ InstallMotifManPage(XmDisplay,3)
+ InstallMotifManPage(XmDragCancel,3)
+ InstallMotifManPage(XmDragContext,3)
+ InstallMotifManPage(XmDragIcon,3)
+ InstallMotifManPage(XmDragStart,3)
+ InstallMotifManPage(XmDrawingArea,3)
+ InstallMotifManPage(XmDrawnButton,3)
+ InstallMotifManPage(XmDropSite,3)
+ InstallMotifManPage(XmDropSiteConfigureStackingOrder,3)
+ InstallMotifManPage(XmDropSiteEndUpdate,3)
+ InstallMotifManPage(XmDropSiteQueryStackingOrder,3)
+ InstallMotifManPage(XmDropSiteRegister,3)
+ InstallMotifManPage(XmDropSiteRegistered,3)
+ InstallMotifManPage(XmDropSiteRetrieve,3)
+ InstallMotifManPage(XmDropSiteStartUpdate,3)
+ InstallMotifManPage(XmDropSiteUnregister,3)
+ InstallMotifManPage(XmDropSiteUpdate,3)
+ InstallMotifManPage(XmDropTransfer,3)
+ InstallMotifManPage(XmDropTransferAdd,3)
+ InstallMotifManPage(XmDropTransferStart,3)
+ InstallMotifManPage(XmFileSelectionBox,3)
+ InstallMotifManPage(XmFileSelectionBoxGetChild,3)
+ InstallMotifManPage(XmFileSelectionDoSearch,3)
+ InstallMotifManPage(XmFontList,3)
+ InstallMotifManPage(XmFontListAdd,3)
+ InstallMotifManPage(XmFontListAppendEntry,3)
+ InstallMotifManPage(XmFontListCopy,3)
+ InstallMotifManPage(XmFontListCreate,3)
+ InstallMotifManPage(XmFontListEntryCreate,3)
+ InstallMotifManPage(XmFontListEntryFree,3)
+ InstallMotifManPage(XmFontListEntryGetFont,3)
+ InstallMotifManPage(XmFontListEntryGetTag,3)
+ InstallMotifManPage(XmFontListEntryLoad,3)
+ InstallMotifManPage(XmFontListFree,3)
+ InstallMotifManPage(XmFontListFreeFontContext,3)
+ InstallMotifManPage(XmFontListGetNextFont,3)
+ InstallMotifManPage(XmFontListInitFontContext,3)
+ InstallMotifManPage(XmFontListNextEntry,3)
+ InstallMotifManPage(XmFontListRemoveEntry,3)
+ InstallMotifManPage(XmForm,3)
+ InstallMotifManPage(XmFrame,3)
+ InstallMotifManPage(XmGadget,3)
+ InstallMotifManPage(XmGetAtomName,3)
+ InstallMotifManPage(XmGetColorCalculation,3)
+ InstallMotifManPage(XmGetColors,3)
+ InstallMotifManPage(XmGetDestination,3)
+ InstallMotifManPage(XmGetDragContext,3)
+ InstallMotifManPage(XmGetFocusWidget,3)
+ InstallMotifManPage(XmGetMenuCursor,3)
+ InstallMotifManPage(XmGetPixmap,3)
+ InstallMotifManPage(XmGetPixmapByDepth,3)
+ InstallMotifManPage(XmGetPostedFromWidget,3)
+ InstallMotifManPage(XmGetScaledPixmap,3)
+ InstallMotifManPage(XmGetSecondaryResourceData,3)
+ InstallMotifManPage(XmGetTabGroup,3)
+ InstallMotifManPage(XmGetTearOffControl,3)
+ InstallMotifManPage(XmGetVisibility,3)
+ InstallMotifManPage(XmGetXmDisplay,3)
+ InstallMotifManPage(XmGetXmScreen,3)
+ InstallMotifManPage(XmIconGadget,3)
+ InstallMotifManPage(XmImCloseXIM,3)
+ InstallMotifManPage(XmImFreeXIC,3)
+ InstallMotifManPage(XmImGetXIC,3)
+ InstallMotifManPage(XmImGetXIM,3)
+ InstallMotifManPage(XmImMbLookupString,3)
+ InstallMotifManPage(XmImMbResetIC,3)
+ InstallMotifManPage(XmImRegister,3)
+ InstallMotifManPage(XmImSetFocusValues,3)
+ InstallMotifManPage(XmImSetValues,3)
+ InstallMotifManPage(XmImSetXIC,3)
+ InstallMotifManPage(XmImUnregister,3)
+ InstallMotifManPage(XmImUnsetFocus,3)
+ InstallMotifManPage(XmImVaSetFocusValues,3)
+ InstallMotifManPage(XmImVaSetValues,3)
+ InstallMotifManPage(XmInstallImage,3)
+ InstallMotifManPage(XmInternAtom,3)
+ InstallMotifManPage(XmIsMotifWMRunning,3)
+ InstallMotifManPage(XmIsTraversable,3)
+ InstallMotifManPage(XmLabel,3)
+ InstallMotifManPage(XmLabelGadget,3)
+ InstallMotifManPage(XmList,3)
+ InstallMotifManPage(XmListAddItem,3)
+ InstallMotifManPage(XmListAddItemUnselected,3)
+ InstallMotifManPage(XmListAddItems,3)
+ InstallMotifManPage(XmListAddItemsUnselected,3)
+ InstallMotifManPage(XmListDeleteAllItems,3)
+ InstallMotifManPage(XmListDeleteItem,3)
+ InstallMotifManPage(XmListDeleteItems,3)
+ InstallMotifManPage(XmListDeleteItemsPos,3)
+ InstallMotifManPage(XmListDeletePos,3)
+ InstallMotifManPage(XmListDeletePositions,3)
+ InstallMotifManPage(XmListDeselectAllItems,3)
+ InstallMotifManPage(XmListDeselectItem,3)
+ InstallMotifManPage(XmListDeselectPos,3)
+ InstallMotifManPage(XmListGetKbdItemPos,3)
+ InstallMotifManPage(XmListGetMatchPos,3)
+ InstallMotifManPage(XmListGetSelectedPos,3)
+ InstallMotifManPage(XmListItemExists,3)
+ InstallMotifManPage(XmListItemPos,3)
+ InstallMotifManPage(XmListPosSelected,3)
+ InstallMotifManPage(XmListPosToBounds,3)
+ InstallMotifManPage(XmListReplaceItems,3)
+ InstallMotifManPage(XmListReplaceItemsPos,3)
+ InstallMotifManPage(XmListReplaceItemsPosUnselected,3)
+ InstallMotifManPage(XmListReplaceItemsUnselected,3)
+ InstallMotifManPage(XmListReplacePositions,3)
+ InstallMotifManPage(XmListSelectItem,3)
+ InstallMotifManPage(XmListSelectPos,3)
+ InstallMotifManPage(XmListSetAddMode,3)
+ InstallMotifManPage(XmListSetBottomItem,3)
+ InstallMotifManPage(XmListSetBottomPos,3)
+ InstallMotifManPage(XmListSetHorizPos,3)
+ InstallMotifManPage(XmListSetItem,3)
+ InstallMotifManPage(XmListSetKbdItemPos,3)
+ InstallMotifManPage(XmListSetPos,3)
+ InstallMotifManPage(XmListUpdateSelectedList,3)
+ InstallMotifManPage(XmListYToPos,3)
+ InstallMotifManPage(XmMainWindow,3)
+ InstallMotifManPage(XmMainWindowSep1,3)
+ InstallMotifManPage(XmMainWindowSep2,3)
+ InstallMotifManPage(XmMainWindowSep3,3)
+ InstallMotifManPage(XmMainWindowSetAreas,3)
+ InstallMotifManPage(XmManager,3)
+ InstallMotifManPage(XmMapSegmentEncoding,3)
+ InstallMotifManPage(XmMenuPosition,3)
+ InstallMotifManPage(XmMenuShell,3)
+ InstallMotifManPage(XmMessageBox,3)
+ InstallMotifManPage(XmMessageBoxGetChild,3)
+ InstallMotifManPage(XmNotebook,3)
+ InstallMotifManPage(XmNotebookGetPageInfo,3)
+ InstallMotifManPage(XmObjectAtPoint,3)
+ InstallMotifManPage(XmOptionButtonGadget,3)
+ InstallMotifManPage(XmOptionLabelGadget,3)
+ InstallMotifManPage(XmPanedWindow,3)
+ InstallMotifManPage(XmParseMapping,3)
+ InstallMotifManPage(XmParseMappingCreate,3)
+ InstallMotifManPage(XmParseMappingFree,3)
+ InstallMotifManPage(XmParseMappingGetValues,3)
+ InstallMotifManPage(XmParseMappingSetValues,3)
+ InstallMotifManPage(XmParseTable,3)
+ InstallMotifManPage(XmParseTableFree,3)
+ InstallMotifManPage(XmPrimitive,3)
+ InstallMotifManPage(XmPrintPopupPDM,3)
+ InstallMotifManPage(XmPrintSetup,3)
+ InstallMotifManPage(XmPrintShell,3)
+ InstallMotifManPage(XmPrintToFile,3)
+ InstallMotifManPage(XmProcessTraversal,3)
+ InstallMotifManPage(XmPushButton,3)
+ InstallMotifManPage(XmPushButtonGadget,3)
+ InstallMotifManPage(XmRedisplayWidget,3)
+ InstallMotifManPage(XmRegisterSegmentEncoding,3)
+ InstallMotifManPage(XmRemoveFromPostFromList,3)
+ InstallMotifManPage(XmRemoveProtocolCallback,3)
+ InstallMotifManPage(XmRemoveProtocols,3)
+ InstallMotifManPage(XmRemoveTabGroup,3)
+ InstallMotifManPage(XmRemoveWMProtocolCallback,3)
+ InstallMotifManPage(XmRemoveWMProtocols,3)
+ InstallMotifManPage(XmRenderTable,3)
+ InstallMotifManPage(XmRenderTableAddRenditions,3)
+ InstallMotifManPage(XmRenderTableCopy,3)
+ InstallMotifManPage(XmRenderTableCvtFromProp,3)
+ InstallMotifManPage(XmRenderTableCvtToProp,3)
+ InstallMotifManPage(XmRenderTableFree,3)
+ InstallMotifManPage(XmRenderTableGetRendition,3)
+ InstallMotifManPage(XmRenderTableGetRenditions,3)
+ InstallMotifManPage(XmRenderTableGetTags,3)
+ InstallMotifManPage(XmRenderTableRemoveRenditions,3)
+ InstallMotifManPage(XmRendition,3)
+ InstallMotifManPage(XmRenditionCreate,3)
+ InstallMotifManPage(XmRenditionFree,3)
+ InstallMotifManPage(XmRenditionRetrieve,3)
+ InstallMotifManPage(XmRenditionUpdate,3)
+ InstallMotifManPage(XmRepTypeAddReverse,3)
+ InstallMotifManPage(XmRepTypeGetId,3)
+ InstallMotifManPage(XmRepTypeGetNameList,3)
+ InstallMotifManPage(XmRepTypeGetRecord,3)
+ InstallMotifManPage(XmRepTypeGetRegistered,3)
+ InstallMotifManPage(XmRepTypeInstallTearOffModelConverter,3)
+ InstallMotifManPage(XmRepTypeRegister,3)
+ InstallMotifManPage(XmRepTypeValidValue,3)
+ InstallMotifManPage(XmResolveAllPartOffsets,3)
+ InstallMotifManPage(XmResolvePartOffsets,3)
+ InstallMotifManPage(XmRowColumn,3)
+ InstallMotifManPage(XmScale,3)
+ InstallMotifManPage(XmScaleGetValue,3)
+ InstallMotifManPage(XmScaleSetTicks,3)
+ InstallMotifManPage(XmScaleSetValue,3)
+ InstallMotifManPage(XmScreen,3)
+ InstallMotifManPage(XmScrollBar,3)
+ InstallMotifManPage(XmScrollBarGetValues,3)
+ InstallMotifManPage(XmScrollBarSetValues,3)
+ InstallMotifManPage(XmScrollVisible,3)
+ InstallMotifManPage(XmScrolledWindow,3)
+ InstallMotifManPage(XmScrolledWindowSetAreas,3)
+ InstallMotifManPage(XmSelectionBox,3)
+ InstallMotifManPage(XmSelectionBoxGetChild,3)
+ InstallMotifManPage(XmSeparator,3)
+ InstallMotifManPage(XmSeparatorGadget,3)
+ InstallMotifManPage(XmSetColorCalculation,3)
+ InstallMotifManPage(XmSetFontUnit,3)
+ InstallMotifManPage(XmSetFontUnits,3)
+ InstallMotifManPage(XmSetMenuCursor,3)
+ InstallMotifManPage(XmSetProtocolHooks,3)
+ InstallMotifManPage(XmSetWMProtocolHooks,3)
+ InstallMotifManPage(XmSimpleSpinBox,3)
+ InstallMotifManPage(XmSimpleSpinBoxAddItem,3)
+ InstallMotifManPage(XmSimpleSpinBoxDeletePos,3)
+ InstallMotifManPage(XmSimpleSpinBoxSetItem,3)
+ InstallMotifManPage(XmSpinBox,3)
+ InstallMotifManPage(XmSpinBoxValidatePosition,3)
+ InstallMotifManPage(XmString,3)
+ InstallMotifManPage(XmStringBaseline,3)
+ InstallMotifManPage(XmStringByteCompare,3)
+ InstallMotifManPage(XmStringByteStreamLength,3)
+ InstallMotifManPage(XmStringCompare,3)
+ InstallMotifManPage(XmStringComponentCreate,3)
+ InstallMotifManPage(XmStringComponentType,3)
+ InstallMotifManPage(XmStringConcat,3)
+ InstallMotifManPage(XmStringConcatAndFree,3)
+ InstallMotifManPage(XmStringCopy,3)
+ InstallMotifManPage(XmStringCreate,3)
+ InstallMotifManPage(XmStringCreateLocalized,3)
+ InstallMotifManPage(XmStringCreateLtoR,3)
+ InstallMotifManPage(XmStringCreateSimple,3)
+ InstallMotifManPage(XmStringDirection,3)
+ InstallMotifManPage(XmStringDirectionCreate,3)
+ InstallMotifManPage(XmStringDirectionToDirection,3)
+ InstallMotifManPage(XmStringDraw,3)
+ InstallMotifManPage(XmStringDrawImage,3)
+ InstallMotifManPage(XmStringDrawUnderline,3)
+ InstallMotifManPage(XmStringEmpty,3)
+ InstallMotifManPage(XmStringExtent,3)
+ InstallMotifManPage(XmStringFree,3)
+ InstallMotifManPage(XmStringFreeContext,3)
+ InstallMotifManPage(XmStringGenerate,3)
+ InstallMotifManPage(XmStringGetLtoR,3)
+ InstallMotifManPage(XmStringGetNextComponent,3)
+ InstallMotifManPage(XmStringGetNextSegment,3)
+ InstallMotifManPage(XmStringGetNextTriple,3)
+ InstallMotifManPage(XmStringHasSubstring,3)
+ InstallMotifManPage(XmStringHeight,3)
+ InstallMotifManPage(XmStringInitContext,3)
+ InstallMotifManPage(XmStringIsVoid,3)
+ InstallMotifManPage(XmStringLength,3)
+ InstallMotifManPage(XmStringLineCount,3)
+ InstallMotifManPage(XmStringNConcat,3)
+ InstallMotifManPage(XmStringNCopy,3)
+ InstallMotifManPage(XmStringParseText,3)
+ InstallMotifManPage(XmStringPeekNextComponent,3)
+ InstallMotifManPage(XmStringPeekNextTriple,3)
+ InstallMotifManPage(XmStringPutRendition,3)
+ InstallMotifManPage(XmStringSegmentCreate,3)
+ InstallMotifManPage(XmStringSeparatorCreate,3)
+ InstallMotifManPage(XmStringTable,3)
+ InstallMotifManPage(XmStringTableParseStringArray,3)
+ InstallMotifManPage(XmStringTableProposeTablist,3)
+ InstallMotifManPage(XmStringTableToXmString,3)
+ InstallMotifManPage(XmStringTableUnparse,3)
+ InstallMotifManPage(XmStringToXmStringTable,3)
+ InstallMotifManPage(XmStringUnparse,3)
+ InstallMotifManPage(XmStringWidth,3)
+ InstallMotifManPage(XmTab,3)
+ InstallMotifManPage(XmTabCreate,3)
+ InstallMotifManPage(XmTabFree,3)
+ InstallMotifManPage(XmTabGetValues,3)
+ InstallMotifManPage(XmTabList,3)
+ InstallMotifManPage(XmTabListCopy,3)
+ InstallMotifManPage(XmTabListFree,3)
+ InstallMotifManPage(XmTabListGetTab,3)
+ InstallMotifManPage(XmTabListInsertTabs,3)
+ InstallMotifManPage(XmTabListRemoveTabs,3)
+ InstallMotifManPage(XmTabListReplacePositions,3)
+ InstallMotifManPage(XmTabListTabCount,3)
+ InstallMotifManPage(XmTabSetValue,3)
+ InstallMotifManPage(XmTargetsAreCompatible,3)
+ InstallMotifManPage(XmText,3)
+ InstallMotifManPage(XmTextClearSelection,3)
+ InstallMotifManPage(XmTextCopy,3)
+ InstallMotifManPage(XmTextCopyLink,3)
+ InstallMotifManPage(XmTextCut,3)
+ InstallMotifManPage(XmTextDisableRedisplay,3)
+ InstallMotifManPage(XmTextEnableRedisplay,3)
+ InstallMotifManPage(XmTextField,3)
+ InstallMotifManPage(XmTextFieldClearSelection,3)
+ InstallMotifManPage(XmTextFieldCopy,3)
+ InstallMotifManPage(XmTextFieldCopyLink,3)
+ InstallMotifManPage(XmTextFieldCut,3)
+ InstallMotifManPage(XmTextFieldGetBaseline,3)
+ InstallMotifManPage(XmTextFieldGetEditable,3)
+ InstallMotifManPage(XmTextFieldGetInsertionPosition,3)
+ InstallMotifManPage(XmTextFieldGetLastPosition,3)
+ InstallMotifManPage(XmTextFieldGetMaxLength,3)
+ InstallMotifManPage(XmTextFieldGetSelection,3)
+ InstallMotifManPage(XmTextFieldGetSelectionPosition,3)
+ InstallMotifManPage(XmTextFieldGetSelectionWcs,3)
+ InstallMotifManPage(XmTextFieldGetString,3)
+ InstallMotifManPage(XmTextFieldGetStringWcs,3)
+ InstallMotifManPage(XmTextFieldGetSubstring,3)
+ InstallMotifManPage(XmTextFieldGetSubstringWcs,3)
+ InstallMotifManPage(XmTextFieldInsert,3)
+ InstallMotifManPage(XmTextFieldInsertWcs,3)
+ InstallMotifManPage(XmTextFieldPaste,3)
+ InstallMotifManPage(XmTextFieldPasteLink,3)
+ InstallMotifManPage(XmTextFieldPosToXY,3)
+ InstallMotifManPage(XmTextFieldRemove,3)
+ InstallMotifManPage(XmTextFieldReplace,3)
+ InstallMotifManPage(XmTextFieldReplaceWcs,3)
+ InstallMotifManPage(XmTextFieldSetAddMode,3)
+ InstallMotifManPage(XmTextFieldSetEditable,3)
+ InstallMotifManPage(XmTextFieldSetHighlight,3)
+ InstallMotifManPage(XmTextFieldSetInsertionPosition,3)
+ InstallMotifManPage(XmTextFieldSetMaxLength,3)
+ InstallMotifManPage(XmTextFieldSetSelection,3)
+ InstallMotifManPage(XmTextFieldSetString,3)
+ InstallMotifManPage(XmTextFieldSetStringWcs,3)
+ InstallMotifManPage(XmTextFieldShowPosition,3)
+ InstallMotifManPage(XmTextFieldXYToPos,3)
+ InstallMotifManPage(XmTextFindString,3)
+ InstallMotifManPage(XmTextFindStringWcs,3)
+ InstallMotifManPage(XmTextGetBaseline,3)
+ InstallMotifManPage(XmTextGetCenterline,3)
+ InstallMotifManPage(XmTextGetEditable,3)
+ InstallMotifManPage(XmTextGetInsertionPosition,3)
+ InstallMotifManPage(XmTextGetLastPosition,3)
+ InstallMotifManPage(XmTextGetMaxLength,3)
+ InstallMotifManPage(XmTextGetSelection,3)
+ InstallMotifManPage(XmTextGetSelectionPosition,3)
+ InstallMotifManPage(XmTextGetSelectionWcs,3)
+ InstallMotifManPage(XmTextGetSource,3)
+ InstallMotifManPage(XmTextGetString,3)
+ InstallMotifManPage(XmTextGetStringWcs,3)
+ InstallMotifManPage(XmTextGetSubstring,3)
+ InstallMotifManPage(XmTextGetSubstringWcs,3)
+ InstallMotifManPage(XmTextGetTopCharacter,3)
+ InstallMotifManPage(XmTextInsert,3)
+ InstallMotifManPage(XmTextInsertWcs,3)
+ InstallMotifManPage(XmTextPaste,3)
+ InstallMotifManPage(XmTextPasteLink,3)
+ InstallMotifManPage(XmTextPosToXY,3)
+ InstallMotifManPage(XmTextPosition,3)
+ InstallMotifManPage(XmTextRemove,3)
+ InstallMotifManPage(XmTextReplace,3)
+ InstallMotifManPage(XmTextReplaceWcs,3)
+ InstallMotifManPage(XmTextScroll,3)
+ InstallMotifManPage(XmTextSetAddMode,3)
+ InstallMotifManPage(XmTextSetEditable,3)
+ InstallMotifManPage(XmTextSetHighlight,3)
+ InstallMotifManPage(XmTextSetInsertionPosition,3)
+ InstallMotifManPage(XmTextSetMaxLength,3)
+ InstallMotifManPage(XmTextSetSelection,3)
+ InstallMotifManPage(XmTextSetSource,3)
+ InstallMotifManPage(XmTextSetString,3)
+ InstallMotifManPage(XmTextSetStringWcs,3)
+ InstallMotifManPage(XmTextSetTopCharacter,3)
+ InstallMotifManPage(XmTextShowPosition,3)
+ InstallMotifManPage(XmTextXYToPos,3)
+ InstallMotifManPage(XmToggleButton,3)
+ InstallMotifManPage(XmToggleButtonGadget,3)
+ InstallMotifManPage(XmToggleButtonGadgetGetState,3)
+ InstallMotifManPage(XmToggleButtonGadgetSetState,3)
+ InstallMotifManPage(XmToggleButtonGetState,3)
+ InstallMotifManPage(XmToggleButtonSetState,3)
+ InstallMotifManPage(XmToggleButtonSetValue,3)
+ InstallMotifManPage(XmTrackingEvent,3)
+ InstallMotifManPage(XmTrackingLocate,3)
+ InstallMotifManPage(XmTransferDone,3)
+ InstallMotifManPage(XmTransferSendRequest,3)
+ InstallMotifManPage(XmTransferSetParameters,3)
+ InstallMotifManPage(XmTransferStartRequest,3)
+ InstallMotifManPage(XmTransferValue,3)
+ InstallMotifManPage(XmTranslateKey,3)
+ InstallMotifManPage(XmUninstallImage,3)
+ InstallMotifManPage(XmUpdateDisplay,3)
+ InstallMotifManPage(XmVaCreateSimpleCheckBox,3)
+ InstallMotifManPage(XmVaCreateSimpleMenuBar,3)
+ InstallMotifManPage(XmVaCreateSimpleOptionMenu,3)
+ InstallMotifManPage(XmVaCreateSimplePopupMenu,3)
+ InstallMotifManPage(XmVaCreateSimplePulldownMenu,3)
+ InstallMotifManPage(XmVaCreateSimpleRadioBox,3)
+ InstallMotifManPage(XmWidgetGetBaselines,3)
+ InstallMotifManPage(XmWidgetGetDisplayRect,3)
*** motif.orig/doc/man/man4/Imakefile	Fri Jul  7 14:45:07 2000
--- motif/doc/man/man4/Imakefile	Wed May 10 11:03:01 2000
***************
*** 0 ****
--- 1,8 ----
+ XCOMM Imakefile
+ 
+ MANDIR = $(FILEMANDIR)
+ MANSUFFIX = $(FILEMANSUFFIX)
+ 
+ all::
+ 
+ InstallMotifManPage(mwmrc,4)
*** motif.orig/doc/man/man4/mwmrc.4	Fri Apr 28 11:05:28 2000
--- motif/doc/man/man4/mwmrc.4	Sun Jun 18 18:31:40 2000
***************
*** 49,82 ****
  .TH "mwmrc" "special file"
  .SH "NAME"
  \fBmwmrc\fP \(em the
! mwm Window Manager Resource Description File
  .SH "DESCRIPTION"
  .PP
! The \fBmwmrc\fP window manager is a supplementary resource
! file that controls much of the behavior of the CDE window manager \fBmwm\fP\&. It contains descriptions of resources that cannot easily be
  written using standard X Window System, Version 11 resource syntax\&. The resource
  description file contains entries that are referred to by X resources in
! defaults files (for example, \fB/usr/mwm/app-defaults/$LANG/mwm\fP)
  or in the \fBRESOURCE_MANAGER\fP property on the
  root window\&. For example, the resource description file enables you to specify
  different types of window menus; however, an X resource is used to specify
! which of these window menus the \fBmwm\fP should use for a particular
! window\&. The specifications of the resource description file supported by the
! mwm workspace manager are a strict superset of the specifications supported
! by the OSF Motif Window Manager (\fBmwm 1\&.2\&.4\fP)\&. In other words,
! the \fBsystem\&.mwmrc\fP or \fB$HOME/\&.mwmrc\fP file
! that you\&'ve used for \fBmwm\fP is easily made usable by \fBmwm\fP\&.
  .SS "Location"
  .PP
! The workspace manager searches for one of the following resource description
  files, where \fI$LANG\fP is the value of the language environment
  on a per-user basis:
  .PP
  .nf
  \f(CW$HOME/$LANG/\&.mwmrc
  $HOME/\&.mwmrc
! /usr/lib/X11/$LANG/system\&.mwmrc
! /usr/lib/X11/system\&.mwmrc\fR
  .fi
  .PP
  .PP
--- 49,79 ----
  .TH "mwmrc" "special file"
  .SH "NAME"
  \fBmwmrc\fP \(em the
! Motif Window Manager Resource Description File
  .SH "DESCRIPTION"
  .PP
! The \fBmwmrc\fP file is a supplementary resource
! file that controls much of the behavior of the Motif window manager \fBmwm\fP\&. 
! It contains descriptions of resources that cannot easily be
  written using standard X Window System, Version 11 resource syntax\&. The resource
  description file contains entries that are referred to by X resources in
! defaults files (for example, \fB/usr/X11R6/lib/X11/app-defaults/Mwm\fP)
  or in the \fBRESOURCE_MANAGER\fP property on the
  root window\&. For example, the resource description file enables you to specify
  different types of window menus; however, an X resource is used to specify
! which of these window menus \fBmwm\fP should use for a particular
! window\&. 
  .SS "Location"
  .PP
! The window manager searches for one of the following resource description
  files, where \fI$LANG\fP is the value of the language environment
  on a per-user basis:
  .PP
  .nf
  \f(CW$HOME/$LANG/\&.mwmrc
  $HOME/\&.mwmrc
! /usr/X11R6/lib/X11/$LANG/system\&.mwmrc
! /usr/X11R6/lib/X11/system\&.mwmrc\fR
  .fi
  .PP
  .PP
***************
*** 87,93 ****
  be specified from the command line:
  .PP
  .nf
! \f(CW/usr/mwm/bin/mwm -xrm "mwm*configFile: mymwmrc"\fR
  .fi
  .PP
  .SS "Resource Types"
--- 84,90 ----
  be specified from the command line:
  .PP
  .nf
! \f(CW/usr/X11R6/bin/X11/mwm -xrm "mwm*configFile: mymwmrc"\fR
  .fi
  .PP
  .SS "Resource Types"
***************
*** 95,103 ****
  The following types of resources can be described in the mwm resource
  description file:
  .IP "\fBButtons\fP" 10
! Workspace manager functions can be bound (associated) with button events\&.
  .IP "\fBKeys\fP" 10
! Workspace manager functions can be bound (associated) with key press
  events\&.
  .IP "\fBMenus\fP" 10
  Menu panes can be used for the window menu and other menus posted with
--- 92,100 ----
  The following types of resources can be described in the mwm resource
  description file:
  .IP "\fBButtons\fP" 10
! Window manager functions can be bound (associated) with button events\&.
  .IP "\fBKeys\fP" 10
! Window manager functions can be bound (associated) with key press
  events\&.
  .IP "\fBMenus\fP" 10
  Menu panes can be used for the window menu and other menus posted with
***************
*** 111,132 ****
  can be quoted to prevent it from being interpreted as the comment character)\&.
  A quoted item can be contained in double quotes (\fB" "\fP)\&.
  Single characters can be quoted by preceding them by the back-slash character
! (\fB\\fP), except for workspace names, which may contain no back-slash
! characters\&. If a line ends with a back-slash, the next line is considered
  a continuation of that line\&. All text from an unquoted \fB#\fP
  to the end of the line is regarded as a comment and is not interpreted as
  part of a resource description\&. If \fB!\fP is the first character
  in a line, the line is regarded as a comment\&.
! .SS "Workspace Manager Functions"
  .PP
! Workspace manager functions can be accessed with button and key bindings,
! and with workspace manager menus\&. Functions are indicated as part of the specifications
  for button and key binding sets, and menu panes\&. The function specification
  has the following syntax:
  .PP
  .nf
  \f(CW\fBfunction\fP = \fBfunction_name\fP [\fBfunction_args\fP]
! \fBfunction_name\fP = \fBworkspace manager function\fP
  \fBfunction_args\fP = {\fBquoted_item\fP | \fBunquoted_item\fP}\fR
  .fi
  .PP
--- 108,128 ----
  can be quoted to prevent it from being interpreted as the comment character)\&.
  A quoted item can be contained in double quotes (\fB" "\fP)\&.
  Single characters can be quoted by preceding them by the back-slash character
! (\fB\\\fP)\&. If a line ends with a back-slash, the next line is considered
  a continuation of that line\&. All text from an unquoted \fB#\fP
  to the end of the line is regarded as a comment and is not interpreted as
  part of a resource description\&. If \fB!\fP is the first character
  in a line, the line is regarded as a comment\&.
! .SS "Window Manager Functions"
  .PP
! Window manager functions can be accessed with button and key bindings,
! and with window manager menus\&. Functions are indicated as part of the specifications
  for button and key binding sets, and menu panes\&. The function specification
  has the following syntax:
  .PP
  .nf
  \f(CW\fBfunction\fP = \fBfunction_name\fP [\fBfunction_args\fP]
! \fBfunction_name\fP = \fBwindow manager function\fP
  \fBfunction_args\fP = {\fBquoted_item\fP | \fBunquoted_item\fP}\fR
  .fi
  .PP
***************
*** 156,165 ****
  an \fIicon\fP function argument is specified then
  the function applies only to icons\&. If an \fIwindow\fP
  function argument is specified then the function applies only to windows\&.
! .IP "\fBf\&.exec\fP \fBcommand\fP
! (or \fI!\fP \fBcommand\fP)" 10
  This function causes \fIcommand\fP to be
! executed (using the value of the \fI$MWMSHELL\fP or \fI$SHELL\fP environment variable if set; otherwise, \fB/usr/bin/sh\fP )\&. The \fI!\fP notation can be used in place of the \fBf\&.exec\fP function name\&.
  .IP "\fBf\&.focus_color\fP" 10
  This function sets the colormap focus to a client window\&. If this function
  is done in a root context, then the default colormap (setup by the X Window
--- 152,160 ----
  an \fIicon\fP function argument is specified then
  the function applies only to icons\&. If an \fIwindow\fP
  function argument is specified then the function applies only to windows\&.
! .IP "\fBf\&.exec\fP \fBcommand\fP (or \fI!\fP \fBcommand\fP)" 10
  This function causes \fIcommand\fP to be
! executed (using the value of the \fI$MWMSHELL\fP or \fI$SHELL\fP environment variable if set; otherwise, \fB/bin/sh\fP )\&. The \fI!\fP notation can be used in place of the \fBf\&.exec\fP function name\&.
  .IP "\fBf\&.focus_color\fP" 10
  This function sets the colormap focus to a client window\&. If this function
  is done in a root context, then the default colormap (setup by the X Window
***************
*** 215,221 ****
  the window with the colormap focus\&.
  .IP "\fBf\&.next_key\fP [ \fIicon\fP | \fIwindow\fP | \fItransient\fP]" 10
  This function sets the keyboard input focus to the next window/icon
! in the set of windows/icons managed by the workspace manager (the ordering
  of this set is based on the stacking of windows on the screen)\&. This function
  is treated as \fBf\&.nop\fP if \fBkeyboardFocusPolicy\fP
  is not explicit\&. The keyboard input focus is only moved to windows that do
--- 210,216 ----
  the window with the colormap focus\&.
  .IP "\fBf\&.next_key\fP [ \fIicon\fP | \fIwindow\fP | \fItransient\fP]" 10
  This function sets the keyboard input focus to the next window/icon
! in the set of windows/icons managed by the window manager (the ordering
  of this set is based on the stacking of windows on the screen)\&. This function
  is treated as \fBf\&.nop\fP if \fBkeyboardFocusPolicy\fP
  is not explicit\&. The keyboard input focus is only moved to windows that do
***************
*** 243,250 ****
  icons to be "packed" into the icon grid\&.
  .IP "\fBf\&.pass_keys\fP" 10
  This function is used to enable/disable (toggle) processing of key bindings
! for workspace manager functions\&. When it disables key binding processing all
! keys are passed on to the window with the keyboard input focus and no workspace
  manager functions are invoked\&. If the \fBf\&.pass_keys\fP function
  is invoked with a key binding to disable key binding processing the same key
  binding can be used to enable key binding processing\&.
--- 238,245 ----
  icons to be "packed" into the icon grid\&.
  .IP "\fBf\&.pass_keys\fP" 10
  This function is used to enable/disable (toggle) processing of key bindings
! for window manager functions\&. When it disables key binding processing all
! keys are passed on to the window with the keyboard input focus and no window
  manager functions are invoked\&. If the \fBf\&.pass_keys\fP function
  is invoked with a key binding to disable key binding processing the same key
  binding can be used to enable key binding processing\&.
***************
*** 259,265 ****
  for the window with the colormap focus\&.
  .IP "\fBf\&.prev_key\fP [ \fIicon\fP | \fIwindow\fP | \fItransient\fP]" 10
  This function sets the keyboard input focus to the previous window/icon
! in the set of windows/icons managed by the workspace manager (the ordering
  of this set is based on the stacking of windows on the screen)\&. This function
  is treated as \fBf\&.nop\fP if \fIkeyboardFocusPolicy\fP is not explicit\&. The keyboard input focus is only moved to windows
  that do not have an associated secondary window that is application modal\&.
--- 254,260 ----
  for the window with the colormap focus\&.
  .IP "\fBf\&.prev_key\fP [ \fIicon\fP | \fIwindow\fP | \fItransient\fP]" 10
  This function sets the keyboard input focus to the previous window/icon
! in the set of windows/icons managed by the window manager (the ordering
  of this set is based on the stacking of windows on the screen)\&. This function
  is treated as \fBf\&.nop\fP if \fIkeyboardFocusPolicy\fP is not explicit\&. The keyboard input focus is only moved to windows
  that do not have an associated secondary window that is application modal\&.
***************
*** 271,278 ****
  applies only to windows\&.
  .IP "\fBf\&.quit_mwm\fP" 10
  This function terminates mwm (but NOT the X window system)\&.
! .IP "\fBf\&.raise\fP\ [\fI-\fP\fIclient\fP | \fIwithin\fP
! | \fIfreeFamily\fP]" 10
  This function raises a primary window to the top of the global window
  stack (where it is obscured by no other window) and raises the secondary window
  (transient window or dialog box) within the client family\&. The arguments to
--- 266,272 ----
  applies only to windows\&.
  .IP "\fBf\&.quit_mwm\fP" 10
  This function terminates mwm (but NOT the X window system)\&.
! .IP "\fBf\&.raise\fP\ [\fI-\fP\fIclient\fP | \fIwithin\fP | \fIfreeFamily\fP]" 10
  This function raises a primary window to the top of the global window
  stack (where it is obscured by no other window) and raises the secondary window
  (transient window or dialog box) within the client family\&. The arguments to
***************
*** 311,317 ****
  its maximized state and raises it to the top of the window stack\&. If a normal
  window is iconified, then \fBf\&.restore_and_raise\fP restores
  it to its normalized state and raises it to the top of the window stack\&.
! .IP "2f\&.restart" 10
  This function causes mwm to be restarted (effectively terminated and
  re-executed)\&. Restart is necessary for \fBmwm\fP to incorporate
  changes in both the \fBmwmrc\fP file and X resources\&.
--- 305,311 ----
  its maximized state and raises it to the top of the window stack\&. If a normal
  window is iconified, then \fBf\&.restore_and_raise\fP restores
  it to its normalized state and raises it to the top of the window stack\&.
! .IP "\fBf\&.restart\fP" 10
  This function causes mwm to be restarted (effectively terminated and
  re-executed)\&. Restart is necessary for \fBmwm\fP to incorporate
  changes in both the \fBmwmrc\fP file and X resources\&.
***************
*** 335,347 ****
  This function causes a menu separator to be put in the menu pane at
  the specified location (the label is ignored)\&.
  .IP "\fBf\&.set_behavior\fP" 10
! This function causes the workspace manager to restart with the default
  behavior (if a custom behavior is configured) or a custom behavior (if a
  default behavior is configured)\&. By default this is bound to \fIShift\ Ctrl\ Alt\ <Key>!\fP\&.
  .IP "\fBf\&.title\fP" 10
  This function inserts a title in the menu pane at the specified location\&.
! .IP "\fIf\&.version\fP" 10
! This function causes the workspace manager to display its release version
  in a dialog box\&.
  .SS "Function Constraints"
  .PP
--- 329,341 ----
  This function causes a menu separator to be put in the menu pane at
  the specified location (the label is ignored)\&.
  .IP "\fBf\&.set_behavior\fP" 10
! This function causes the window manager to restart with the default
  behavior (if a custom behavior is configured) or a custom behavior (if a
  default behavior is configured)\&. By default this is bound to \fIShift\ Ctrl\ Alt\ <Key>!\fP\&.
  .IP "\fBf\&.title\fP" 10
  This function inserts a title in the menu pane at the specified location\&.
! .IP "\fBf\&.version\fP" 10
! This function causes the window manager to display its release version
  in a dialog box\&.
  .SS "Function Constraints"
  .PP
***************
*** 361,371 ****
  If a function is specified in a type of resource where it is not supported
  or is invoked in a context that does not apply then the function is treated
  as \fBf\&.nop\fP\&. The following table indicates the resource
! types and function contexts in which workspace manager functions apply\&.
  .TS
  tab();
  lw(2.289841i) lw(1.851594i) lw(1.358566i).
! \fIFunction\fPContextsResources
  \fBf\&.beep\fProot,icon,windowbutton,key,menu
  \fBf\&.circle_down\fProot,icon,windowbutton,key,menu
  \fBf\&.circle_up\fProot,icon,windowbutton,key,menu
--- 355,367 ----
  If a function is specified in a type of resource where it is not supported
  or is invoked in a context that does not apply then the function is treated
  as \fBf\&.nop\fP\&. The following table indicates the resource
! types and function contexts in which window manager functions apply\&.
! .PP
  .TS
  tab();
  lw(2.289841i) lw(1.851594i) lw(1.358566i).
! FunctionContextsResources
! _
  \fBf\&.beep\fProot,icon,windowbutton,key,menu
  \fBf\&.circle_down\fProot,icon,windowbutton,key,menu
  \fBf\&.circle_up\fProot,icon,windowbutton,key,menu
***************
*** 388,394 ****
  \fBf\&.post_wmenu\fProot,icon,windowbutton,key
  \fBf\&.prev_cmap\fProot,icon,windowbutton,key,menu
  \fBf\&.prev_key\fProot,icon,windowbutton,key,menu
! \fIf\&.quit_mwm\fProotbutton,key,menu (root only)
  \fBf\&.raise\fProot,icon,windowbutton,key,menu
  \fBf\&.raise_lower\fPicon,windowbutton,key,menu
  \fBf\&.refresh\fProot,icon,windowbutton,key,menu
--- 384,390 ----
  \fBf\&.post_wmenu\fProot,icon,windowbutton,key
  \fBf\&.prev_cmap\fProot,icon,windowbutton,key,menu
  \fBf\&.prev_key\fProot,icon,windowbutton,key,menu
! \fBf\&.quit_mwm\fProotbutton,key,menu (root only)
  \fBf\&.raise\fProot,icon,windowbutton,key,menu
  \fBf\&.raise_lower\fPicon,windowbutton,key,menu
  \fBf\&.refresh\fProot,icon,windowbutton,key,menu
***************
*** 402,410 ****
  \fBf\&.separator\fProot,icon,windowmenu
  \fBf\&.set_behavior\fProot,icon,windowbutton,key,menu
  \fBf\&.title\fProot,icon,windowmenu
! \fIf\&.version\fProot,icon,windowbutton,key,menu
  .TE
! .SH "WORKSPACE MANAGER EVENT SPECIFICATION"
  .PP
  Events are indicated as part of the specifications for button and key
  binding sets, and menu panes\&. Button events have the following syntax:
--- 398,406 ----
  \fBf\&.separator\fProot,icon,windowmenu
  \fBf\&.set_behavior\fProot,icon,windowbutton,key,menu
  \fBf\&.title\fProot,icon,windowmenu
! \fBf\&.version\fProot,icon,windowbutton,key,menu
  .TE
! .SH "WINDOW MANAGER EVENT SPECIFICATION"
  .PP
  Events are indicated as part of the specifications for button and key
  binding sets, and menu panes\&. Button events have the following syntax:
***************
*** 417,426 ****
--- 413,424 ----
  .PP
  The following table indicates the values that can be used for \fBmodifier_name\fP\&. Note that [Alt] and [Meta] can be used interchangably
  on some hardware\&.
+ .PP
  .TS
  tab();
  lw(1.097588i) lw(4.402412i).
  ModifierDescription
+ _
  CtrlControl Key
  ShiftShift Key
  AltAlt Key
***************
*** 438,447 ****
--- 436,447 ----
  These keys may or may not be available on your hardware: Key Symbol Caps Lock
  Shift Lock Kana Lock Num Lock Scroll Lock The following table indicates the
  values that can be used for \fBbutton_event_name\fP\&.
+ .PP
  .TS
  tab();
  lw(1.290570i) lw(4.209430i).
  ButtonDescription
+ _
  Btn1DownButton 1 Press
  Btn1UpButton 1 Release
  Btn1ClickButton 1 Press and Release
***************
*** 464,471 ****
  Btn5Click2Button 5 Double Click
  .TE
  .PP
! Key events that are used by the workspace manager for menu mnemonics
! and for binding to workspace manager functions are single key presses; key
  releases are ignored\&. Key events have the following syntax:
  .PP
  .nf
--- 464,471 ----
  Btn5Click2Button 5 Double Click
  .TE
  .PP
! Key events that are used by the window manager for menu mnemonics
! and for binding to window manager functions are single key presses; key
  releases are ignored\&. Key events have the following syntax:
  .PP
  .nf
***************
*** 482,492 ****
  .SH "BUTTON BINDINGS"
  .PP
  The \fBbuttonBindings\fP resource value is the name of
! a set of button bindings that are used to configure workspace manager behavior\&.
! A workspace manager function can be done when a button press occurs with
  the pointer over a framed client window, an icon or the root window\&. The
  context for indicating where the button press applies is also the context
! for invoking the workspace manager function when the button press is done
  (significant for functions that are context sensitive)\&. The button binding
  syntax is
  .PP
--- 482,492 ----
  .SH "BUTTON BINDINGS"
  .PP
  The \fBbuttonBindings\fP resource value is the name of
! a set of button bindings that are used to configure window manager behavior\&.
! A window manager function can be done when a button press occurs with
  the pointer over a framed client window, an icon or the root window\&. The
  context for indicating where the button press applies is also the context
! for invoking the window manager function when the button press is done
  (significant for functions that are context sensitive)\&. The button binding
  syntax is
  .PP
***************
*** 515,521 ****
  .SH "KEY BINDINGS"
  .PP
  The \fBkeyBindings\fP resource value is the name of a set
! of key bindings that are used to configure workspace manager behavior\&. A
  window manager function can be done when a particular key is pressed\&. The
  context in which the key binding applies is indicated in the key binding specification\&.
  The valid contexts are the same as those that apply to button bindings\&. The
--- 515,521 ----
  .SH "KEY BINDINGS"
  .PP
  The \fBkeyBindings\fP resource value is the name of a set
! of key bindings that are used to configure window manager behavior\&. A
  window manager function can be done when a particular key is pressed\&. The
  context in which the key binding applies is indicated in the key binding specification\&.
  The valid contexts are the same as those that apply to button bindings\&. The
***************
*** 549,555 ****
  keyboard input focus)\&.
  .SH "MENU PANES"
  .PP
! Menus can be popped up using the \fBf\&.post_wmenu\fP and \fBf\&.menu\fP workspace manager functions\&. The context for workspace manager
  functions that are done from a menu is \fIroot\fP,
  \fIicon\fP or \fIwindow\fP depending
  on how the menu was popped up\&. In the case of the \fIwindow\fP menu or menus popped up with a key binding, the location of
--- 549,555 ----
  keyboard input focus)\&.
  .SH "MENU PANES"
  .PP
! Menus can be popped up using the \fBf\&.post_wmenu\fP and \fBf\&.menu\fP window manager functions\&. The context for window manager
  functions that are done from a menu is \fIroot\fP,
  \fIicon\fP or \fIwindow\fP depending
  on how the menu was popped up\&. In the case of the \fIwindow\fP menu or menus popped up with a key binding, the location of
***************
*** 594,603 ****
  .PP
  The first matching \fBcharacter\fP in the label is underlined\&.
  If there is no matching \fBcharacter\fP in the label, no mnemonic
! is registered with the workspace manager for that label\&. Although the \fBcharacter\fP must exactly match a character in the label, the mnemonic
  does not execute if any modifier (such as Shift) is pressed with the character
  key\&. The \fBaccelerator\fP specification is a key event specification
! with the same syntax as is used for key bindings to workspace manager functions\&.
  .SH "INCLUDING FILES"
  .PP
  You may include other files into your mwmrc file by using the
--- 594,603 ----
  .PP
  The first matching \fBcharacter\fP in the label is underlined\&.
  If there is no matching \fBcharacter\fP in the label, no mnemonic
! is registered with the window manager for that label\&. Although the \fBcharacter\fP must exactly match a character in the label, the mnemonic
  does not execute if any modifier (such as Shift) is pressed with the character
  key\&. The \fBaccelerator\fP specification is a key event specification
! with the same syntax as is used for key bindings to window manager functions\&.
  .SH "INCLUDING FILES"
  .PP
  You may include other files into your mwmrc file by using the
***************
*** 623,635 ****
  is not what you expect\&.
  .SH "FILES"
  .PP
  \fB$HOME/$LANG/\&.mwmrc
  $HOME/\&.mwmrc
! /usr/lib/X11/$LANG/system\&.mwmrc
! /usr/lib/X11/system\&.mwmrc
! $HOME/\&.mwm/errorlog\fP
  .SH "RELATED INFORMATION"
  .PP
! \fBmwm\fP(1), \fBmwm(\fP1X),
  \fBX\fP(1)\&. 
  ...\" created by instant / docbook-to-man, Sun 22 Dec 1996, 20:36
--- 623,636 ----
  is not what you expect\&.
  .SH "FILES"
  .PP
+ .nf
  \fB$HOME/$LANG/\&.mwmrc
  $HOME/\&.mwmrc
! /usr/X11R6/lib/X11/$LANG/system\&.mwmrc
! /usr/X11R6/lib/X11/system\&.mwmrc\fP
! .fi
  .SH "RELATED INFORMATION"
  .PP
! \fBmwm\fP(1),
  \fBX\fP(1)\&. 
  ...\" created by instant / docbook-to-man, Sun 22 Dec 1996, 20:36
*** motif.orig/doc/man/man5/Imakefile	Fri Jul  7 14:45:07 2000
--- motif/doc/man/man5/Imakefile	Wed May 10 11:03:01 2000
***************
*** 0 ****
--- 1,10 ----
+ XCOMM Imakefile
+ 
+ MANDIR = $(MISCMANDIR)
+ MANSUFFIX = $(MISCMANSUFFIX)
+ 
+ all::
+ 
+ InstallMotifManPage(Traits,5)
+ InstallMotifManPage(UIL,5)
+ InstallMotifManPage(WML,5)
*** motif.orig/Imakefile	Fri Jul  7 14:12:30 2000
--- motif/Imakefile	Fri Jun  2 11:49:59 2000
***************
*** 40,52 ****
  #define IHaveSubdirs
  #define PassCDebugFlags CDEBUGFLAGS="$(CDEBUGFLAGS)"
  
! RELEASE = "Release 2.1.20"
  PRODUCT = "Motif"
  #if BuildMotifDemos
        DEMOSDIRECTORY = demos
  #endif
        SUBDIRS = config localized lib tools/wml clients $(DEMOSDIRECTORY) \
! 	bitmaps bindings
        CDE_SUBDIRS = lib clients/uil clients/xmbind
  
  MakeSubdirs($(SUBDIRS))
--- 40,52 ----
  #define IHaveSubdirs
  #define PassCDebugFlags CDEBUGFLAGS="$(CDEBUGFLAGS)"
  
! RELEASE = "Release 2.1.30"
  PRODUCT = "Motif"
  #if BuildMotifDemos
        DEMOSDIRECTORY = demos
  #endif
        SUBDIRS = config localized lib tools/wml clients $(DEMOSDIRECTORY) \
! 	bitmaps bindings doc/man
        CDE_SUBDIRS = lib clients/uil clients/xmbind
  
  MakeSubdirs($(SUBDIRS))
*** motif.orig/lib/Mrm/Mrmos.c	Wed May  3 05:12:38 2000
--- motif/lib/Mrm/Mrmos.c	Sat Jun  3 18:52:40 2000
***************
*** 54,59 ****
--- 54,60 ----
  #endif /* __cplusplus */
  
  #include <Xm/Xm.h>	/* For _NO_PROTO declaration. */
+ #include <MrmosI.h>
  
  /************************************************************
   *
*** motif.orig/lib/Mrm/Mrmwcrw.c	Wed May  3 05:12:38 2000
--- motif/lib/Mrm/Mrmwcrw.c	Sat Jun  3 18:53:59 2000
***************
*** 183,188 ****
--- 183,190 ----
    else if (widgetrec->variety != UilMrmAutoChildVariety)
      return Urm__UT_Error("UrmCreateWidgetInstanceCleanup", _MrmMMsg_0055,
  			 NULL, context_id, MrmBAD_WIDGET_REC);
+ 
+   return MrmSUCCESS;
  }
  
  
*** motif.orig/lib/Mrm/Mrmwcrwr.c	Wed May  3 05:12:38 2000
--- motif/lib/Mrm/Mrmwcrwr.c	Sat Jun  3 18:56:51 2000
***************
*** 692,697 ****
--- 692,698 ----
  	(context_id, sizeof(double), &offset, (char **) &dblptr) ;
        if ( result != MrmSUCCESS ) return result ;
   
+ #ifdef USE_ORIGINAL_MOTIF_CODE
        /* This is necessary for machines (such as hp9000) that require
  	 doubles to be aligned on 8 byte boundaries. */
        diff = ((long)dblptr % 8);
***************
*** 703,708 ****
--- 704,710 ----
  	  if ( result != MrmSUCCESS ) return result ;
  	}         
        dblptr = (double *)((char *)dblptr + diff);
+ #endif
         
        *dblptr = *((double *) arg_val) ;
        _MrmOSHostDoubleToIEEE(dblptr);
*** motif.orig/lib/Xm/CascadeBG.c	Wed May  3 05:12:38 2000
--- motif/lib/Xm/CascadeBG.c	Sun Jun  4 13:22:01 2000
***************
*** 74,79 ****
--- 74,80 ----
  #include "RCMenuI.h"
  #include "SyntheticI.h"
  #include "TravActI.h"
+ #include "TraversalI.h"
  #include "UniqueEvnI.h"
  
  #define CASCADE_PIX_SPACE     4	/* pixels between label and bit map */
*** motif.orig/lib/Xm/ColorObj.c	Wed May  3 05:12:39 2000
--- motif/lib/Xm/ColorObj.c	Sun Jun  4 13:23:54 2000
***************
*** 698,704 ****
      if (value != NULL)  {
          if (value[length - 1] != XmPIXEL_SET_PROP_VERSION)
  	   return False ;
! 	value[length - 1] = NULL ; /* extract version info */
  
          FetchPixelData(w, value, screen);
      }
--- 698,704 ----
      if (value != NULL)  {
          if (value[length - 1] != XmPIXEL_SET_PROP_VERSION)
  	   return False ;
! 	value[length - 1] = 0 ; /* extract version info */
  
          FetchPixelData(w, value, screen);
      }
***************
*** 1252,1260 ****
  
  
  /**********************************************************************/
! /** XmGetPixelData()                                                **/
  /**              pixelSet should be an array of num_pixelSet entries  **/
! /**              Contrary to the Xme version, use the correct display **/
  /**                                                                  **/
  /**  for instance, to access the primary background, use
               primary_background = pixelSet[primary_id].bg ;          */
--- 1252,1260 ----
  
  
  /**********************************************************************/
! /** XmeGetColorObjData()                                             **/
  /**              pixelSet should be an array of num_pixelSet entries  **/
! /**              Contrary to XmeGetPixelData, use the correct display **/
  /**                                                                  **/
  /**  for instance, to access the primary background, use
               primary_background = pixelSet[primary_id].bg ;          */
*** motif.orig/lib/Xm/Container.c	Wed May  3 05:12:39 2000
--- motif/lib/Xm/Container.c	Sun Jun  4 13:28:07 2000
***************
*** 5100,5111 ****
      c = GetContainerConstraint(focus_cwid);
  
      /* check LtoR and reduce to _COLLAPSE and _EXPAND values */
!     if ((state_to == _LEFT)
       || (state_to == _RIGHT && (LayoutIsRtoLM(cw))))
  	    new_state = XmCOLLAPSED;
      else 
-     if ((state_to == _RIGHT)
-      || (state_to == _LEFT && (LayoutIsRtoLM(cw))))
  	    new_state = XmEXPANDED;
  
      /* check if there is anything to do */
--- 5100,5110 ----
      c = GetContainerConstraint(focus_cwid);
  
      /* check LtoR and reduce to _COLLAPSE and _EXPAND values */
!     if ((state_to == _COLLAPSE)
!      || (state_to == _LEFT && (! LayoutIsRtoLM(cw)))
       || (state_to == _RIGHT && (LayoutIsRtoLM(cw))))
  	    new_state = XmCOLLAPSED;
      else 
  	    new_state = XmEXPANDED;
  
      /* check if there is anything to do */
***************
*** 7208,7218 ****
  		{
  		  /* CR 8400 - clicking on selected item should
  		     unselect in SINGLE mode */
! 		  if (current_cwid 
  		      && current_cwid == cw->container.anchor_cwid &&
  		      cw->container.selection_state == XmSELECTED) {
  		    /* Unselect if clicking on a selected item */
- 		    c = GetContainerConstraint(current_cwid);
  		    cw->container.selection_state = XmNOT_SELECTED;
  		    MarkCwid(current_cwid,False);
  		    cw->container.anchor_cwid = NULL;
--- 7207,7224 ----
  		{
  		  /* CR 8400 - clicking on selected item should
  		     unselect in SINGLE mode */
! 
! 		  /* Fix by Metro Link.
! 		     First, get the constraints if current_cwid is valid. */
! 		  if (current_cwid)
! 		    c = GetContainerConstraint(current_cwid);
! 		  
! 		  /* Now check to see if the *item* is selected. */
! 		  if (current_cwid
  		      && current_cwid == cw->container.anchor_cwid &&
+ 		      c->selection_visual == XmSELECTED &&
  		      cw->container.selection_state == XmSELECTED) {
  		    /* Unselect if clicking on a selected item */
  		    cw->container.selection_state = XmNOT_SELECTED;
  		    MarkCwid(current_cwid,False);
  		    cw->container.anchor_cwid = NULL;
*** motif.orig/lib/Xm/CutPaste.c	Wed May  3 05:12:39 2000
--- motif/lib/Xm/CutPaste.c	Sun Jun  4 13:28:25 2000
***************
*** 1346,1352 ****
  	case 1: item = XmS_MOTIF_CLIP_NEXT_ID;
  	    break;
  	default:
!     	    sprintf( atomname, "_MOTIF_CLIP_ITEM_%d", itemid );
      	    item = atomname;
  	    break;	
      }
--- 1346,1352 ----
  	case 1: item = XmS_MOTIF_CLIP_NEXT_ID;
  	    break;
  	default:
!     	    sprintf( atomname, "_MOTIF_CLIP_ITEM_%ld", itemid );
      	    item = atomname;
  	    break;	
      }
*** motif.orig/lib/Xm/DrawingA.c	Wed May  3 05:12:39 2000
--- motif/lib/Xm/DrawingA.c	Sun Jun  4 13:45:12 2000
***************
*** 379,385 ****
  	widget = cw->composite.children[i];
  
  	/* do not care for gadget only for the DA input */
! 	if (XtIsManaged (widget)) {
  	    if (x >= widget->core.x && y >= widget->core.y && 
  		x < widget->core.x + widget->core.width    && 
  		y < widget->core.y + widget->core.height)
--- 379,385 ----
  	widget = cw->composite.children[i];
  
  	/* do not care for gadget only for the DA input */
! 	if (XmIsGadget(widget) && XtIsManaged (widget)) {
  	    if (x >= widget->core.x && y >= widget->core.y && 
  		x < widget->core.x + widget->core.width    && 
  		y < widget->core.y + widget->core.height)
*** motif.orig/lib/Xm/DrawnB.c	Wed May  3 05:12:39 2000
--- motif/lib/Xm/DrawnB.c	Sun Jun  4 13:46:31 2000
***************
*** 61,70 ****
--- 61,73 ----
  #include "XmI.h"
  #include "RepTypeI.h"
  #include "LabelI.h"
+ #include "MenuUtilI.h"
  #include "MenuProcI.h"
+ #include "MenuStateI.h"
  #include "PrimitiveI.h"
  #include "TravActI.h"
  #include "TraversalI.h"
+ #include "UniqueEvnI.h"
  
  
  #define DELAY_DEFAULT 100	
*** motif.orig/lib/Xm/DropSMgr.c	Wed May  3 05:12:39 2000
--- motif/lib/Xm/DropSMgr.c	Sun Jun  4 13:48:43 2000
***************
*** 518,523 ****
--- 518,524 ----
  	dsm->dropManager.rootW = dsm->dropManager.rootH = ~0;
  	dsm->dropManager.clipperList = NULL;
  	dsm->dropManager.updateInfo = NULL;
+ 	dsm->dropManager.updateTimeOutId = 0;
  
  	/* Patch around broken Xt interfaces */
  	XtGetSubresources(nw, info, NULL, NULL, _XmDSResources,
***************
*** 530,535 ****
--- 531,539 ----
  {
  	XmDropSiteManagerObject	dsm = (XmDropSiteManagerObject)w;
  
+ 	if (dsm->dropManager.updateTimeOutId)
+ 	    XtRemoveTimeOut(dsm->dropManager.updateTimeOutId);
+ 	
  	DSMDestroyTable(dsm);
  	_XmRegionDestroy(dsm->dropManager.curAncestorClipRegion);
  	_XmRegionDestroy(dsm->dropManager.newAncestorClipRegion);
***************
*** 3908,3915 ****
  
    /* We don't add a timeout if the record is already marked for update */
    if (clean) {
!     XtAppAddTimeOut(XtWidgetToApplicationContext(shell), 0,
! 		    _XmIEndUpdate, dsm);
    }
  }
  
--- 3912,3920 ----
  
    /* We don't add a timeout if the record is already marked for update */
    if (clean) {
!     dsm -> dropManager.updateTimeOutId =
!       XtAppAddTimeOut(XtWidgetToApplicationContext(shell), 0,
! 		      _XmIEndUpdate, dsm);
    }
  }
  
***************
*** 3922,3927 ****
--- 3927,3939 ----
    Widget shell;
    XmDSInfo shellInfo;
  
+   /* Remove timeout if this is a forced update */
+   if (dsm -> dropManager.updateTimeOutId) {
+     if (interval_id == NULL)
+       XtRemoveTimeOut(dsm -> dropManager.updateTimeOutId);
+     dsm -> dropManager.updateTimeOutId = 0;
+   }
+   
    /* Return if all updates have already happened */
    while(dsm -> dropManager.updateInfo != NULL) {
      dsupdate = (_XmDropSiteUpdateInfo) dsm -> dropManager.updateInfo;
*** motif.orig/lib/Xm/DropSMgrP.h	Wed May  3 05:12:39 2000
--- motif/lib/Xm/DropSMgrP.h	Sun Jun  4 13:49:11 2000
***************
*** 274,279 ****
--- 274,280 ----
      Dimension		rootW, rootH;
      XtPointer		clipperList;
      _XmDropSiteUpdateInfo	updateInfo;
+     XtIntervalId	updateTimeOutId;
  } XmDropSiteManagerPart, *XmDropSiteManagerPartPtr;
  
  /* Full instance record declaration */
*** motif.orig/lib/Xm/Gadget.c	Wed May  3 05:12:40 2000
--- motif/lib/Xm/Gadget.c	Sun Jun  4 13:49:31 2000
***************
*** 66,71 ****
--- 66,72 ----
  #include "ResIndI.h"
  #include "RepTypeI.h"
  #include "SyntheticI.h"
+ #include "TraitI.h"
  #include "TraversalI.h"
  
  
*** motif.orig/lib/Xm/IconFile.c	Wed May  3 05:12:40 2000
--- motif/lib/Xm/IconFile.c	Sun Jun  4 14:12:22 2000
***************
*** 51,57 ****
  */
  
  #include <stdio.h>
! #include <locale.h>
  #include <X11/Xos.h>
  #include <Xm/IconFileP.h>
  #include <Xm/ColorObjP.h>
--- 51,57 ----
  */
  
  #include <stdio.h>
! #include <X11/Xlocale.h>
  #include <X11/Xos.h>
  #include <Xm/IconFileP.h>
  #include <Xm/ColorObjP.h>
***************
*** 102,108 ****
  /**************** Icon PATH defines ********/
  
  
! static XmConst char ABSOLUTE_IPATH[] = "19 Oct 1995B";
  static XmConst char ABSOLUTE_PATH[] = "\
  %P\
  %S";
--- 102,108 ----
  /**************** Icon PATH defines ********/
  
  
! static XmConst char ABSOLUTE_IPATH[] = "%H%B";
  static XmConst char ABSOLUTE_PATH[] = "\
  %P\
  %S";
***************
*** 184,205 ****
      else {
  	int	bufLen, oldBufLen = 0;
  	char	stackBuf[MAX_CACHE_DIR_SIZE];
  	int	numFiles = 0;
  	int	nameHeapSize = 0;
  	_Xreaddirparams dirEntryBuf;
  
          cachedDirType = DtVALID_CACHED_DIR;
  	while ((currDirect = _XReaddir(fileDesc, dirEntryBuf)) != NULL) {
! 	  bufLen = currDirect->d_reclen;
! 	  if (bufLen + oldBufLen >= MAX_CACHE_DIR_SIZE) {
  	    /*
  	     * don't cache this one
  	     */
  	    cachedDirType = DtUNCACHED_DIR;
  	    break;
  	  } else {
! 	    (void) memcpy(&(stackBuf[oldBufLen]), (void *)currDirect, bufLen);
  	    oldBufLen += bufLen;
  	  }
  	}
  	if (oldBufLen == 0) {
--- 184,211 ----
      else {
  	int	bufLen, oldBufLen = 0;
  	char	stackBuf[MAX_CACHE_DIR_SIZE];
+ 	char    *p;
  	int	numFiles = 0;
  	int	nameHeapSize = 0;
  	_Xreaddirparams dirEntryBuf;
  
+         /* 
+          * Original code was caching each struct direct in stackBuf.
+          * Instead, just cache currDirect->d_name, null-terminated.
+          */
          cachedDirType = DtVALID_CACHED_DIR;
  	while ((currDirect = _XReaddir(fileDesc, dirEntryBuf)) != NULL) {
! 	  bufLen = strlen(currDirect->d_name);
! 	  if (bufLen + oldBufLen + 1 >= MAX_CACHE_DIR_SIZE) {
  	    /*
  	     * don't cache this one
  	     */
  	    cachedDirType = DtUNCACHED_DIR;
  	    break;
  	  } else {
! 	    (void) memcpy(&(stackBuf[oldBufLen]), currDirect->d_name, bufLen);
  	    oldBufLen += bufLen;
+             stackBuf[oldBufLen++] = '\0';
  	  }
  	}
  	if (oldBufLen == 0) {
***************
*** 213,225 ****
  	    String		nameHeap;
  	    Cardinal		i;
  
! 	    for (currDirect = (struct dirent *)stackBuf;
! 		 ((char *)currDirect - stackBuf) < oldBufLen;
! 		 currDirect = (struct dirent *) 
! 		 (((char *)currDirect) + currDirect->d_reclen)) {
  
  		numFiles++;
! 		nameHeapSize += strlen (currDirect->d_name);
  	    }
  	    /*
  	     * we allocate an extra nameOffset to track the length of
--- 219,233 ----
  	    String		nameHeap;
  	    Cardinal		i;
  
!             /*
!              * Go through stackBuf and count the length of all
!              * the names.  Don't count the nulls.
!              */
!             for (p = stackBuf ; p - stackBuf < oldBufLen;
! 		 p = p + strlen(p) + 1) {
  
  		numFiles++;
! 		nameHeapSize += strlen(p);
  	    }
  	    /*
  	     * we allocate an extra nameOffset to track the length of
***************
*** 240,256 ****
  	    nameHeap = (String)
  	      &(validDir->nameOffsets[numFiles + 1]);
  
! 	    for (i = 0, currDirect = (struct dirent *)stackBuf;
! 		 i < validDir->numFiles;
! 		 i++,
! 		 currDirect = (struct dirent *) 
! 		 (((char *)currDirect) + currDirect->d_reclen)) {
! 
! 		validDir->nameOffsets[i + 1] = 
! 		  validDir->nameOffsets[i] + strlen (currDirect->d_name);
! 		memcpy(&(nameHeap[validDir->nameOffsets[i]]),
! 		       &(currDirect->d_name[0]),
! 		       strlen (currDirect->d_name));
  	    }
            cachedDir = (DtCachedDir)validDir ;
  	}
--- 248,260 ----
  	    nameHeap = (String)
  	      &(validDir->nameOffsets[numFiles + 1]);
  
!             /* Copy the strings from stackBuf to nameHeap.  Omit the nulls. */
!             for (i = 0, p = stackBuf; i < validDir->numFiles;
!                  i++, p = p + strlen(p) + 1) {
! 
! 		validDir->nameOffsets[i + 1] =
! 		  validDir->nameOffsets[i] + strlen(p);
! 		memcpy(&(nameHeap[validDir->nameOffsets[i]]), p, strlen(p));
  	    }
            cachedDir = (DtCachedDir)validDir ;
  	}
***************
*** 443,452 ****
--- 447,467 ----
    if (MB_CUR_MAX == 1) {
        return strchr(str, '/');
    } else {
+ #ifndef NO_MULTIBYTE
        while ((n = mblen(str, MB_CUR_MAX)) >0) {
+ #else
+       if (!str) return NULL;
+       while ((n = *str ? 1 : 0) > 0) {
+ #endif
+ #ifndef NO_MULTIBYTE
          if (n == 1 && *str == '/')
              return str;
          str += n;
+ #else
+ 	if (*str == '/')
+ 	    return str;
+ 	str++;
+ #endif
        }
        return NULL;
    }
***************
*** 578,584 ****
  
      /* generate the icon paths once per application: iconPath and bmPath */
      if (!iconNameCache) {
- 	String 		tmpPath;
  	Boolean		junkBoolean;
  
  	iconNameCache =  _XmAllocHashTable(100, 
--- 593,598 ----
***************
*** 592,604 ****
  	strcpy(stackString, homedir) ;
  
  	if (useColor) {
! 	    tmpPath = getenv("XMICONSEARCHPATH");
  	}
  	else {
! 	    tmpPath = getenv("XMICONBMSEARCHPATH");
  	}
- 	if (tmpPath) iconPath = XtNewString(tmpPath);
- 	else iconPath = XtNewString(ABSOLUTE_IPATH);
  
  	/* 1.2 path as a fallback */
  	bmPath = _XmOSInitPath(NULL, "XBMLANGPATH", &junkBoolean);
--- 606,616 ----
  	strcpy(stackString, homedir) ;
  
  	if (useColor) {
! 	    iconPath = _XmOSInitPath(NULL, "XMICONSEARCHPATH", &junkBoolean);
  	}
  	else {
! 	    iconPath = _XmOSInitPath(NULL, "XMICONBMSEARCHPATH", &junkBoolean);
  	}
  
  	/* 1.2 path as a fallback */
  	bmPath = _XmOSInitPath(NULL, "XBMLANGPATH", &junkBoolean);
*** motif.orig/lib/Xm/ImageCache.c	Wed May  3 05:12:40 2000
--- motif/lib/Xm/ImageCache.c	Fri Jun  9 13:14:46 2000
***************
*** 691,696 ****
--- 691,697 ----
      Boolean useIconFileCache;
      Boolean useMask;
      Boolean useColor;
+     int xpmStatus;
  
      /* init so that we can call safely XpmFreeAttributes. */
      attrib.valuemask = 0;
***************
*** 788,798 ****
  
      *image = NULL ;
  
!     if (XmeXpmReadFileToImage(display,
  			      file_name,
  			      image,
  			      &mask_image,
! 			      &attrib) < 0)
  	*image = NULL ;
      else {
  	/* store allocated colors */
--- 789,800 ----
  
      *image = NULL ;
  
!     xpmStatus = XmeXpmReadFileToImage(display,
  			      file_name,
  			      image,
  			      &mask_image,
! 			      &attrib);
!     if (xpmStatus < 0)
  	*image = NULL ;
      else {
  	/* store allocated colors */
***************
*** 840,845 ****
--- 842,852 ----
  		acc_color->bottom_shadow_color= XmUNSPECIFIED_PIXEL;
  		acc_color->select_color = XmUNSPECIFIED_PIXEL;
  		acc_color->highlight_color = XmUNSPECIFIED_PIXEL;
+ 		if (acc_color->foreground == XmUNSPECIFIED_PIXEL
+ 		    && acc_color->background == XmUNSPECIFIED_PIXEL) {
+ 		    acc_color->foreground = 1;
+ 		    acc_color->background = 0;
+ 		}
  	    } else {
  
  		/* we've loaded a xpm, check which symbolics
***************
*** 886,902 ****
  	   for we don't want to keep them in the image
  	   cache, since they need color lookup,
  	   which is done one level up in the pixmap cache */
! 	if ((*image)->depth == 1) {
  	    _XmInstallImage (*image, image_name, hot_x, hot_y);
  	    return TRUE ;
  	} else {
! 	    XmeXpmFreeAttributes(&attrib);
  	    return NOT_CACHED ; /* mean the image can be destroyed
  				   after it is used */
  	}
      }
      
!     XmeXpmFreeAttributes(&attrib);
  
      return FALSE ;
  } 
--- 893,914 ----
  	   for we don't want to keep them in the image
  	   cache, since they need color lookup,
  	   which is done one level up in the pixmap cache */
! 	if (((*image)->depth == 1)
! 	    && (acc_color->foreground == 1)
! 	    && (acc_color->background == 0)
! 	    ) {
  	    _XmInstallImage (*image, image_name, hot_x, hot_y);
  	    return TRUE ;
  	} else {
! 	    if (xpmStatus >= 0)
! 		XmeXpmFreeAttributes(&attrib);
  	    return NOT_CACHED ; /* mean the image can be destroyed
  				   after it is used */
  	}
      }
      
!     if (xpmStatus >= 0)
! 	XmeXpmFreeAttributes(&attrib);
  
      return FALSE ;
  } 
***************
*** 1333,1338 ****
--- 1345,1362 ----
         only handle unequal depths for bitmaps. */
      if ((image->depth != depth) && (image->depth != 1))
  	return (XmUNSPECIFIED_PIXMAP);
+ 
+     /* force the foreground/background if a Bitmap
+        is returned. These values are going to go in the cache
+        too, so we will have to remember this forcing for the
+        case -depth: you ask for -depth and some 
+        foreground/background, that should match a depth 1
+        with 1/0. Look at ComparePixmapDatas above for details */
+ 
+     if (depth == 1) {
+ 	acc_color->foreground = 1;
+ 	acc_color->background = 0;
+     }
  
      /* XPutImage will only deepen bitmaps -- fake it with pixmaps. */
      old_image_format = image->format;
*** motif.orig/lib/Xm/Imakefile	Wed May  3 05:12:40 2000
--- motif/lib/Xm/Imakefile	Fri Jun  2 11:55:19 2000
***************
*** 72,78 ****
  
      LINTLIBS = $(LINTXLIB) $(LINTXTOOL)
  
!      DEFINES = XmDefines
  SRCH_DEFINES = -DLIBDIR=\"$(XPROJECTROOT)/lib/X11\" -DINCDIR=\"$(XPROJECTROOT)/include/X11\"
  BINDINGS_DEF = -DXMBINDDIR_FALLBACK=\"VirtualBindingsPath\"
  STRINGSABIOPTIONS = ToolkitStringsABIOptions
--- 72,78 ----
  
      LINTLIBS = $(LINTXLIB) $(LINTXTOOL)
  
!      DEFINES = XmDefines StrcasecmpDefines
  SRCH_DEFINES = -DLIBDIR=\"$(XPROJECTROOT)/lib/X11\" -DINCDIR=\"$(XPROJECTROOT)/include/X11\"
  BINDINGS_DEF = -DXMBINDDIR_FALLBACK=\"VirtualBindingsPath\"
  STRINGSABIOPTIONS = ToolkitStringsABIOptions
*** motif.orig/lib/Xm/List.c	Wed May  3 05:12:40 2000
--- motif/lib/Xm/List.c	Sun Jun  4 14:50:10 2000
***************
*** 2801,2807 ****
    if ((!lw->list.Mom) ||
        (!lw->list.vScrollBar) ||
        (lw->list.FromSetSB))
!     return;
  
  
    lw->list.FromSetSB = TRUE;
--- 2801,2807 ----
    if ((!lw->list.Mom) ||
        (!lw->list.vScrollBar) ||
        (lw->list.FromSetSB))
!     return False;
  
  
    lw->list.FromSetSB = TRUE;
***************
*** 2885,2891 ****
    if ((!lw->list.Mom) ||
        (!lw->list.hScrollBar) ||
        (lw->list.FromSetSB))
!     return;
  
    lw->list.FromSetSB = TRUE;
  
--- 2885,2891 ----
    if ((!lw->list.Mom) ||
        (!lw->list.hScrollBar) ||
        (lw->list.FromSetSB))
!     return False;
  
    lw->list.FromSetSB = TRUE;
  
*** motif.orig/lib/Xm/Manager.c	Wed May  3 05:12:40 2000
--- motif/lib/Xm/Manager.c	Sun Jun  4 14:50:33 2000
***************
*** 64,69 ****
--- 64,70 ----
  #include "ResConverI.h"
  #include "ResIndI.h"
  #include "SyntheticI.h"
+ #include "TraitI.h"
  #include "TravActI.h"
  #include "TraversalI.h"
  #include "UniqueEvnI.h"
*** motif.orig/lib/Xm/MenuShell.c	Wed May  3 05:12:40 2000
--- motif/lib/Xm/MenuShell.c	Sun Jun  4 14:57:40 2000
***************
*** 627,632 ****
--- 627,636 ----
  
      ms->menu_shell.label_font_list = XmFontListCopy (defaultFont);   
  
+     if(ms->menu_shell.default_font_list != NULL)
+         ms->menu_shell.default_font_list =
+             XmFontListCopy(ms->menu_shell.default_font_list);   
+ 
      _XmSetSwallowEventHandler((Widget) ms, True);
  
      /*
***************
*** 2225,2230 ****
--- 2229,2236 ----
  {
      XmMenuShellWidget ms = (XmMenuShellWidget) wid ;
      _XmDestroyFocusData(ms->menu_shell.focus_data);
+     if (ms->menu_shell.default_font_list != NULL) 
+        XmFontListFree (ms->menu_shell.default_font_list);
  
      if (ms->menu_shell.button_font_list != NULL) 
         XmFontListFree (ms->menu_shell.button_font_list);
*** motif.orig/lib/Xm/MenuT.h	Wed May  3 05:12:40 2000
--- motif/lib/Xm/MenuT.h	Sun Jun  4 15:08:22 2000
***************
*** 47,52 ****
--- 47,57 ----
  extern "C" {
  #endif
  
+ /* Quick fix for Linux-ARM where "arm" is the #define symbol */
+ #ifdef arm
+ # undef arm
+ #endif
+ 
  /* Menu System Traits */
  externalref XrmQuark XmQTmenuSystem;
  externalref XrmQuark XmQTmenuSavvy;
*** motif.orig/lib/Xm/MessageB.c	Wed May  3 05:12:40 2000
--- motif/lib/Xm/MessageB.c	Sun Jun  4 15:10:56 2000
***************
*** 678,686 ****
          } 
  
      /* Over-ride BBoard to disallow a direct change of button id's
      */
!     if ( current->bulletin_board.cancel_button
!                                         != new_w->bulletin_board.cancel_button) {
          new_w->bulletin_board.cancel_button 
                                         = current->bulletin_board.cancel_button;
          XmeWarning( (Widget) new_w, WARNING5);
--- 678,690 ----
          } 
  
      /* Over-ride BBoard to disallow a direct change of button id's
+      * unless it's a template dialog.  For those, if you can't set it
+      * here then you can never set it.
      */
!     if ( ( current->message_box.dialog_type != XmDIALOG_TEMPLATE ) &&
!          ( current->bulletin_board.cancel_button !=
!                                         new_w->bulletin_board.cancel_button ) )
!     {
          new_w->bulletin_board.cancel_button 
                                         = current->bulletin_board.cancel_button;
          XmeWarning( (Widget) new_w, WARNING5);
*** motif.orig/lib/Xm/Obso2_0.c	Wed May  3 05:12:41 2000
--- motif/lib/Xm/Obso2_0.c	Sun Jun  4 15:12:09 2000
***************
*** 2129,2135 ****
    if (!a && !b) return(TRUE);
    if (!a || !b) return(FALSE);
  
!   return(XmStringCompare(a, b));
  }
  
  Dimension 
--- 2129,2135 ----
    if (!a && !b) return(TRUE);
    if (!a || !b) return(FALSE);
  
!   return(XmStringByteCompare(a, b));
  }
  
  Dimension 
*** motif.orig/lib/Xm/PixConv.c	Wed May  3 05:12:41 2000
--- motif/lib/Xm/PixConv.c	Sun Jun  4 15:16:33 2000
***************
*** 357,367 ****
     
     /* if PIXMAP forced, force depth to be positive, meaning
        always a pixmap even if xbm specified */
     /* this is mainly for backgroundPixmap */
     /* if the resource name was available in the converter, I could
        give it to GetColorInfo and have the class decide.. Xt problem */
  
!    if ((depth < 0) && 
         ((converter_type == CONVERT_PIXMAP) ||
  	(_XmGetBitmapConversionModel(screen) == XmMATCH_DEPTH)))
         depth = - depth ;
--- 357,370 ----
     
     /* if PIXMAP forced, force depth to be positive, meaning
        always a pixmap even if xbm specified */
+    /* ...as long as the foreground color is not XmUNSPECIFIED_PIXEL.
+       Otherwise, the pixmap gets created with a bogus foreground color.
+       (Metro Link fix) */
     /* this is mainly for backgroundPixmap */
     /* if the resource name was available in the converter, I could
        give it to GetColorInfo and have the class decide.. Xt problem */
  
!    if ((depth < 0) && (acc_color_rec.foreground != XmUNSPECIFIED_PIXEL) &&
         ((converter_type == CONVERT_PIXMAP) ||
  	(_XmGetBitmapConversionModel(screen) == XmMATCH_DEPTH)))
         depth = - depth ;
*** motif.orig/lib/Xm/Primitive.c	Wed May  3 05:12:41 2000
--- motif/lib/Xm/Primitive.c	Sun Jun  4 15:16:48 2000
***************
*** 64,69 ****
--- 64,70 ----
  #include "ResConverI.h"
  #include "ResIndI.h"
  #include "SyntheticI.h"
+ #include "TraitI.h"
  #include "TravActI.h"
  #include "TraversalI.h"
  #include "UniqueEvnI.h"
*** motif.orig/lib/Xm/PrintS.c	Fri Apr 28 11:05:22 2000
--- motif/lib/Xm/PrintS.c	Sun Jun  4 15:17:08 2000
***************
*** 12,17 ****
--- 12,19 ----
  #include <Xm/PrintSP.h>
  #include "ImageCachI.h"
  #include "SyntheticI.h"
+ #include <stdlib.h>
+ #include <unistd.h>
  
  /********    Static Function Declarations    ********/
  
*** motif.orig/lib/Xm/PushB.c	Wed May  3 05:12:41 2000
--- motif/lib/Xm/PushB.c	Sun Jun  4 15:17:23 2000
***************
*** 65,70 ****
--- 65,71 ----
  #include "LabelI.h"
  #include "MenuProcI.h"
  #include "MenuStateI.h"
+ #include "MenuUtilI.h"
  #include "PrimitiveI.h"
  #include "TravActI.h"
  #include "TraversalI.h"
*** motif.orig/lib/Xm/PushBG.c	Wed May  3 05:12:41 2000
--- motif/lib/Xm/PushBG.c	Sun Jun  4 15:17:39 2000
***************
*** 69,74 ****
--- 69,75 ----
  #include "LabelGI.h"
  #include "MenuProcI.h"
  #include "MenuStateI.h"
+ #include "MenuUtilI.h"
  #include "SyntheticI.h"
  #include "TravActI.h"
  #include "TraversalI.h"
*** motif.orig/lib/Xm/RCLayout.c	Wed May  3 05:12:41 2000
--- motif/lib/Xm/RCLayout.c	Sun Jun  4 15:18:22 2000
***************
*** 1919,1925 ****
       _XmProcessUnlock();
       (*resize) ((Widget) instigator); 
     }
!    XtFree ( (char *) RC_Boxes(m));
  }
  
  
--- 1919,1930 ----
       _XmProcessUnlock();
       (*resize) ((Widget) instigator); 
     }
!    /* Patch submitted by Kevin B. Hendrix of Java-Linux project. */
!    if (RC_Boxes(m))
!    {
!      XtFree ( (char *) RC_Boxes(m));
!      RC_Boxes(m) = NULL;
!    }
  }
  
  
*** motif.orig/lib/Xm/regexp.c	Fri Apr 28 11:05:22 2000
--- motif/lib/Xm/regexp.c	Sun Jun  4 13:18:24 2000
***************
*** 928,934 ****
  _XmRegexec(XmRegexpRec *prog, char *string)
  {
  	register char	*s;
- 	extern char	*strchr();
  
  	/* Be paranoid... */
  	if (prog == NULL || string == NULL) {
--- 928,933 ----
*** motif.orig/lib/Xm/ResConvert.c	Wed May  3 05:12:42 2000
--- motif/lib/Xm/ResConvert.c	Sun Jun  4 15:18:39 2000
***************
*** 1287,1294 ****
--- 1287,1298 ----
           else
           {
  	    if (MB_CUR_MAX > 1) {
+ #ifndef NO_MULTIBYTE
  	      if ((csize = mblen(*s, MB_CUR_MAX)) < 0)
  	        break;
+ #else
+ 	      csize = **s ? 1 : 0;
+ #endif
  	      strncpy(tmp, *s, csize);
  	      tmp += csize;
  	      (*s) += csize;
***************
*** 1440,1447 ****
--- 1444,1455 ----
              if(    *p == '\\' && *(p + 1) == ','    )
              {   p++ ;
                  } 
+ #ifndef NO_MULTIBYTE
  	    if((csize = mblen(p, MB_CUR_MAX)) < 0)
   	      break;
+ #else
+ 	    csize = *p ? 1 : 0;
+ #endif
              } 
          if(    i == size    )
          {   
*** motif.orig/lib/Xm/Scale.c	Fri Jul  7 14:13:09 2000
--- motif/lib/Xm/Scale.c	Sun Jun  4 15:20:20 2000
***************
*** 62,68 ****
   */
  # include <langinfo.h>
  # if defined(linux) && !defined(RADIXCHAR)
! #  define RADIXCHAR MON_DECIMAL_POINT
  # endif
  # ifdef X_LOCALE
  #  ifdef linux
--- 62,68 ----
   */
  # include <langinfo.h>
  # if defined(linux) && !defined(RADIXCHAR)
! #  define RADIXCHAR DECIMAL_POINT
  # endif
  # ifdef X_LOCALE
  #  ifdef linux
*** motif.orig/lib/Xm/Screen.c	Wed May  3 05:12:42 2000
--- motif/lib/Xm/Screen.c	Sun Jun  4 15:20:40 2000
***************
*** 52,57 ****
--- 52,58 ----
  #include <Xm/DisplayP.h>
  #include "DragIconI.h"
  #include "HashI.h"
+ #include "ImageCachI.h"
  #include "MessagesI.h"
  #include "RepTypeI.h"
  #include "ScreenI.h"
*** motif.orig/lib/Xm/ScrolledW.c	Wed May  3 05:12:42 2000
--- motif/lib/Xm/ScrolledW.c	Sun Jun  4 15:21:39 2000
***************
*** 1470,1476 ****
  DeleteChild(
          Widget child )
  {
!     XmScrolledWindowWidget sw = (XmScrolledWindowWidget) XtParent(child);
      XtWidgetProc      delete_child;
      
      if (child == sw->swindow.WorkWindow)
--- 1470,1477 ----
  DeleteChild(
          Widget child )
  {
!     Widget swWid = XtParent(child);
!     XmScrolledWindowWidget sw = (XmScrolledWindowWidget) swWid;
      XtWidgetProc      delete_child;
      
      if (child == sw->swindow.WorkWindow)
***************
*** 1480,1485 ****
--- 1481,1490 ----
          sw->swindow.hScrollBar = NULL;
      if (child == (Widget) sw->swindow.vScrollBar)
          sw->swindow.vScrollBar = NULL;
+ 
+     /* Clean up the Navigator.  Metro Link fix, suggested by
+      * Kevin B. Hendricks of Java-Linux project. */
+     RemoveNavigator(swWid, child);
  
      _XmProcessLock();
      delete_child = 
*** motif.orig/lib/Xm/SpinB.c	Wed May  3 05:12:42 2000
--- motif/lib/Xm/SpinB.c	Sun Jun  4 15:22:15 2000
***************
*** 1357,1363 ****
  
  /******************************************************************************
   * SpinBNext
!  *	Action for DownArrow Key.
   *****************************************************************************/
  
  /*ARGSUSED*/
--- 1357,1363 ----
  
  /******************************************************************************
   * SpinBNext
!  *	Action for UpArrow Key.
   *****************************************************************************/
  
  /*ARGSUSED*/
***************
*** 1372,1378 ****
  
  /******************************************************************************
   * SpinBPrior
!  *	Action for UpArrow Key.
   *****************************************************************************/
  
  /*ARGSUSED*/
--- 1372,1378 ----
  
  /******************************************************************************
   * SpinBPrior
!  *	Action for DownArrow Key.
   *****************************************************************************/
  
  /*ARGSUSED*/
*** motif.orig/lib/Xm/Text.c	Wed May  3 05:12:42 2000
--- motif/lib/Xm/Text.c	Sun Jun  4 15:22:39 2000
***************
*** 1625,1632 ****
--- 1625,1636 ----
        }
      } else {
        while (length--) {
+ #ifndef NO_MULTIBYTE
  	char_size = mblen(ptr, tw->text.char_size);
  	if (char_size < 0) break; /* error */
+ #else
+ 	char_size = *ptr ? 1 : 0;
+ #endif
  	cur_start++;
  	if (char_size == 1 && *ptr == '\012') {
  	  ptr++;
***************
*** 2941,2947 ****
--- 2945,2953 ----
    if (num_count_bytes <= 0)
      return 0;
    
+ #ifndef NO_MULTIBYTE
    if (MB_CUR_MAX == 1 || MB_CUR_MAX == 0) /* Sun sets MB_CUR_MAX to 0, Argg!!*/
+ #endif
      return num_count_bytes;
    
    for (bptr = str; num_count_bytes > 0; count++, bptr+= char_size) {
*** motif.orig/lib/Xm/TextF.c	Fri Jul  7 14:13:10 2000
--- motif/lib/Xm/TextF.c	Sun Jun  4 15:34:08 2000
***************
*** 138,143 ****
--- 138,145 ----
  }
  #define wcsncat(w1,w2,l) _Xmwcsncat(w1,w2,l)
  
+ #else  /* !__FreeBSD__ */
+ #include <wchar.h>
  #endif /* __FreeBSD__ */
  
  #define MSG1		_XmMMsgTextF_0000
***************
*** 1315,1321 ****
--- 1317,1327 ----
  {
    char * bptr;
    int count = 0;
+ #ifndef NO_MULTIBYTE
    int char_size = 0;
+ #else
+   int char_size = 1;
+ #endif
    
    if (n_bytes <= 0 || ptr == NULL || *ptr == '\0')
      return 0;
***************
*** 1325,1335 ****
--- 1331,1346 ----
    
    bptr = ptr;
    
+ #ifndef NO_MULTIBYTE
    for (bptr = ptr; n_bytes > 0; count++, bptr+= char_size) {
      char_size = mblen(bptr, tf->text.max_char_size);
      if (char_size <= 0) break; /* error */
      n_bytes -= char_size;
    }
+ #else
+   while (*bptr++ && n_bytes--)
+     count++;
+ #endif
    return count;
  }
  
***************
*** 3635,3643 ****
--- 3646,3659 ----
      } else {
        int i, csize;
        wchar_t wc;
+ #ifndef NO_MULTIBYTE
        for (i = 0, csize = mblen(str, tf->text.max_char_size);
  	   i < n;
  	   i += csize, csize=mblen(&(str[i]), tf->text.max_char_size))
+ #else
+       for (i = 0, csize = *str ? 1 : 0; i < n;
+ 	   i += csize, csize = str[i] ? 1 : 0)
+ #endif
  	{
  	  if (csize < 0) 
  	    return False;
***************
*** 3655,3663 ****
--- 3671,3684 ----
       */
      int i, csize;
      if (!use_wchar) {
+ #ifndef NO_MULTIBYTE
        for (i = 0, csize = mblen(str, tf->text.max_char_size);
  	   i < n;
  	   i += csize, csize=mblen(&(str[i]), tf->text.max_char_size))
+ #else
+       for (i = 0, csize = *str ? 1 : 0; i < n;
+ 	   i += csize, csize = str[i] ? 1 : 0)
+ #endif
  	{
  	  if (csize < 0)
  	    return False;
***************
*** 10002,10008 ****
--- 10023,10033 ----
        length = 0;
      } else {
        for(length = 0;num_chars > 0; num_chars--)
+ #ifndef NO_MULTIBYTE
  	length += mblen(&value[length], tf->text.max_char_size);
+ #else
+         length += value[length] ? 1 : 0;
+ #endif
      }
    }
    value[length] = (char)'\0';
*** motif.orig/lib/Xm/TextFSel.c	Wed May  3 05:12:42 2000
--- motif/lib/Xm/TextFSel.c	Wed Jun 28 17:35:31 2000
***************
*** 803,808 ****
--- 803,809 ----
    char * total_value = NULL;
    wchar_t * wc_total_value;
    unsigned long total_length = 0;
+   int wc_total_length;
    Boolean replace = False;
    XmAnyCallbackStruct cb;
  
***************
*** 885,899 ****
  				      insertPosRight, (char *) total_value,
  				      (int)total_length, False);
    } else {
      wc_total_value = (wchar_t*)XtMalloc((unsigned)
! 					total_length * sizeof(wchar_t));
!     /* Note: casting total_length to an int may result in a truncation. */
!     total_length = mbstowcs(wc_total_value, total_value,
! 			    (int)total_length);
!     if (total_length > 0)
        replace = _XmTextFieldReplaceText(tf, ds->event, insertPosLeft, 
  					insertPosRight, (char *)wc_total_value,
! 					(int)total_length, False);
      XtFree((char*)wc_total_value);
    }
    
--- 886,900 ----
  				      insertPosRight, (char *) total_value,
  				      (int)total_length, False);
    } else {
+     wc_total_length = _XmTextFieldCountCharacters(tf, total_value,
+                                                   total_length);
      wc_total_value = (wchar_t*)XtMalloc((unsigned)
! 					wc_total_length * sizeof(wchar_t));
!     wc_total_length = mbstowcs(wc_total_value, total_value, wc_total_length);
!     if (wc_total_length > 0)
        replace = _XmTextFieldReplaceText(tf, ds->event, insertPosLeft, 
  					insertPosRight, (char *)wc_total_value,
! 					wc_total_length, False);
      XtFree((char*)wc_total_value);
    }
    
*** motif.orig/lib/Xm/TextIn.c	Wed May  3 05:12:42 2000
--- motif/lib/Xm/TextIn.c	Sun Jun  4 15:34:21 2000
***************
*** 1302,1310 ****
--- 1302,1315 ----
  #ifdef HAS_WIDECHAR_FUNCTIONS
      int i, csize;
      wchar_t wc;
+ #ifndef NO_MULTIBYTE
      for (i = 0, csize = mblen(str, tw->text.char_size);
  	 i < n;
  	 i += csize, csize=mblen(&(str[i]), tw->text.char_size))
+ #else
+     for (i = 0, csize = *str ? 1 : 0; i < n;
+ 	 i += csize, csize = str[i] ? 1 : 0)
+ #endif
        {
  	if (csize < 0) 
  	  return False;
***************
*** 1320,1328 ****
--- 1325,1338 ----
       * printable. Better than nothing...
       */
      int i, csize;
+ #ifndef NO_MULTIBYTE
      for (i = 0, csize = mblen(str, tw->text.char_size);
  	 i < n;
  	 i += csize, csize=mblen(&(str[i]), tw->text.char_size))
+ #else
+     for (i = 0, csize = *str ? 1 : 0; i < n;
+ 	 i += csize, csize = str[i] ? 1 : 0)
+ #endif
        {
  	if (csize < 0)
  	  return False;
*** motif.orig/lib/Xm/TextOut.c	Wed May  3 05:12:43 2000
--- motif/lib/Xm/TextOut.c	Sun Jun  4 15:34:35 2000
***************
*** 666,672 ****
--- 666,676 ----
      XCharStruct overall;
      
      for (i = from, ptr = block->ptr + from; i < to; i +=csize, ptr += csize) {
+ #ifndef NO_MULTIBYTE
        csize = mblen(ptr, tw->text.char_size);
+ #else
+       csize = *ptr ? 1 : 0;
+ #endif
        if (csize <= 0) break;
        c = (unsigned char) *ptr;
        if (csize == 1) {
***************
*** 741,747 ****
--- 745,755 ----
    
    if (tw->text.char_size != 1) {
      for (i = from, ptr = block->ptr + from; i < to; i +=csize, ptr += csize) {
+ #ifndef NO_MULTIBYTE
        csize = mblen(ptr, tw->text.char_size);
+ #else
+       csize = *ptr ? 1 : 0;
+ #endif
        if (csize <= 0) break;
        c = (unsigned char) *ptr;
        if (csize == 1 && c == '\t')
***************
*** 984,994 ****
  					       end, &block);
      length = block.length;
      if ((int)tw->text.char_size > 1) {
!       for (i = num_chars = 0, num_bytes = mblen(block.ptr, 
! 						(int)tw->text.char_size);
  	   i < length && width < x && num_bytes >= 0; 
  	   i += num_bytes, num_chars++, 
  	   num_bytes = mblen(&block.ptr[i], (int)tw->text.char_size)) {
  	lastwidth = width;
  	width += FindWidth(tw, width, &block, i, i + num_bytes);
        }
--- 992,1010 ----
  					       end, &block);
      length = block.length;
      if ((int)tw->text.char_size > 1) {
!       for (i = num_chars = 0,
! #ifndef NO_MULTIBYTE
! 	   num_bytes = mblen(block.ptr, (int)tw->text.char_size);
! #else
! 	   num_bytes = *block.ptr ? 1 : 0;
! #endif
  	   i < length && width < x && num_bytes >= 0; 
  	   i += num_bytes, num_chars++, 
+ #ifndef NO_MULTIBYTE
  	   num_bytes = mblen(&block.ptr[i], (int)tw->text.char_size)) {
+ #else
+ 	   num_bytes = block.ptr[i] ? 1 : 0) {
+ #endif
  	lastwidth = width;
  	width += FindWidth(tw, width, &block, i, i + num_bytes);
        }
***************
*** 1274,1281 ****
  	       XmsdLeft, 1, True);
  	    (void) (*tw->text.source->ReadSource)
  	      (tw->text.source, position, oldpos, &block);
! 	    num_bytes = mblen(block.ptr, 
! 			      (int)tw->text.char_size);
  	    /* Pitiful error handling, but what else can you do? */
  	    if (num_bytes < 0) num_bytes = 1;
  	    x -= FindWidth(tw, x, &block, 0, num_bytes);
--- 1290,1300 ----
  	       XmsdLeft, 1, True);
  	    (void) (*tw->text.source->ReadSource)
  	      (tw->text.source, position, oldpos, &block);
! #ifndef NO_MULTIBYTE
! 	    num_bytes = mblen(block.ptr, (int)tw->text.char_size);
! #else
! 	    num_bytes = *block.ptr ? 1 : 0;
! #endif
  	    /* Pitiful error handling, but what else can you do? */
  	    if (num_bytes < 0) num_bytes = 1;
  	    x -= FindWidth(tw, x, &block, 0, num_bytes);
***************
*** 2544,2551 ****
--- 2563,2574 ----
  					       end, &block);
      if ((int)tw->text.char_size == 1) num_bytes = 1;
      else {
+ #ifndef NO_MULTIBYTE
        num_bytes = mblen(block.ptr, (int)tw->text.char_size);
        if (num_bytes < 1) num_bytes = 1;
+ #else
+       num_bytes = 1;
+ #endif
      }
      while (block.length > 0) {
        while (num_bytes == 1 && block.ptr[0] == '\t') {
***************
*** 2561,2569 ****
  	    x = newx;
  	    if ((int)tw->text.char_size != 1) { 
  	      /* check if we've got mbyte char */
! 	      num_bytes = mblen(block.ptr, 
! 				(int)tw->text.char_size);
  	      if (num_bytes < 1) num_bytes = 1;
  	    }
  	  }
  	}
--- 2584,2595 ----
  	    x = newx;
  	    if ((int)tw->text.char_size != 1) { 
  	      /* check if we've got mbyte char */
! #ifndef NO_MULTIBYTE
! 	      num_bytes = mblen(block.ptr, (int)tw->text.char_size);
  	      if (num_bytes < 1) num_bytes = 1;
+ #else
+ 	      num_bytes = 1;
+ #endif
  	    }
  	  }
  	}
***************
*** 2616,2624 ****
--- 2642,2654 ----
  	block.length--;
  	block.ptr++;
  	if ((int)tw->text.char_size != 1) {
+ #ifndef NO_MULTIBYTE
  	  num_bytes = mblen(block.ptr, (int)tw->text.char_size);
  	  /* crummy error handling, but ... */
  	  if (num_bytes < 0) num_bytes = 1;
+ #else
+ 	  num_bytes = *block.ptr ? 1 : 0;
+ #endif
  	}
  	if (block.length <= 0) break;
        }
***************
*** 2627,2637 ****
  	  if (block.ptr[length] == '\t') break;
  	}
        } else {
! 	for (length = 0, num_bytes = mblen(block.ptr, 
! 					   (int)tw->text.char_size); 
  	     length < block.length; 
! 	     num_bytes = mblen(&block.ptr[length], 
! 			       (int)tw->text.char_size)) {
  	  if ((num_bytes == 1) && block.ptr[length] == '\t') break;
  	  if (num_bytes == 0) break;
  	  if (num_bytes < 0) num_bytes = 1;
--- 2657,2674 ----
  	  if (block.ptr[length] == '\t') break;
  	}
        } else {
! 	for (length = 0,
! #ifndef NO_MULTIBYTE
!              num_bytes = mblen(block.ptr, (int)tw->text.char_size); 
! #else
! 	     num_bytes = *block.ptr ? 1 : 0;
! #endif
  	     length < block.length; 
! #ifndef NO_MULTIBYTE
! 	     num_bytes = mblen(&block.ptr[length], (int)tw->text.char_size)) {
! #else
! 	     num_bytes = block.ptr[length] ? 1 : 0) {
! #endif
  	  if ((num_bytes == 1) && block.ptr[length] == '\t') break;
  	  if (num_bytes == 0) break;
  	  if (num_bytes < 0) num_bytes = 1;
***************
*** 2651,2658 ****
--- 2688,2699 ----
  	  }
  	} else {
  	  if (newx - data->hoffset < data->leftmargin) {
+ #ifndef NO_MULTIBYTE
  	    num_bytes = mblen(block.ptr, (int)tw->text.char_size);
  	    if (num_bytes < 0) num_bytes = 1;
+ #else
+ 	    num_bytes = *block.ptr ? 1 : 0;
+ #endif
  	    length -= num_bytes;
  	    block.length -= num_bytes;
  	    block.ptr += num_bytes;
***************
*** 2669,2678 ****
  	    newx += FindWidth(tw, newx, &block, i, i+1);
  	  }
  	} else {
! 	  for (i=0, num_bytes = mblen(block.ptr, (int)tw->text.char_size); 
  	       i < length && newx <= rightedge && num_bytes > 0; 
! 	       i += num_bytes, num_bytes = mblen(&block.ptr[i], 
! 						 (int)tw->text.char_size))
  	    newx += FindWidth(tw, newx, &block, i, i + num_bytes);
  	}
  	length = i;
--- 2710,2728 ----
  	    newx += FindWidth(tw, newx, &block, i, i+1);
  	  }
  	} else {
! 	  for (i=0,
! #ifndef NO_MULTIBYTE
! 	       num_bytes = mblen(block.ptr, (int)tw->text.char_size); 
! #else
! 	       num_bytes = *block.ptr ? 1 : 0;
! #endif
  	       i < length && newx <= rightedge && num_bytes > 0; 
! 	       i += num_bytes,
! #ifndef NO_MULTIBYTE
! 	       num_bytes = mblen(&block.ptr[i], (int)tw->text.char_size))
! #else
! 	       num_bytes = block.ptr[i] ? 1 : 0)
! #endif
  	    newx += FindWidth(tw, newx, &block, i, i + num_bytes);
  	}
  	length = i;
***************
*** 2753,2760 ****
--- 2803,2814 ----
        block.length -= length;
        block.ptr += length;
        if ((int)tw->text.char_size != 1) {
+ #ifndef NO_MULTIBYTE
  	num_bytes = mblen(block.ptr, (int)tw->text.char_size);
  	if (num_bytes < 1) num_bytes = 1;
+ #else
+         num_bytes = 1;
+ #endif
        }
      }    
    }
*** motif.orig/lib/Xm/TextStrSo.c	Wed May  3 05:12:43 2000
--- motif/lib/Xm/TextStrSo.c	Sun Jun  4 15:34:42 2000
***************
*** 157,166 ****
    case 2: {
      bits16_ptr = (BITS16 *) characters;
      tmp_bytes = (unsigned char*) bytes;
!     for (num_bytes = mblen((char*)tmp_bytes, max_char_size), 
  	 temp_bits16 = 0; 
  	 num_chars > 0 && num_bytes > 0;
! 	 num_chars--, num_bytes = mblen((char*)tmp_bytes, max_char_size), 
  	 temp_bits16 = 0, bits16_ptr ++) {
        if (num_bytes == 1) {
  	temp_bits16 = (BITS16) *tmp_bytes++;
--- 157,176 ----
    case 2: {
      bits16_ptr = (BITS16 *) characters;
      tmp_bytes = (unsigned char*) bytes;
!     for (
! #ifndef NO_MULTIBYTE
! 	 num_bytes = mblen((char*)tmp_bytes, max_char_size), 
! #else
! 	 num_bytes = *tmp_bytes ? 1 : 0,
! #endif
  	 temp_bits16 = 0; 
  	 num_chars > 0 && num_bytes > 0;
! 	 num_chars--,
! #ifndef NO_MULTIBYTE
! 	 num_bytes = mblen((char*)tmp_bytes, max_char_size), 
! #else
! 	 num_bytes = *tmp_bytes ? 1 : 0,
! #endif
  	 temp_bits16 = 0, bits16_ptr ++) {
        if (num_bytes == 1) {
  	temp_bits16 = (BITS16) *tmp_bytes++;
*** motif.orig/lib/Xm/ToggleB.c	Wed May  3 05:12:43 2000
--- motif/lib/Xm/ToggleB.c	Sun Jun 18 21:25:56 2000
***************
*** 61,66 ****
--- 61,67 ----
  #include "LabelI.h"
  #include "MenuProcI.h"
  #include "MenuStateI.h"
+ #include "MenuUtilI.h"
  #include "PrimitiveI.h"
  #include "RepTypeI.h"
  #include "TravActI.h"
***************
*** 2134,2144 ****
      y = (int)((w->core.height - w->toggle.indicator_dim))/2;
    else
      {
        int fudge = Xm3D_ENHANCE_PIXEL;
  
!       y = w->label.TextRect.y;
!       if (Lab_IsMenupane(w))
! 	y += (w->toggle.indicator_dim + 2) / 4; /* adjust in menu */
  
        /* CR 2337: Keep large indicators inside the toggle. */
        /*	Is this definition of fudge right??? */
--- 2135,2155 ----
      y = (int)((w->core.height - w->toggle.indicator_dim))/2;
    else
      {
+       /* Center indicator vertically next to the first line of text. */
        int fudge = Xm3D_ENHANCE_PIXEL;
+       Dimension text_height;
+       int line_count, height_diff;
  
!       text_height = XmStringHeight(w->label.font, w->label._label);
!       if ((line_count = XmStringLineCount(w->label._label)) < 1)
! 	line_count = 1;
!       
!       height_diff = ((int)text_height / line_count) -
!                     (int)w->toggle.indicator_dim;
!       if (height_diff < 0)
! 	height_diff = 0;
!       
!       y = w->label.TextRect.y + (height_diff / 2);
  
        /* CR 2337: Keep large indicators inside the toggle. */
        /*	Is this definition of fudge right??? */
*** motif.orig/lib/Xm/ToggleBG.c	Wed May  3 05:12:43 2000
--- motif/lib/Xm/ToggleBG.c	Sun Jun 18 21:25:56 2000
***************
*** 63,68 ****
--- 63,69 ----
  #include "LabelI.h"
  #include "MenuProcI.h"
  #include "MenuStateI.h"
+ #include "MenuUtilI.h"
  #include "RepTypeI.h"
  #include "SyntheticI.h"
  #include "ToggleBGI.h"
***************
*** 2545,2555 ****
        (int)((w->rectangle.height - TBG_IndicatorDim(w)))/2;
    else
      {
        int fudge = Xm3D_ENHANCE_PIXEL;
  
!       y = w->rectangle.y + LabG_TextRect(w).y;
!       if (LabG_IsMenupane(w))
! 	y += (TBG_IndicatorDim(w) + 2) / 4; /* adjust in menu */
  
        /* CR 2337: Keep large indicators inside the toggle. */
        /*	Is this definition of fudge right??? */
--- 2546,2565 ----
        (int)((w->rectangle.height - TBG_IndicatorDim(w)))/2;
    else
      {
+       /* Center indicator vertically next to the first line of text. */
        int fudge = Xm3D_ENHANCE_PIXEL;
+       Dimension text_height;
+       int line_count, height_diff;
  
!       text_height = XmStringHeight(LabG_Font(w), LabG__label(w));
!       if ((line_count = XmStringLineCount(LabG__label(w))) < 1)
! 	line_count = 1;
!       
!       height_diff = ((int)text_height / line_count) - (int)TBG_IndicatorDim(w);
!       if (height_diff < 0)
! 	height_diff = 0;
!       
!       y = w->rectangle.y + LabG_TextRect(w).y + (height_diff / 2);
  
        /* CR 2337: Keep large indicators inside the toggle. */
        /*	Is this definition of fudge right??? */
*** motif.orig/lib/Xm/Transfer.c	Wed May  3 05:12:43 2000
--- motif/lib/Xm/Transfer.c	Sun Jun  4 16:58:31 2000
***************
*** 2145,2151 ****
  	current = XtParent(current)) {
        if (XtIsShell(current)) {
  	XGetWindowProperty(XtDisplay(current), XtWindow(current), 
! 			   XA_WM_CLASS, 0L, 100000, False,
  			   (Atom) AnyPropertyType, 
  			   &cs -> type,
  			   &cs -> format,
--- 2145,2151 ----
  	current = XtParent(current)) {
        if (XtIsShell(current)) {
  	XGetWindowProperty(XtDisplay(current), XtWindow(current), 
! 			   XA_WM_CLASS, 0L, 100000L, False,
  			   (Atom) AnyPropertyType, 
  			   &cs -> type,
  			   &cs -> format,
***************
*** 2169,2175 ****
  	current = XtParent(current)) {
        if (XtIsShell(current)) {
  	XGetWindowProperty(XtDisplay(current), XtWindow(current), 
! 			   XA_WM_NAME, 0L, 100000, False,
  			   (Atom) AnyPropertyType, 
  			   &type,
  			   &format,
--- 2169,2175 ----
  	current = XtParent(current)) {
        if (XtIsShell(current)) {
  	XGetWindowProperty(XtDisplay(current), XtWindow(current), 
! 			   XA_WM_NAME, 0L, 100000L, False,
  			   (Atom) AnyPropertyType, 
  			   &type,
  			   &format,
*** motif.orig/lib/Xm/VendorS.c	Wed May  3 05:12:43 2000
--- motif/lib/Xm/VendorS.c	Sun Jun  4 15:39:09 2000
***************
*** 1017,1023 ****
  	        Widget incrWid = modals[i+incr].wid;
  		/* if it's not the shell, or it is the shell but some 
  		   other entry for another grab */
! 		if ( (incrWid != shell) || (modals[i].ve != ve) )    
  		  {
  		      if  ((ve != NULL) && (modals[i+incr].grabber == ve))
                          {   
--- 1017,1023 ----
  	        Widget incrWid = modals[i+incr].wid;
  		/* if it's not the shell, or it is the shell but some 
  		   other entry for another grab */
! 		if ( (incrWid != shell) || (modals[i+incr].ve != ve) )    
  		  {
  		      if  ((ve != NULL) && (modals[i+incr].grabber == ve))
                          {   
*** motif.orig/lib/Xm/XmIm.c	Wed May  3 05:12:43 2000
--- motif/lib/Xm/XmIm.c	Sun Jun  4 15:41:37 2000
***************
*** 257,263 ****
  static void regist_real_callback(Widget w,
                       XIMProc call,
                       int swc);
! static XIMProc get_real_callback(Widget w,
                    int swc,
  		  Widget *real_widget);
  static void move_preedit_string(XmImXICInfo icp,
--- 257,263 ----
  static void regist_real_callback(Widget w,
                       XIMProc call,
                       int swc);
! static XICProc get_real_callback(Widget w,
                    int swc,
  		  Widget *real_widget);
  static void move_preedit_string(XmImXICInfo icp,
***************
*** 1173,1179 ****
    int flags = 0;
    Pixel bg;
    char *ret;
!   unsigned long mask;
    Boolean unrecognized = False;
    
    p = w;
--- 1173,1179 ----
    int flags = 0;
    Pixel bg;
    char *ret;
!   unsigned long mask = 0;
    Boolean unrecognized = False;
    
    p = w;
***************
*** 1273,1279 ****
      }
      if (XtIsRealized(p)) {
        if (XmIsDialogShell(p)) {
- 	int i;
  	for (i = 0; 
  	     i < ((CompositeWidget)p)->composite.num_children; 
  	     i++)
--- 1273,1278 ----
***************
*** 1432,1438 ****
  		       XPointer client_data,
  		       XPointer call_data)
  {
!   XIMProc proc;
    Widget real = NULL;
  
    if (!client_data){
--- 1431,1437 ----
  		       XPointer client_data,
  		       XPointer call_data)
  {
!   XICProc proc;
    Widget real = NULL;
  
    if (!client_data){
***************
*** 1451,1457 ****
  		      XPointer client_data,
  		      XPointer call_data)
  {
!   XIMProc proc;
    Widget w = (Widget)client_data;
    XmImShellInfo im_info;
    XmImXICInfo icp;
--- 1450,1456 ----
  		      XPointer client_data,
  		      XPointer call_data)
  {
!   XICProc proc;
    Widget w = (Widget)client_data;
    XmImShellInfo im_info;
    XmImXICInfo icp;
***************
*** 1482,1488 ****
  		      XPointer client_data,
  		      XPointer call_data)
  {
!   XIMProc proc;
    Widget w = (Widget)client_data;
    XmImShellInfo im_info;
    XmImXICInfo icp;
--- 1481,1487 ----
  		      XPointer client_data,
  		      XPointer call_data)
  {
!   XICProc proc;
    Widget w = (Widget)client_data;
    XmImShellInfo im_info;
    XmImXICInfo icp;
***************
*** 1609,1615 ****
  		       XPointer client_data,
  		       XPointer call_data)
  {
!   XIMProc proc;
    Widget w = (Widget)client_data;
    XmImShellInfo im_info;
    XmImXICInfo icp;
--- 1608,1614 ----
  		       XPointer client_data,
  		       XPointer call_data)
  {
!   XICProc proc;
    Widget w = (Widget)client_data;
    XmImShellInfo im_info;
    XmImXICInfo icp;
***************
*** 1648,1654 ****
      (*proc)(xic, (XPointer)real, call_data);
  }
  
! static XIMProc
  get_real_callback(Widget w,
                    int swc,
  		  Widget *real_widget)
--- 1647,1653 ----
      (*proc)(xic, (XPointer)real, call_data);
  }
  
! static XICProc
  get_real_callback(Widget w,
                    int swc,
  		  Widget *real_widget)
***************
*** 1659,1667 ****
    XmImRefRec refs;
  
    if ((im_info = get_im_info(w, False)) == NULL)
!         return (XIMProc)NULL;
    if ((icp = im_info->shell_xic) == NULL)
!         return (XIMProc)NULL;
  
    if (*real_widget == NULL) 
      *real_widget = XtWindowToWidget(XtDisplay(w), icp->focus_window);
--- 1658,1666 ----
    XmImRefRec refs;
  
    if ((im_info = get_im_info(w, False)) == NULL)
!         return (XICProc)NULL;
    if ((icp = im_info->shell_xic) == NULL)
!         return (XICProc)NULL;
  
    if (*real_widget == NULL) 
      *real_widget = XtWindowToWidget(XtDisplay(w), icp->focus_window);
***************
*** 1679,1687 ****
    }
  
    if (refs.callbacks[target])
!     return (XIMProc)refs.callbacks[target][swc];
    else
!     return (XIMProc)NULL;
  }
  
  static void
--- 1678,1686 ----
    }
  
    if (refs.callbacks[target])
!     return (XICProc)refs.callbacks[target][swc];
    else
!     return (XICProc)NULL;
  }
  
  static void
***************
*** 1813,1819 ****
    PreeditBuffer pb = icp->preedit_buffer;
    XIMPreeditDrawCallbackStruct draw_data;
    XIMText text;
!   XIMProc proc;
  
    proc = get_real_callback(wfrom, PREEDIT_DONE, &wfrom);
    if (proc)
--- 1812,1818 ----
    PreeditBuffer pb = icp->preedit_buffer;
    XIMPreeditDrawCallbackStruct draw_data;
    XIMText text;
!   XICProc proc;
  
    proc = get_real_callback(wfrom, PREEDIT_DONE, &wfrom);
    if (proc)
***************
*** 1836,1842 ****
    draw_data.text = &text;
    proc = get_real_callback(wto, PREEDIT_DRAW, &wto);
    if (proc)
!     (*proc)(icp->xic, (XPointer)wto, &draw_data);
  }   
  
  
--- 1835,1841 ----
    draw_data.text = &text;
    proc = get_real_callback(wto, PREEDIT_DRAW, &wto);
    if (proc)
!     (*proc)(icp->xic, (XPointer)wto, (XPointer)&draw_data);
  }   
  
  
*** motif.orig/lib/Xm/Xmos.c	Wed May  3 05:12:44 2000
--- motif/lib/Xm/Xmos.c	Sun Jun  4 15:45:23 2000
***************
*** 417,424 ****
--- 417,428 ----
  	  }
  	prev2Char = prevChar;
  	prevChar = *lookAheadPtr;
+ #ifndef NO_MULTIBYTE
  	lookAheadPtr += ((MB_CUR_MAX > 1) ? 
  			 abs(mblen(lookAheadPtr, MB_CUR_MAX)) : 1);
+ #else
+ 	lookAheadPtr++;
+ #endif
        } 
    } while (!hasWildcards  &&  *lookAheadPtr++);
    
***************
*** 559,565 ****
--- 563,573 ----
    bufPtr = outputBuf;
    *bufPtr++ = '^';
    
+ #ifndef NO_MULTIBYTE
    while ((len = mblen(pattern, MB_CUR_MAX)) > 0)
+ #else
+   while ((len = *pattern ? 1 : 0))
+ #endif
      {
        if (len <= 1)
  	{
***************
*** 990,996 ****
  _XmOSFileCompare(XmConst void *sp1,
  		 XmConst void *sp2)
  {
!   return strcmp(*((String *) sp1), *((String *) sp2));
  }
  
  /*************************************************************************
--- 998,1004 ----
  _XmOSFileCompare(XmConst void *sp1,
  		 XmConst void *sp2)
  {
!   return strcmp(*((XmConst String *) sp1), *((XmConst String *) sp2));
  }
  
  /*************************************************************************
*** motif.orig/lib/Xm/XmRenderT.c	Wed May  3 05:12:43 2000
--- motif/lib/Xm/XmRenderT.c	Sun Jun  4 15:41:59 2000
***************
*** 2399,2405 ****
      if (_XmRendBG(rendition) == XmAS_IS)
        str = "-1, ";
      else {
!       sprintf(temp, "%d, ", _XmRendBG(rendition));
        str = temp;
      }
      size = strlen(str);
--- 2399,2405 ----
      if (_XmRendBG(rendition) == XmAS_IS)
        str = "-1, ";
      else {
!       sprintf(temp, "%ld, ", _XmRendBG(rendition));
        str = temp;
      }
      size = strlen(str);
***************
*** 2408,2414 ****
      if (_XmRendFG(rendition) == XmAS_IS)
        str = "-1, ";
      else {
!       sprintf(temp, "%d, ", _XmRendFG(rendition));
        str = temp;
      }
      size = strlen(str);
--- 2408,2414 ----
      if (_XmRendFG(rendition) == XmAS_IS)
        str = "-1, ";
      else {
!       sprintf(temp, "%ld, ", _XmRendFG(rendition));
        str = temp;
      }
      size = strlen(str);
*** motif.orig/lib/Xm/XmString.c	Wed May  3 05:12:43 2000
--- motif/lib/Xm/XmString.c	Sun Jun  4 15:44:25 2000
***************
*** 2654,2664 ****
--- 2654,2672 ----
  	else {
  	  int cnt = 0;
  	  int len;
+ #ifndef NO_MULTIBYTE
  	  while (byte_count > 0 && (len = mblen(s, MB_CUR_MAX)) > 0) {
  	    cnt++;
  	    s += len;
  	    byte_count -= len;
  	  }
+ #else
+ 	  while (byte_count > 0 && *s) {
+ 	    cnt++;
+ 	    s++;
+ 	    byte_count--;
+ 	  }
+ #endif
  	  return cnt;
  	}
        }
***************
*** 3389,3403 ****
  {
    char *a = (char*) _XmEntryTextGet(seg); 
    char *b = (char*) _XmEntryTextGet(under_seg);
    int i, j, k, begin, max, width;
    unsigned int seg_len, under_seg_len;
    Boolean fail;
    
!   if (!((_XmEntryTag(seg) == _XmEntryTag(under_seg)) ||
! 	((strcmp(_XmEntryTag(seg), XmFONTLIST_DEFAULT_TAG) == 0) &&
  	 _XmStringIsCurrentCharset(_XmEntryTag(under_seg))) ||
  	((strcmp(_XmEntryTag(under_seg), XmFONTLIST_DEFAULT_TAG) == 0) &&
! 	 _XmStringIsCurrentCharset(_XmEntryTag(seg)))))
      return;
    
    seg_len = _XmEntryByteCountGet(seg);
--- 3397,3419 ----
  {
    char *a = (char*) _XmEntryTextGet(seg); 
    char *b = (char*) _XmEntryTextGet(under_seg);
+   char *seg_tag = _XmEntryTag(seg);
    int i, j, k, begin, max, width;
    unsigned int seg_len, under_seg_len;
    Boolean fail;
    
!   /* Metro Link fix: _XmEntryTag(seg) can be NULL, but the original Motif
!    * code never checked for that.  We check, and if it is NULL, we treat
!    * it as if it was set to XmFONTLIST_DEFAULT_TAG. */
!   
!   if (seg_tag == NULL)
!     seg_tag = XmFONTLIST_DEFAULT_TAG;
!   
!   if (!((seg_tag == _XmEntryTag(under_seg)) ||
! 	((strcmp(seg_tag, XmFONTLIST_DEFAULT_TAG) == 0) &&
  	 _XmStringIsCurrentCharset(_XmEntryTag(under_seg))) ||
  	((strcmp(_XmEntryTag(under_seg), XmFONTLIST_DEFAULT_TAG) == 0) &&
! 	 _XmStringIsCurrentCharset(seg_tag))))
      return;
    
    seg_len = _XmEntryByteCountGet(seg);
***************
*** 3500,3511 ****
--- 3516,3535 ----
  	    break;
  	  }
        } else {
+ #ifndef NO_MULTIBYTE
  	len_a = mblen(&a[i], MB_CUR_MAX);
+ #else
+ 	len_a = a[i] ? 1 : 0;
+ #endif
  	if (len_a < 1) return;
  	len_a1 = len_a;
  	
  	for (j = 0; j < under_seg_len; j += len_b) {
+ #ifndef NO_MULTIBYTE
  	  len_b = mblen(&b[j], MB_CUR_MAX);
+ #else
+ 	  len_b = b[j] ? 1 : 0;
+ #endif
  	  if (len_b < 1) return;
  	  
  	  if (len_b == len_a1) {
***************
*** 3857,3863 ****
--- 3881,3891 ----
  	      p += seg_len; 
  	      for (i = 0; i < seg_len; i += len)
  		{
+ #ifndef NO_MULTIBYTE
  		  len = mblen(q, MB_CUR_MAX);
+ #else
+ 		  len = *q ? 1 : 0;
+ #endif
  		  if (len < 1) /* Something went wrong, just return for now. */
  		    return;
              
***************
*** 7394,7400 ****
  	      /* Don't need this, since dialog_title will be converted from
  	       *   original XmString to compound text.
  	       */
! 	      XtFree( (char *) tag) ;
  	      XtFree( (char *) text) ;
  	      text = NULL ;
  	    }
--- 7422,7429 ----
  	      /* Don't need this, since dialog_title will be converted from
  	       *   original XmString to compound text.
  	       */
! 	      if (tag != NULL)
! 	        XtFree( (char *) tag) ;
  	      XtFree( (char *) text) ;
  	      text = NULL ;
  	    }
***************
*** 7714,7720 ****
--- 7743,7753 ----
    halt = (end_ptr && (ptr >= (char*) end_ptr));
    while (!halt && (wide_char ? *((wchar_t*) ptr) : *ptr))
      {
+ #ifndef NO_MULTIBYTE
        int len = (wide_char ? sizeof(wchar_t) : mblen(ptr, MB_CUR_MAX));
+ #else
+       int len = (wide_char ? sizeof(wchar_t) : 1);
+ #endif
        advanced = False;
  
        /* If we have an invalid character, treat it as a single byte. */
***************
*** 8037,8043 ****
--- 8070,8080 ----
  	      else
  		unparse_text(result, length, output_type, 
  			     XmSTRING_COMPONENT_TEXT, 
+ #ifndef NO_MULTIBYTE
  			     mblen((char*) pat->pattern, MB_CUR_MAX),
+ #else
+ 			     *((char *) pat->pattern) ? 1: 0,
+ #endif
  			     pat->pattern);
  	      
  	      /* Skip all but the last matched component. */
*** motif.orig/lib/Xm/XmStringFunc.c	Wed May  3 05:12:43 2000
--- motif/lib/Xm/XmStringFunc.c	Sun Jun  4 15:44:39 2000
***************
*** 395,408 ****
--- 395,416 ----
        else
  	comp_type = XmSTRING_COMPONENT_TEXT;
        if ((text_end == NULL) || (ptr < (char*) text_end))
+ #ifndef NO_MULTIBYTE
  	len = mblen(ptr, MB_CUR_MAX);
+ #else
+         len = *ptr ? 1 : 0;
+ #endif
        break;
  
      case XmMULTIBYTE_TEXT:
        /* In Motif 2.0 dynamic switching of locales isn't supported. */
        comp_type = XmSTRING_COMPONENT_LOCALE_TEXT;
        if ((text_end == NULL) || (ptr < (char*) text_end))
+ #ifndef NO_MULTIBYTE
  	len = mblen(ptr, MB_CUR_MAX);
+ #else
+         len = *ptr ? 1 : 0;
+ #endif
        break;
  
      case XmWIDECHAR_TEXT:
*** motif.orig/lib/Xm/XpmI.h	Fri Apr 28 11:05:21 2000
--- motif/lib/Xm/XpmI.h	Sun Jun  4 15:47:23 2000
***************
*** 115,121 ****
  extern FILE *popen();
  #endif
  
! #if defined(SYSV) || defined(SVR4) || defined(VMS) || defined(WIN32)
  #include <string.h>
  
  #ifndef index
--- 115,121 ----
  extern FILE *popen();
  #endif
  
! #if defined(SYSV) || defined(SVR4) || defined(VMS) || defined(WIN32) || defined (_SVID_SOURCE)
  #include <string.h>
  
  #ifndef index
*** motif.orig/localized/util/mkcatdefs.c	Wed May  3 05:12:44 2000
--- motif/localized/util/mkcatdefs.c	Sat Jun  3 19:47:45 2000
***************
*** 59,67 ****
  
  #include <stdio.h>
  #include <stdlib.h>
  #include <locale.h>
  #include <ctype.h>
- #include <ctype.h>
  
  #ifdef aix
  #include <sys/dir.h>
--- 59,67 ----
  
  #include <stdio.h>
  #include <stdlib.h>
+ #include <unistd.h>
  #include <locale.h>
  #include <ctype.h>
  
  #ifdef aix
  #include <sys/dir.h>
***************
*** 331,337 ****
  	
  	sscanf (cp+3+len, "%s", setname);
  	if (inclfile) 
! 	  fprintf (outfp, "\n/* definitions for set %s */\n", setname, "");
  	if (isdigit(setname[0])) {
  	  cpt = setname;
  	  do  {
--- 331,337 ----
  	
  	sscanf (cp+3+len, "%s", setname);
  	if (inclfile) 
! 	  fprintf (outfp, "\n/* definitions for set %s */\n", setname);
  	if (isdigit(setname[0])) {
  	  cpt = setname;
  	  do  {
***************
*** 376,382 ****
  	    }
  	  } while (*(cpt += len));
  	  if (inclfile)
! 	    fprintf (outfp, "#define %s %d\n\n", setname, (char *)setno);
  	  symbflg = 1;
  	}
  #ifdef aix
--- 376,382 ----
  	    }
  	  } while (*(cpt += len));
  	  if (inclfile)
! 	    fprintf (outfp, "#define %s %d\n\n", setname, setno);
  	  symbflg = 1;
  	}
  #ifdef aix
***************
*** 428,434 ****
  	    cp += strlen(msgname);
  	    fprintf (msgfp,"%d%s", msgno,cp);
  	    if (inclfile)
! 	      fprintf (outfp, "#define %s %d\n", msgname, (char *)msgno);
  	    symbflg = 1;
  	    if (chkcontin(line))
  	      contin = 1;
--- 428,434 ----
  	    cp += strlen(msgname);
  	    fprintf (msgfp,"%d%s", msgno,cp);
  	    if (inclfile)
! 	      fprintf (outfp, "#define %s %d\n", msgname, msgno);
  	    symbflg = 1;
  	    if (chkcontin(line))
  	      contin = 1;
***************
*** 455,461 ****
  	      errflg = 1;
  	      if (n == 0)
  		fprintf(stderr, "mkcatdefs: %s is an invalid identifier\n", 
! 			msgno);
  	      else if (n == msgno) 
  		fprintf(stderr,
  			"mkcatdefs: message id %s already assigned to identifier\n", 
--- 455,461 ----
  	      errflg = 1;
  	      if (n == 0)
  		fprintf(stderr, "mkcatdefs: %s is an invalid identifier\n", 
! 			msgname);
  	      else if (n == msgno) 
  		fprintf(stderr,
  			"mkcatdefs: message id %s already assigned to identifier\n", 
*** motif.orig/localized/util/mkmsgcat.c	Wed May  3 08:49:05 2000
--- motif/localized/util/mkmsgcat.c	Sat Jun  3 19:48:22 2000
***************
*** 40,45 ****
--- 40,46 ----
  
  #include <stdio.h>
  #include <string.h>
+ #include <ctype.h>
  char buf[1024];
  
  char *OSF_COPYRIGHT = "$\n\
*** motif.orig/tools/wml/Imakefile	Wed May  3 05:13:06 2000
--- motif/tools/wml/Imakefile	Sat Jun  3 18:30:06 2000
***************
*** 35,42 ****
  XCOMM POSSIBILITY OF SUCH DAMAGES.
  
  INCLUDES = -I. -I$(INCLUDESRC) -I$(MINCLUDESRC) -I$(MLIBSRC) -I$(MTOP)/include
! DEPLIBS = $(DEPXMLIB)  $(DEPXTOOLLIB) $(DEPXLIB)
! LOCAL_LIBRARIES = $(XMLIB) $(XTOOLLIB) $(XPLIB) $(XLIB)
  
   
  SRCS1 =	wml.c		wmlouth.c	wmloutmm.c \
--- 35,42 ----
  XCOMM POSSIBILITY OF SUCH DAMAGES.
  
  INCLUDES = -I. -I$(INCLUDESRC) -I$(MINCLUDESRC) -I$(MLIBSRC) -I$(MTOP)/include
! DEPLIBS = XmClientDepLibs
! LOCAL_LIBRARIES = XmClientLibs
  
   
  SRCS1 =	wml.c		wmlouth.c	wmloutmm.c \
***************
*** 109,117 ****
  	$(YACC) -d $(YACCFLAGS) Uil.y
  	$(MV) y.tab.c UilLexPars.c
  	$(MV) y.tab.h UilLexPars.h
! 	$(CLIENTENVSETUP) ./wmluiltok < Uil.y > tokens.dat
  	$(RM) wml-uil.mm
! 	$(CLIENTENVSETUP) ./wml $(TABLE)
  	$(RM) tokens.dat
  
  $(WMDTABLE):	wmldbcreate
--- 109,117 ----
  	$(YACC) -d $(YACCFLAGS) Uil.y
  	$(MV) y.tab.c UilLexPars.c
  	$(MV) y.tab.h UilLexPars.h
! 	./wmluiltok < Uil.y > tokens.dat
  	$(RM) wml-uil.mm
! 	./wml $(TABLE)
  	$(RM) tokens.dat
  
  $(WMDTABLE):	wmldbcreate
*** motif.orig/tools/wml/wml.c	Wed May  3 05:13:06 2000
--- motif/tools/wml/wml.c	Sat Jun  3 19:50:55 2000
***************
*** 271,277 ****
  
  }
  
! yywrap()
  {
  return(1);
  }
--- 271,277 ----
  
  }
  
! int yywrap()
  {
  return(1);
  }
*** motif.orig/tools/wml/wmldbcreate.c	Wed May  3 05:13:06 2000
--- motif/tools/wml/wmldbcreate.c	Sat Jun  3 19:51:20 2000
***************
*** 113,119 ****
  char outfilename[80];
  char debugfilename[80];
  
! main(argc, argv)
  int argc;
  char **argv;
  {
--- 113,119 ----
  char outfilename[80];
  char debugfilename[80];
  
! int main(argc, argv)
  int argc;
  char **argv;
  {
***************
*** 217,222 ****
--- 217,224 ----
      emit_ints (Enumval_Values_Table);
  
      exit (0);
+ 
+     return 0;    /* make compiler happy */
  }
  
  
*** motif.orig/tools/wml/wmllex.l	Wed May  3 05:13:06 2000
--- motif/tools/wml/wmllex.l	Sat Jun  3 19:53:13 2000
***************
*** 42,48 ****
  #endif
  
  #ifndef XmConst
! #if (defined(__STDC__) && __STDC__)  ||  !defined( NO_CONST )
  #define XmConst const
  #else
  #define XmConst
--- 42,48 ----
  #endif
  
  #ifndef XmConst
! #if defined(__STDC__) || !defined( NO_CONST )
  #define XmConst const
  #else
  #define XmConst
*** motif.orig/tools/wml/wmlouth.c	Wed May  3 05:13:06 2000
--- motif/tools/wml/wmlouth.c	Sat Jun  3 19:53:56 2000
***************
*** 92,97 ****
--- 92,98 ----
  void wmlOutputUilSymNam ();
  void wmlOutputUilSymEnum ();
  void wmlOutputUilSymCSet ();
+ int wmlResolveCtlIsMember (WmlClassDefPtr, WmlClassCtrlDefPtr);
  
  /*
   * globals
*** motif.orig/tools/wml/wmlparse.y	Wed May  3 05:13:06 2000
--- motif/tools/wml/wmlparse.y	Sat Jun  3 19:55:24 2000
***************
*** 53,69 ****
  #endif
  
  #ifndef XmConst
! #if (defined(__STDC__) && __STDC__)  ||  !defined( NO_CONST )
  #define XmConst const
  #else
  #define XmConst
  #endif /* __STDC__ */
  #endif /* XmConst */
  
  /*
   * Undefine NULL, since it is defined in stdio
   */
  #undef NULL
  
  %}
  
--- 53,71 ----
  #endif
  
  #ifndef XmConst
! #if defined(__STDC__) || !defined( NO_CONST )
  #define XmConst const
  #else
  #define XmConst
  #endif /* __STDC__ */
  #endif /* XmConst */
  
+ #if !defined(__STDC__)
  /*
   * Undefine NULL, since it is defined in stdio
   */
  #undef NULL
+ #endif
  
  %}
  
*** motif.orig/tools/wml/wmlsynbld.c	Wed May  3 05:13:06 2000
--- motif/tools/wml/wmlsynbld.c	Sat Jun  3 19:55:53 2000
***************
*** 784,790 ****
  		rdesc->exclude = WmlAttributeFalse;
  		break;
  	    default:
! 		printf ("\nwmlAddClassResourceAttribute: bad EXCLUDE value %d",
  			excval);
  		return;
  		break;
--- 784,790 ----
  		rdesc->exclude = WmlAttributeFalse;
  		break;
  	    default:
! 		printf ("\nwmlAddClassResourceAttribute: bad EXCLUDE value %ld",
  			excval);
  		return;
  		break;
***************
*** 881,887 ****
  		break;
  	    default:
  		printf
! 		    ("\nwmlAddResourceAttribute: bad XRMRESOURCE value %d",
  		     xrmval);
  		return;
  		break;
--- 881,887 ----
  		break;
  	    default:
  		printf
! 		    ("\nwmlAddResourceAttribute: bad XRMRESOURCE value %ld",
  		     xrmval);
  		return;
  		break;
***************
*** 969,975 ****
  		break;
  	    default:
  		printf
! 		    ("\nwmlAddDatatypeAttribute: bad XRMRESOURCE value %d",
  		     xrmval);
  		return;
  		break;
--- 969,975 ----
  		break;
  	    default:
  		printf
! 		    ("\nwmlAddDatatypeAttribute: bad XRMRESOURCE value %ld",
  		     xrmval);
  		return;
  		break;
***************
*** 1216,1222 ****
  		break;
  	    default:
  		printf
! 		    ("\nwmlAddCharsetAttribute: bad DIRECTION value %d",
  		     atrval);
  		return;
  		break;
--- 1216,1222 ----
  		break;
  	    default:
  		printf
! 		    ("\nwmlAddCharsetAttribute: bad DIRECTION value %ld",
  		     atrval);
  		return;
  		break;
***************
*** 1234,1240 ****
  		break;
  	    default:
  		printf
! 		    ("\nwmlAddCharsetAttribute: bad PARSEDIRECTION value %d",
  		     atrval);
  		return;
  		break;
--- 1234,1240 ----
  		break;
  	    default:
  		printf
! 		    ("\nwmlAddCharsetAttribute: bad PARSEDIRECTION value %ld",
  		     atrval);
  		return;
  		break;
***************
*** 1255,1261 ****
  		break;
  	    default:
  		printf
! 		    ("\nwmlAddCharsetAttribute: bad CHARACTERSIZE value %d",
  		     atrval);
  		return;
  		break;
--- 1255,1261 ----
  		break;
  	    default:
  		printf
! 		    ("\nwmlAddCharsetAttribute: bad CHARACTERSIZE value %ld",
  		     atrval);
  		return;
  		break;
*** motif.orig/tools/wml/wmluiltok.l	Wed May  3 05:13:06 2000
--- motif/tools/wml/wmluiltok.l	Sat Jun  3 19:57:16 2000
***************
*** 40,49 ****
  
  #if defined(__STDC__)
  #include <string.h>
  #endif
  
  #ifndef XmConst
! #if (defined(__STDC__) && __STDC__)  ||  !defined( NO_CONST )
  #define XmConst const
  #else
  #define XmConst
--- 40,50 ----
  
  #if defined(__STDC__)
  #include <string.h>
+ #include <stdlib.h>
  #endif
  
  #ifndef XmConst
! #if defined(__STDC__) || !defined( NO_CONST )
  #define XmConst const
  #else
  #define XmConst
***************
*** 186,192 ****
  add_token (t)					/* keep sorted by name */
      Token t;
  {
!     int i, j, k;
  
      for (j=0; j<used; j++)			/* for each token */
      {
--- 187,193 ----
  add_token (t)					/* keep sorted by name */
      Token t;
  {
!     int i, j;
  
      for (j=0; j<used; j++)			/* for each token */
      {
***************
*** 210,218 ****
  
  
  
! yywrap ()
  {
!     int i, j, k;
  
      for (i=0; i<used; i++)
  	 { 
--- 211,219 ----
  
  
  
! int yywrap ()
  {
!     int i;
  
      for (i=0; i<used; i++)
  	 { 
